"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/pureimage/dist/pureimage-umd.cjs
var require_pureimage_umd = __commonJS({
  "node_modules/pureimage/dist/pureimage-umd.cjs"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports, require("fs"), require("util"), require("stream"), require("zlib"), require("assert"), require("buffer")) : typeof define === "function" && define.amd ? define(["exports", "fs", "util", "stream", "zlib", "assert", "buffer"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.PureImage = {}, global2.require$$0, global2.util, global2.Stream, global2.zlib, global2.require$$0$1, global2.require$$1));
    })(exports, function(exports2, require$$0, util, Stream, zlib, require$$0$1, require$$1) {
      "use strict";
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : { "default": e };
      }
      __name(_interopDefaultLegacy, "_interopDefaultLegacy");
      var require$$0__default = /* @__PURE__ */ _interopDefaultLegacy(require$$0);
      var util__default = /* @__PURE__ */ _interopDefaultLegacy(util);
      var Stream__default = /* @__PURE__ */ _interopDefaultLegacy(Stream);
      var zlib__default = /* @__PURE__ */ _interopDefaultLegacy(zlib);
      var require$$0__default$1 = /* @__PURE__ */ _interopDefaultLegacy(require$$0$1);
      var require$$1__default = /* @__PURE__ */ _interopDefaultLegacy(require$$1);
      const NAMED_COLORS = {
        transparent: 0,
        aliceblue: 4042850303,
        antiquewhite: 4209760255,
        aqua: 16777215,
        aquamarine: 2147472639,
        azure: 4043309055,
        beige: 4126530815,
        bisque: 4293182719,
        black: 255,
        blanchedalmond: 4293643775,
        blue: 65535,
        blueviolet: 2318131967,
        brown: 2771004159,
        burlywood: 3736635391,
        cadetblue: 1604231423,
        chartreuse: 2147418367,
        chocolate: 3530104575,
        coral: 4286533887,
        cornflowerblue: 1687547391,
        cornsilk: 4294499583,
        crimson: 3692313855,
        cyan: 16777215,
        darkblue: 35839,
        darkcyan: 9145343,
        darkgoldenrod: 3095792639,
        darkgray: 2846468607,
        darkgreen: 6553855,
        darkgrey: 2846468607,
        darkkhaki: 3182914559,
        darkmagenta: 2332068863,
        darkolivegreen: 1433087999,
        darkorange: 4287365375,
        darkorchid: 2570243327,
        darkred: 2332033279,
        darksalmon: 3918953215,
        darkseagreen: 2411499519,
        darkslateblue: 1211993087,
        darkslategray: 793726975,
        darkslategrey: 793726975,
        darkturquoise: 13554175,
        darkviolet: 2483082239,
        deeppink: 4279538687,
        deepskyblue: 12582911,
        dimgray: 1768516095,
        dimgrey: 1768516095,
        dodgerblue: 512819199,
        firebrick: 2988581631,
        floralwhite: 4294635775,
        forestgreen: 579543807,
        fuchsia: 4278255615,
        gainsboro: 3705462015,
        ghostwhite: 4177068031,
        gold: 4292280575,
        goldenrod: 3668254975,
        gray: 2155905279,
        green: 8388863,
        greenyellow: 2919182335,
        grey: 2155905279,
        honeydew: 4043305215,
        hotpink: 4285117695,
        indianred: 3445382399,
        indigo: 1258324735,
        ivory: 4294963455,
        khaki: 4041641215,
        lavender: 3873897215,
        lavenderblush: 4293981695,
        lawngreen: 2096890111,
        lemonchiffon: 4294626815,
        lightblue: 2916673279,
        lightcoral: 4034953471,
        lightcyan: 3774873599,
        lightgoldenrodyellow: 4210742015,
        lightgray: 3553874943,
        lightgreen: 2431553791,
        lightgrey: 3553874943,
        lightpink: 4290167295,
        lightsalmon: 4288707327,
        lightseagreen: 548580095,
        lightskyblue: 2278488831,
        lightslategray: 2005441023,
        lightslategrey: 2005441023,
        lightsteelblue: 2965692159,
        lightyellow: 4294959359,
        lime: 16711935,
        limegreen: 852308735,
        linen: 4210091775,
        magenta: 4278255615,
        maroon: 2147483903,
        mediumaquamarine: 1724754687,
        mediumblue: 52735,
        mediumorchid: 3126187007,
        mediumpurple: 2473647103,
        mediumseagreen: 1018393087,
        mediumslateblue: 2070474495,
        mediumspringgreen: 16423679,
        mediumturquoise: 1221709055,
        mediumvioletred: 3340076543,
        midnightblue: 421097727,
        mintcream: 4127193855,
        mistyrose: 4293190143,
        moccasin: 4293178879,
        navajowhite: 4292783615,
        navy: 33023,
        oldlace: 4260751103,
        olive: 2155872511,
        olivedrab: 1804477439,
        orange: 4289003775,
        orangered: 4282712319,
        orchid: 3664828159,
        palegoldenrod: 4008225535,
        palegreen: 2566625535,
        paleturquoise: 2951671551,
        palevioletred: 3681588223,
        papayawhip: 4293907967,
        peachpuff: 4292524543,
        peru: 3448061951,
        pink: 4290825215,
        plum: 3718307327,
        powderblue: 2967529215,
        purple: 2147516671,
        rebeccapurple: 1714657791,
        red: 4278190335,
        rosybrown: 3163525119,
        royalblue: 1097458175,
        saddlebrown: 2336560127,
        salmon: 4202722047,
        sandybrown: 4104413439,
        seagreen: 780883967,
        seashell: 4294307583,
        sienna: 2689740287,
        silver: 3233857791,
        skyblue: 2278484991,
        slateblue: 1784335871,
        slategray: 1887473919,
        slategrey: 1887473919,
        snow: 4294638335,
        springgreen: 16744447,
        steelblue: 1182971135,
        tan: 3535047935,
        teal: 8421631,
        thistle: 3636451583,
        tomato: 4284696575,
        turquoise: 1088475391,
        violet: 4001558271,
        wheat: 4125012991,
        white: 4294967295,
        whitesmoke: 4126537215,
        yellow: 4294902015,
        yellowgreen: 2597139199
      };
      const TRANSPARENT_BLACK = 0;
      const OPAQUE_BLACK = 255;
      class Point {
        /**
         * Creates an instance of Point.
         * @param {number} x X position
         * @param {number} y Y position
         *
         * @memberof Point
         */
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }
        clone() {
          return new Point(this.x, this.y);
        }
        distance(pt) {
          return Math.sqrt(
            Math.pow(pt.x - this.x, 2) + Math.pow(pt.y - this.y, 2)
          );
        }
        add(pt) {
          return new Point(this.x + pt.x, this.y + pt.y);
        }
        subtract(pt) {
          return new Point(this.x - pt.x, this.y - pt.y);
        }
        magnitude() {
          return Math.sqrt(this.dotProduct(this));
        }
        dotProduct(v) {
          return this.x * v.x + this.y * v.y;
        }
        divide(scalar) {
          return new Point(this.x / scalar, this.y / scalar);
        }
        floor() {
          return new Point(Math.floor(this.x), Math.floor(this.y));
        }
        round() {
          return new Point(Math.round(this.x), Math.round(this.y));
        }
        unit() {
          return this.divide(this.magnitude());
        }
        rotate(theta) {
          return new Point(
            Math.cos(theta) * this.x - Math.sin(theta) * this.y,
            Math.sin(theta) * this.x + Math.cos(theta) * this.y
          );
        }
        scale(scalar) {
          return new Point(
            this.x * scalar,
            this.y * scalar
          );
        }
        equals(pt) {
          return this.x === pt.x && this.y === pt.y;
        }
      }
      __name(Point, "Point");
      const toRad = /* @__PURE__ */ __name((deg) => Math.PI / 180 * deg, "toRad");
      function calc_min_bounds(pts) {
        let x1 = Number.POSITIVE_INFINITY;
        let y1 = Number.POSITIVE_INFINITY;
        let x2 = Number.NEGATIVE_INFINITY;
        let y2 = Number.NEGATIVE_INFINITY;
        pts.forEach((pt) => {
          x1 = Math.min(x1, pt.x);
          y1 = Math.min(y1, pt.y);
          x2 = Math.max(x2, pt.x);
          y2 = Math.max(y2, pt.y);
        });
        return new Bounds2(x1, y1, x2, y2);
      }
      __name(calc_min_bounds, "calc_min_bounds");
      class Bounds2 {
        constructor(x1, y1, x2, y2) {
          this.x1 = x1;
          this.y1 = y1;
          this.x2 = x2;
          this.y2 = y2;
        }
        contains(pt) {
          if (pt.x < this.x1)
            return false;
          if (pt.x >= this.x2)
            return false;
          if (pt.y < this.y1)
            return false;
          if (pt.y >= this.y2)
            return false;
          return true;
        }
        intersect(bds) {
          let x1 = Math.max(this.x1, bds.x1);
          let y1 = Math.max(this.y1, bds.y1);
          let x2 = Math.min(this.x2, bds.x2);
          let y2 = Math.min(this.y2, bds.y2);
          return new Bounds2(x1, y1, x2, y2);
        }
      }
      __name(Bounds2, "Bounds");
      class Line {
        /**
         * Construct a Line using two {@link Point} objects
         * .
         * @param {Point} start An instance of {@link Point} containing X and Y co-ordinates
         * @param {Point} end   An instance of {@link Point} containing X and Y co-ordinates
         * @memberof Line
         */
        /**
         * Construct a Line using 4 {@link number}s
         *
         * @param {number} startX Starting position on the X axis
         * @param {number} startY Starting position on the Y axis
         * @param {number} endX   Ending position on the X axis
         * @param {number} endY   Ending position on the Y acis
         * @memberof Line
         */
        constructor() {
          if (arguments.length === 4) {
            this.start = {};
            this.end = {};
            [this.start.x, this.start.y, this.end.x, this.end.y] = arguments;
            for (let argument_index in arguments) {
              if (arguments.hasOwnProperty(argument_index)) {
                let argument = arguments[argument_index];
                if (typeof argument !== "number") {
                  throw TypeError("When passing 4 arguments, only numbers may be passed");
                }
              }
            }
          } else if (arguments.length === 2) {
            [this.start, this.end] = arguments;
          } else {
            throw Error("Please pass either two Point objects, or 4 integers to the constructor");
          }
        }
        /**
         * Get the line length
         *
         * @returns {number}
         *
         * @memberof Line
         */
        getLength() {
          return Math.sqrt(
            Math.pow(this.start.x - this.end.x, 2) + Math.pow(this.start.y - this.end.y, 2)
          );
        }
        is_invalid() {
          if (Number.isNaN(this.start.x))
            return true;
          if (Number.isNaN(this.end.x))
            return true;
          if (Number.isNaN(this.start.y))
            return true;
          if (Number.isNaN(this.end.y))
            return true;
          if (this.start.x > Number.MAX_SAFE_INTEGER)
            return true;
          if (this.start.y > Number.MAX_SAFE_INTEGER)
            return true;
          if (this.end.x > Number.MAX_SAFE_INTEGER)
            return true;
          if (this.end.y > Number.MAX_SAFE_INTEGER)
            return true;
          return false;
        }
      }
      __name(Line, "Line");
      function createCommonjsModule(fn) {
        var module3 = { exports: {} };
        return fn(module3, module3.exports), module3.exports;
      }
      __name(createCommonjsModule, "createCommonjsModule");
      var encoding = createCommonjsModule(function(module3, exports3) {
        var cffStandardStrings = [
          ".notdef",
          "space",
          "exclam",
          "quotedbl",
          "numbersign",
          "dollar",
          "percent",
          "ampersand",
          "quoteright",
          "parenleft",
          "parenright",
          "asterisk",
          "plus",
          "comma",
          "hyphen",
          "period",
          "slash",
          "zero",
          "one",
          "two",
          "three",
          "four",
          "five",
          "six",
          "seven",
          "eight",
          "nine",
          "colon",
          "semicolon",
          "less",
          "equal",
          "greater",
          "question",
          "at",
          "A",
          "B",
          "C",
          "D",
          "E",
          "F",
          "G",
          "H",
          "I",
          "J",
          "K",
          "L",
          "M",
          "N",
          "O",
          "P",
          "Q",
          "R",
          "S",
          "T",
          "U",
          "V",
          "W",
          "X",
          "Y",
          "Z",
          "bracketleft",
          "backslash",
          "bracketright",
          "asciicircum",
          "underscore",
          "quoteleft",
          "a",
          "b",
          "c",
          "d",
          "e",
          "f",
          "g",
          "h",
          "i",
          "j",
          "k",
          "l",
          "m",
          "n",
          "o",
          "p",
          "q",
          "r",
          "s",
          "t",
          "u",
          "v",
          "w",
          "x",
          "y",
          "z",
          "braceleft",
          "bar",
          "braceright",
          "asciitilde",
          "exclamdown",
          "cent",
          "sterling",
          "fraction",
          "yen",
          "florin",
          "section",
          "currency",
          "quotesingle",
          "quotedblleft",
          "guillemotleft",
          "guilsinglleft",
          "guilsinglright",
          "fi",
          "fl",
          "endash",
          "dagger",
          "daggerdbl",
          "periodcentered",
          "paragraph",
          "bullet",
          "quotesinglbase",
          "quotedblbase",
          "quotedblright",
          "guillemotright",
          "ellipsis",
          "perthousand",
          "questiondown",
          "grave",
          "acute",
          "circumflex",
          "tilde",
          "macron",
          "breve",
          "dotaccent",
          "dieresis",
          "ring",
          "cedilla",
          "hungarumlaut",
          "ogonek",
          "caron",
          "emdash",
          "AE",
          "ordfeminine",
          "Lslash",
          "Oslash",
          "OE",
          "ordmasculine",
          "ae",
          "dotlessi",
          "lslash",
          "oslash",
          "oe",
          "germandbls",
          "onesuperior",
          "logicalnot",
          "mu",
          "trademark",
          "Eth",
          "onehalf",
          "plusminus",
          "Thorn",
          "onequarter",
          "divide",
          "brokenbar",
          "degree",
          "thorn",
          "threequarters",
          "twosuperior",
          "registered",
          "minus",
          "eth",
          "multiply",
          "threesuperior",
          "copyright",
          "Aacute",
          "Acircumflex",
          "Adieresis",
          "Agrave",
          "Aring",
          "Atilde",
          "Ccedilla",
          "Eacute",
          "Ecircumflex",
          "Edieresis",
          "Egrave",
          "Iacute",
          "Icircumflex",
          "Idieresis",
          "Igrave",
          "Ntilde",
          "Oacute",
          "Ocircumflex",
          "Odieresis",
          "Ograve",
          "Otilde",
          "Scaron",
          "Uacute",
          "Ucircumflex",
          "Udieresis",
          "Ugrave",
          "Yacute",
          "Ydieresis",
          "Zcaron",
          "aacute",
          "acircumflex",
          "adieresis",
          "agrave",
          "aring",
          "atilde",
          "ccedilla",
          "eacute",
          "ecircumflex",
          "edieresis",
          "egrave",
          "iacute",
          "icircumflex",
          "idieresis",
          "igrave",
          "ntilde",
          "oacute",
          "ocircumflex",
          "odieresis",
          "ograve",
          "otilde",
          "scaron",
          "uacute",
          "ucircumflex",
          "udieresis",
          "ugrave",
          "yacute",
          "ydieresis",
          "zcaron",
          "exclamsmall",
          "Hungarumlautsmall",
          "dollaroldstyle",
          "dollarsuperior",
          "ampersandsmall",
          "Acutesmall",
          "parenleftsuperior",
          "parenrightsuperior",
          "266 ff",
          "onedotenleader",
          "zerooldstyle",
          "oneoldstyle",
          "twooldstyle",
          "threeoldstyle",
          "fouroldstyle",
          "fiveoldstyle",
          "sixoldstyle",
          "sevenoldstyle",
          "eightoldstyle",
          "nineoldstyle",
          "commasuperior",
          "threequartersemdash",
          "periodsuperior",
          "questionsmall",
          "asuperior",
          "bsuperior",
          "centsuperior",
          "dsuperior",
          "esuperior",
          "isuperior",
          "lsuperior",
          "msuperior",
          "nsuperior",
          "osuperior",
          "rsuperior",
          "ssuperior",
          "tsuperior",
          "ff",
          "ffi",
          "ffl",
          "parenleftinferior",
          "parenrightinferior",
          "Circumflexsmall",
          "hyphensuperior",
          "Gravesmall",
          "Asmall",
          "Bsmall",
          "Csmall",
          "Dsmall",
          "Esmall",
          "Fsmall",
          "Gsmall",
          "Hsmall",
          "Ismall",
          "Jsmall",
          "Ksmall",
          "Lsmall",
          "Msmall",
          "Nsmall",
          "Osmall",
          "Psmall",
          "Qsmall",
          "Rsmall",
          "Ssmall",
          "Tsmall",
          "Usmall",
          "Vsmall",
          "Wsmall",
          "Xsmall",
          "Ysmall",
          "Zsmall",
          "colonmonetary",
          "onefitted",
          "rupiah",
          "Tildesmall",
          "exclamdownsmall",
          "centoldstyle",
          "Lslashsmall",
          "Scaronsmall",
          "Zcaronsmall",
          "Dieresissmall",
          "Brevesmall",
          "Caronsmall",
          "Dotaccentsmall",
          "Macronsmall",
          "figuredash",
          "hypheninferior",
          "Ogoneksmall",
          "Ringsmall",
          "Cedillasmall",
          "questiondownsmall",
          "oneeighth",
          "threeeighths",
          "fiveeighths",
          "seveneighths",
          "onethird",
          "twothirds",
          "zerosuperior",
          "foursuperior",
          "fivesuperior",
          "sixsuperior",
          "sevensuperior",
          "eightsuperior",
          "ninesuperior",
          "zeroinferior",
          "oneinferior",
          "twoinferior",
          "threeinferior",
          "fourinferior",
          "fiveinferior",
          "sixinferior",
          "seveninferior",
          "eightinferior",
          "nineinferior",
          "centinferior",
          "dollarinferior",
          "periodinferior",
          "commainferior",
          "Agravesmall",
          "Aacutesmall",
          "Acircumflexsmall",
          "Atildesmall",
          "Adieresissmall",
          "Aringsmall",
          "AEsmall",
          "Ccedillasmall",
          "Egravesmall",
          "Eacutesmall",
          "Ecircumflexsmall",
          "Edieresissmall",
          "Igravesmall",
          "Iacutesmall",
          "Icircumflexsmall",
          "Idieresissmall",
          "Ethsmall",
          "Ntildesmall",
          "Ogravesmall",
          "Oacutesmall",
          "Ocircumflexsmall",
          "Otildesmall",
          "Odieresissmall",
          "OEsmall",
          "Oslashsmall",
          "Ugravesmall",
          "Uacutesmall",
          "Ucircumflexsmall",
          "Udieresissmall",
          "Yacutesmall",
          "Thornsmall",
          "Ydieresissmall",
          "001.000",
          "001.001",
          "001.002",
          "001.003",
          "Black",
          "Bold",
          "Book",
          "Light",
          "Medium",
          "Regular",
          "Roman",
          "Semibold"
        ];
        var cffStandardEncoding = [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "space",
          "exclam",
          "quotedbl",
          "numbersign",
          "dollar",
          "percent",
          "ampersand",
          "quoteright",
          "parenleft",
          "parenright",
          "asterisk",
          "plus",
          "comma",
          "hyphen",
          "period",
          "slash",
          "zero",
          "one",
          "two",
          "three",
          "four",
          "five",
          "six",
          "seven",
          "eight",
          "nine",
          "colon",
          "semicolon",
          "less",
          "equal",
          "greater",
          "question",
          "at",
          "A",
          "B",
          "C",
          "D",
          "E",
          "F",
          "G",
          "H",
          "I",
          "J",
          "K",
          "L",
          "M",
          "N",
          "O",
          "P",
          "Q",
          "R",
          "S",
          "T",
          "U",
          "V",
          "W",
          "X",
          "Y",
          "Z",
          "bracketleft",
          "backslash",
          "bracketright",
          "asciicircum",
          "underscore",
          "quoteleft",
          "a",
          "b",
          "c",
          "d",
          "e",
          "f",
          "g",
          "h",
          "i",
          "j",
          "k",
          "l",
          "m",
          "n",
          "o",
          "p",
          "q",
          "r",
          "s",
          "t",
          "u",
          "v",
          "w",
          "x",
          "y",
          "z",
          "braceleft",
          "bar",
          "braceright",
          "asciitilde",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "exclamdown",
          "cent",
          "sterling",
          "fraction",
          "yen",
          "florin",
          "section",
          "currency",
          "quotesingle",
          "quotedblleft",
          "guillemotleft",
          "guilsinglleft",
          "guilsinglright",
          "fi",
          "fl",
          "",
          "endash",
          "dagger",
          "daggerdbl",
          "periodcentered",
          "",
          "paragraph",
          "bullet",
          "quotesinglbase",
          "quotedblbase",
          "quotedblright",
          "guillemotright",
          "ellipsis",
          "perthousand",
          "",
          "questiondown",
          "",
          "grave",
          "acute",
          "circumflex",
          "tilde",
          "macron",
          "breve",
          "dotaccent",
          "dieresis",
          "",
          "ring",
          "cedilla",
          "",
          "hungarumlaut",
          "ogonek",
          "caron",
          "emdash",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "AE",
          "",
          "ordfeminine",
          "",
          "",
          "",
          "",
          "Lslash",
          "Oslash",
          "OE",
          "ordmasculine",
          "",
          "",
          "",
          "",
          "",
          "ae",
          "",
          "",
          "",
          "dotlessi",
          "",
          "",
          "lslash",
          "oslash",
          "oe",
          "germandbls"
        ];
        var cffExpertEncoding = [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "space",
          "exclamsmall",
          "Hungarumlautsmall",
          "",
          "dollaroldstyle",
          "dollarsuperior",
          "ampersandsmall",
          "Acutesmall",
          "parenleftsuperior",
          "parenrightsuperior",
          "twodotenleader",
          "onedotenleader",
          "comma",
          "hyphen",
          "period",
          "fraction",
          "zerooldstyle",
          "oneoldstyle",
          "twooldstyle",
          "threeoldstyle",
          "fouroldstyle",
          "fiveoldstyle",
          "sixoldstyle",
          "sevenoldstyle",
          "eightoldstyle",
          "nineoldstyle",
          "colon",
          "semicolon",
          "commasuperior",
          "threequartersemdash",
          "periodsuperior",
          "questionsmall",
          "",
          "asuperior",
          "bsuperior",
          "centsuperior",
          "dsuperior",
          "esuperior",
          "",
          "",
          "isuperior",
          "",
          "",
          "lsuperior",
          "msuperior",
          "nsuperior",
          "osuperior",
          "",
          "",
          "rsuperior",
          "ssuperior",
          "tsuperior",
          "",
          "ff",
          "fi",
          "fl",
          "ffi",
          "ffl",
          "parenleftinferior",
          "",
          "parenrightinferior",
          "Circumflexsmall",
          "hyphensuperior",
          "Gravesmall",
          "Asmall",
          "Bsmall",
          "Csmall",
          "Dsmall",
          "Esmall",
          "Fsmall",
          "Gsmall",
          "Hsmall",
          "Ismall",
          "Jsmall",
          "Ksmall",
          "Lsmall",
          "Msmall",
          "Nsmall",
          "Osmall",
          "Psmall",
          "Qsmall",
          "Rsmall",
          "Ssmall",
          "Tsmall",
          "Usmall",
          "Vsmall",
          "Wsmall",
          "Xsmall",
          "Ysmall",
          "Zsmall",
          "colonmonetary",
          "onefitted",
          "rupiah",
          "Tildesmall",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "exclamdownsmall",
          "centoldstyle",
          "Lslashsmall",
          "",
          "",
          "Scaronsmall",
          "Zcaronsmall",
          "Dieresissmall",
          "Brevesmall",
          "Caronsmall",
          "",
          "Dotaccentsmall",
          "",
          "",
          "Macronsmall",
          "",
          "",
          "figuredash",
          "hypheninferior",
          "",
          "",
          "Ogoneksmall",
          "Ringsmall",
          "Cedillasmall",
          "",
          "",
          "",
          "onequarter",
          "onehalf",
          "threequarters",
          "questiondownsmall",
          "oneeighth",
          "threeeighths",
          "fiveeighths",
          "seveneighths",
          "onethird",
          "twothirds",
          "",
          "",
          "zerosuperior",
          "onesuperior",
          "twosuperior",
          "threesuperior",
          "foursuperior",
          "fivesuperior",
          "sixsuperior",
          "sevensuperior",
          "eightsuperior",
          "ninesuperior",
          "zeroinferior",
          "oneinferior",
          "twoinferior",
          "threeinferior",
          "fourinferior",
          "fiveinferior",
          "sixinferior",
          "seveninferior",
          "eightinferior",
          "nineinferior",
          "centinferior",
          "dollarinferior",
          "periodinferior",
          "commainferior",
          "Agravesmall",
          "Aacutesmall",
          "Acircumflexsmall",
          "Atildesmall",
          "Adieresissmall",
          "Aringsmall",
          "AEsmall",
          "Ccedillasmall",
          "Egravesmall",
          "Eacutesmall",
          "Ecircumflexsmall",
          "Edieresissmall",
          "Igravesmall",
          "Iacutesmall",
          "Icircumflexsmall",
          "Idieresissmall",
          "Ethsmall",
          "Ntildesmall",
          "Ogravesmall",
          "Oacutesmall",
          "Ocircumflexsmall",
          "Otildesmall",
          "Odieresissmall",
          "OEsmall",
          "Oslashsmall",
          "Ugravesmall",
          "Uacutesmall",
          "Ucircumflexsmall",
          "Udieresissmall",
          "Yacutesmall",
          "Thornsmall",
          "Ydieresissmall"
        ];
        var standardNames = [
          ".notdef",
          ".null",
          "nonmarkingreturn",
          "space",
          "exclam",
          "quotedbl",
          "numbersign",
          "dollar",
          "percent",
          "ampersand",
          "quotesingle",
          "parenleft",
          "parenright",
          "asterisk",
          "plus",
          "comma",
          "hyphen",
          "period",
          "slash",
          "zero",
          "one",
          "two",
          "three",
          "four",
          "five",
          "six",
          "seven",
          "eight",
          "nine",
          "colon",
          "semicolon",
          "less",
          "equal",
          "greater",
          "question",
          "at",
          "A",
          "B",
          "C",
          "D",
          "E",
          "F",
          "G",
          "H",
          "I",
          "J",
          "K",
          "L",
          "M",
          "N",
          "O",
          "P",
          "Q",
          "R",
          "S",
          "T",
          "U",
          "V",
          "W",
          "X",
          "Y",
          "Z",
          "bracketleft",
          "backslash",
          "bracketright",
          "asciicircum",
          "underscore",
          "grave",
          "a",
          "b",
          "c",
          "d",
          "e",
          "f",
          "g",
          "h",
          "i",
          "j",
          "k",
          "l",
          "m",
          "n",
          "o",
          "p",
          "q",
          "r",
          "s",
          "t",
          "u",
          "v",
          "w",
          "x",
          "y",
          "z",
          "braceleft",
          "bar",
          "braceright",
          "asciitilde",
          "Adieresis",
          "Aring",
          "Ccedilla",
          "Eacute",
          "Ntilde",
          "Odieresis",
          "Udieresis",
          "aacute",
          "agrave",
          "acircumflex",
          "adieresis",
          "atilde",
          "aring",
          "ccedilla",
          "eacute",
          "egrave",
          "ecircumflex",
          "edieresis",
          "iacute",
          "igrave",
          "icircumflex",
          "idieresis",
          "ntilde",
          "oacute",
          "ograve",
          "ocircumflex",
          "odieresis",
          "otilde",
          "uacute",
          "ugrave",
          "ucircumflex",
          "udieresis",
          "dagger",
          "degree",
          "cent",
          "sterling",
          "section",
          "bullet",
          "paragraph",
          "germandbls",
          "registered",
          "copyright",
          "trademark",
          "acute",
          "dieresis",
          "notequal",
          "AE",
          "Oslash",
          "infinity",
          "plusminus",
          "lessequal",
          "greaterequal",
          "yen",
          "mu",
          "partialdiff",
          "summation",
          "product",
          "pi",
          "integral",
          "ordfeminine",
          "ordmasculine",
          "Omega",
          "ae",
          "oslash",
          "questiondown",
          "exclamdown",
          "logicalnot",
          "radical",
          "florin",
          "approxequal",
          "Delta",
          "guillemotleft",
          "guillemotright",
          "ellipsis",
          "nonbreakingspace",
          "Agrave",
          "Atilde",
          "Otilde",
          "OE",
          "oe",
          "endash",
          "emdash",
          "quotedblleft",
          "quotedblright",
          "quoteleft",
          "quoteright",
          "divide",
          "lozenge",
          "ydieresis",
          "Ydieresis",
          "fraction",
          "currency",
          "guilsinglleft",
          "guilsinglright",
          "fi",
          "fl",
          "daggerdbl",
          "periodcentered",
          "quotesinglbase",
          "quotedblbase",
          "perthousand",
          "Acircumflex",
          "Ecircumflex",
          "Aacute",
          "Edieresis",
          "Egrave",
          "Iacute",
          "Icircumflex",
          "Idieresis",
          "Igrave",
          "Oacute",
          "Ocircumflex",
          "apple",
          "Ograve",
          "Uacute",
          "Ucircumflex",
          "Ugrave",
          "dotlessi",
          "circumflex",
          "tilde",
          "macron",
          "breve",
          "dotaccent",
          "ring",
          "cedilla",
          "hungarumlaut",
          "ogonek",
          "caron",
          "Lslash",
          "lslash",
          "Scaron",
          "scaron",
          "Zcaron",
          "zcaron",
          "brokenbar",
          "Eth",
          "eth",
          "Yacute",
          "yacute",
          "Thorn",
          "thorn",
          "minus",
          "multiply",
          "onesuperior",
          "twosuperior",
          "threesuperior",
          "onehalf",
          "onequarter",
          "threequarters",
          "franc",
          "Gbreve",
          "gbreve",
          "Idotaccent",
          "Scedilla",
          "scedilla",
          "Cacute",
          "cacute",
          "Ccaron",
          "ccaron",
          "dcroat"
        ];
        function DefaultEncoding(font2) {
          this.font = font2;
        }
        __name(DefaultEncoding, "DefaultEncoding");
        DefaultEncoding.prototype.charToGlyphIndex = function(c) {
          var code = c.charCodeAt(0);
          var glyphs = this.font.glyphs;
          if (glyphs) {
            for (var i = 0; i < glyphs.length; i += 1) {
              var glyph2 = glyphs.get(i);
              for (var j = 0; j < glyph2.unicodes.length; j += 1) {
                if (glyph2.unicodes[j] === code) {
                  return i;
                }
              }
            }
          } else {
            return null;
          }
        };
        function CmapEncoding(cmap2) {
          this.cmap = cmap2;
        }
        __name(CmapEncoding, "CmapEncoding");
        CmapEncoding.prototype.charToGlyphIndex = function(c) {
          return this.cmap.glyphIndexMap[c.charCodeAt(0)] || 0;
        };
        function CffEncoding(encoding2, charset) {
          this.encoding = encoding2;
          this.charset = charset;
        }
        __name(CffEncoding, "CffEncoding");
        CffEncoding.prototype.charToGlyphIndex = function(s) {
          var code = s.charCodeAt(0);
          var charName = this.encoding[code];
          return this.charset.indexOf(charName);
        };
        function GlyphNames(post2) {
          var i;
          switch (post2.version) {
            case 1:
              this.names = exports3.standardNames.slice();
              break;
            case 2:
              this.names = new Array(post2.numberOfGlyphs);
              for (i = 0; i < post2.numberOfGlyphs; i++) {
                if (post2.glyphNameIndex[i] < exports3.standardNames.length) {
                  this.names[i] = exports3.standardNames[post2.glyphNameIndex[i]];
                } else {
                  this.names[i] = post2.names[post2.glyphNameIndex[i] - exports3.standardNames.length];
                }
              }
              break;
            case 2.5:
              this.names = new Array(post2.numberOfGlyphs);
              for (i = 0; i < post2.numberOfGlyphs; i++) {
                this.names[i] = exports3.standardNames[i + post2.glyphNameIndex[i]];
              }
              break;
            case 3:
              this.names = [];
              break;
          }
        }
        __name(GlyphNames, "GlyphNames");
        GlyphNames.prototype.nameToGlyphIndex = function(name2) {
          return this.names.indexOf(name2);
        };
        GlyphNames.prototype.glyphIndexToName = function(gid) {
          return this.names[gid];
        };
        function addGlyphNames(font2) {
          var glyph2;
          var glyphIndexMap = font2.tables.cmap.glyphIndexMap;
          var charCodes = Object.keys(glyphIndexMap);
          for (var i = 0; i < charCodes.length; i += 1) {
            var c = charCodes[i];
            var glyphIndex = glyphIndexMap[c];
            glyph2 = font2.glyphs.get(glyphIndex);
            glyph2.addUnicode(parseInt(c));
          }
          for (i = 0; i < font2.glyphs.length; i += 1) {
            glyph2 = font2.glyphs.get(i);
            if (font2.cffEncoding) {
              glyph2.name = font2.cffEncoding.charset[i];
            } else {
              glyph2.name = font2.glyphNames.glyphIndexToName(i);
            }
          }
        }
        __name(addGlyphNames, "addGlyphNames");
        exports3.cffStandardStrings = cffStandardStrings;
        exports3.cffStandardEncoding = cffStandardEncoding;
        exports3.cffExpertEncoding = cffExpertEncoding;
        exports3.standardNames = standardNames;
        exports3.DefaultEncoding = DefaultEncoding;
        exports3.CmapEncoding = CmapEncoding;
        exports3.CffEncoding = CffEncoding;
        exports3.GlyphNames = GlyphNames;
        exports3.addGlyphNames = addGlyphNames;
      });
      function Path() {
        this.commands = [];
        this.fill = "black";
        this.stroke = null;
        this.strokeWidth = 1;
      }
      __name(Path, "Path");
      Path.prototype.moveTo = function(x, y) {
        this.commands.push({
          type: "M",
          x,
          y
        });
      };
      Path.prototype.lineTo = function(x, y) {
        this.commands.push({
          type: "L",
          x,
          y
        });
      };
      Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
        this.commands.push({
          type: "C",
          x1,
          y1,
          x2,
          y2,
          x,
          y
        });
      };
      Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {
        this.commands.push({
          type: "Q",
          x1,
          y1,
          x,
          y
        });
      };
      Path.prototype.close = Path.prototype.closePath = function() {
        this.commands.push({
          type: "Z"
        });
      };
      Path.prototype.extend = function(pathOrCommands) {
        if (pathOrCommands.commands) {
          pathOrCommands = pathOrCommands.commands;
        }
        Array.prototype.push.apply(this.commands, pathOrCommands);
      };
      Path.prototype.draw = function(ctx) {
        ctx.beginPath();
        for (var i = 0; i < this.commands.length; i += 1) {
          var cmd = this.commands[i];
          if (cmd.type === "M") {
            ctx.moveTo(cmd.x, cmd.y);
          } else if (cmd.type === "L") {
            ctx.lineTo(cmd.x, cmd.y);
          } else if (cmd.type === "C") {
            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
          } else if (cmd.type === "Q") {
            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
          } else if (cmd.type === "Z") {
            ctx.closePath();
          }
        }
        if (this.fill) {
          ctx.fillStyle = this.fill;
          ctx.fill();
        }
        if (this.stroke) {
          ctx.strokeStyle = this.stroke;
          ctx.lineWidth = this.strokeWidth;
          ctx.stroke();
        }
      };
      Path.prototype.toPathData = function(decimalPlaces) {
        decimalPlaces = decimalPlaces !== void 0 ? decimalPlaces : 2;
        function floatToString(v) {
          if (Math.round(v) === v) {
            return "" + Math.round(v);
          } else {
            return v.toFixed(decimalPlaces);
          }
        }
        __name(floatToString, "floatToString");
        function packValues() {
          var s = "";
          for (var i2 = 0; i2 < arguments.length; i2 += 1) {
            var v = arguments[i2];
            if (v >= 0 && i2 > 0) {
              s += " ";
            }
            s += floatToString(v);
          }
          return s;
        }
        __name(packValues, "packValues");
        var d = "";
        for (var i = 0; i < this.commands.length; i += 1) {
          var cmd = this.commands[i];
          if (cmd.type === "M") {
            d += "M" + packValues(cmd.x, cmd.y);
          } else if (cmd.type === "L") {
            d += "L" + packValues(cmd.x, cmd.y);
          } else if (cmd.type === "C") {
            d += "C" + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
          } else if (cmd.type === "Q") {
            d += "Q" + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
          } else if (cmd.type === "Z") {
            d += "Z";
          }
        }
        return d;
      };
      Path.prototype.toSVG = function(decimalPlaces) {
        var svg = '<path d="';
        svg += this.toPathData(decimalPlaces);
        svg += '"';
        if (this.fill & this.fill !== "black") {
          if (this.fill === null) {
            svg += ' fill="none"';
          } else {
            svg += ' fill="' + this.fill + '"';
          }
        }
        if (this.stroke) {
          svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
        }
        svg += "/>";
        return svg;
      };
      var Path_1 = Path;
      var path = {
        Path: Path_1
      };
      var check = createCommonjsModule(function(module3, exports3) {
        exports3.argument = function(predicate, message) {
          if (!predicate) {
            throw new Error(message);
          }
        };
        exports3.assert = exports3.argument;
      });
      var LIMIT16 = 32768;
      var LIMIT32 = 2147483648;
      var decode$1 = {};
      var encode$2 = {};
      var sizeOf$1 = {};
      function constant(v) {
        return function() {
          return v;
        };
      }
      __name(constant, "constant");
      encode$2.BYTE = function(v) {
        check.argument(v >= 0 && v <= 255, "Byte value should be between 0 and 255.");
        return [v];
      };
      sizeOf$1.BYTE = constant(1);
      encode$2.CHAR = function(v) {
        return [v.charCodeAt(0)];
      };
      sizeOf$1.CHAR = constant(1);
      encode$2.CHARARRAY = function(v) {
        var b = [];
        for (var i = 0; i < v.length; i += 1) {
          b.push(v.charCodeAt(i));
        }
        return b;
      };
      sizeOf$1.CHARARRAY = function(v) {
        return v.length;
      };
      encode$2.USHORT = function(v) {
        return [v >> 8 & 255, v & 255];
      };
      sizeOf$1.USHORT = constant(2);
      encode$2.SHORT = function(v) {
        if (v >= LIMIT16) {
          v = -(2 * LIMIT16 - v);
        }
        return [v >> 8 & 255, v & 255];
      };
      sizeOf$1.SHORT = constant(2);
      encode$2.UINT24 = function(v) {
        return [v >> 16 & 255, v >> 8 & 255, v & 255];
      };
      sizeOf$1.UINT24 = constant(3);
      encode$2.ULONG = function(v) {
        return [v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
      };
      sizeOf$1.ULONG = constant(4);
      encode$2.LONG = function(v) {
        if (v >= LIMIT32) {
          v = -(2 * LIMIT32 - v);
        }
        return [v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
      };
      sizeOf$1.LONG = constant(4);
      encode$2.FIXED = encode$2.ULONG;
      sizeOf$1.FIXED = sizeOf$1.ULONG;
      encode$2.FWORD = encode$2.SHORT;
      sizeOf$1.FWORD = sizeOf$1.SHORT;
      encode$2.UFWORD = encode$2.USHORT;
      sizeOf$1.UFWORD = sizeOf$1.USHORT;
      encode$2.LONGDATETIME = function() {
        return [0, 0, 0, 0, 0, 0, 0, 0];
      };
      sizeOf$1.LONGDATETIME = constant(8);
      encode$2.TAG = function(v) {
        check.argument(v.length === 4, "Tag should be exactly 4 ASCII characters.");
        return [
          v.charCodeAt(0),
          v.charCodeAt(1),
          v.charCodeAt(2),
          v.charCodeAt(3)
        ];
      };
      sizeOf$1.TAG = constant(4);
      encode$2.Card8 = encode$2.BYTE;
      sizeOf$1.Card8 = sizeOf$1.BYTE;
      encode$2.Card16 = encode$2.USHORT;
      sizeOf$1.Card16 = sizeOf$1.USHORT;
      encode$2.OffSize = encode$2.BYTE;
      sizeOf$1.OffSize = sizeOf$1.BYTE;
      encode$2.SID = encode$2.USHORT;
      sizeOf$1.SID = sizeOf$1.USHORT;
      encode$2.NUMBER = function(v) {
        if (v >= -107 && v <= 107) {
          return [v + 139];
        } else if (v >= 108 && v <= 1131) {
          v = v - 108;
          return [(v >> 8) + 247, v & 255];
        } else if (v >= -1131 && v <= -108) {
          v = -v - 108;
          return [(v >> 8) + 251, v & 255];
        } else if (v >= -32768 && v <= 32767) {
          return encode$2.NUMBER16(v);
        } else {
          return encode$2.NUMBER32(v);
        }
      };
      sizeOf$1.NUMBER = function(v) {
        return encode$2.NUMBER(v).length;
      };
      encode$2.NUMBER16 = function(v) {
        return [28, v >> 8 & 255, v & 255];
      };
      sizeOf$1.NUMBER16 = constant(3);
      encode$2.NUMBER32 = function(v) {
        return [29, v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
      };
      sizeOf$1.NUMBER32 = constant(5);
      encode$2.REAL = function(v) {
        var value = v.toString();
        var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
        if (m) {
          var epsilon = parseFloat("1e" + ((m[2] ? +m[2] : 0) + m[1].length));
          value = (Math.round(v * epsilon) / epsilon).toString();
        }
        var nibbles = "";
        var i;
        var ii;
        for (i = 0, ii = value.length; i < ii; i += 1) {
          var c = value[i];
          if (c === "e") {
            nibbles += value[++i] === "-" ? "c" : "b";
          } else if (c === ".") {
            nibbles += "a";
          } else if (c === "-") {
            nibbles += "e";
          } else {
            nibbles += c;
          }
        }
        nibbles += nibbles.length & 1 ? "f" : "ff";
        var out = [30];
        for (i = 0, ii = nibbles.length; i < ii; i += 2) {
          out.push(parseInt(nibbles.substr(i, 2), 16));
        }
        return out;
      };
      sizeOf$1.REAL = function(v) {
        return encode$2.REAL(v).length;
      };
      encode$2.NAME = encode$2.CHARARRAY;
      sizeOf$1.NAME = sizeOf$1.CHARARRAY;
      encode$2.STRING = encode$2.CHARARRAY;
      sizeOf$1.STRING = sizeOf$1.CHARARRAY;
      decode$1.UTF16 = function(data, offset, numBytes) {
        var codePoints = [];
        var numChars = numBytes / 2;
        for (var j = 0; j < numChars; j++, offset += 2) {
          codePoints[j] = data.getUint16(offset);
        }
        return String.fromCharCode.apply(null, codePoints);
      };
      encode$2.UTF16 = function(v) {
        var b = [];
        for (var i = 0; i < v.length; i += 1) {
          var codepoint = v.charCodeAt(i);
          b.push(codepoint >> 8 & 255);
          b.push(codepoint & 255);
        }
        return b;
      };
      sizeOf$1.UTF16 = function(v) {
        return v.length * 2;
      };
      var eightBitMacEncodings = {
        "x-mac-croatian": (
          // Python: 'mac_croatian'
          "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u03A9\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uF8FF\xA9\u2044\u20AC\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7"
        ),
        "x-mac-cyrillic": (
          // Python: 'mac_cyrillic'
          "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\u0490\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E"
        ),
        "x-mac-gaelic": (
          // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
          "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u1E02\xB1\u2264\u2265\u1E03\u010A\u010B\u1E0A\u1E0B\u1E1E\u1E1F\u0120\u0121\u1E40\xE6\xF8\u1E41\u1E56\u1E57\u027C\u0192\u017F\u1E60\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\u1E61\u1E9B\xFF\u0178\u1E6A\u20AC\u2039\u203A\u0176\u0177\u1E6B\xB7\u1EF2\u1EF3\u204A\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u2663\xD2\xDA\xDB\xD9\u0131\xDD\xFD\u0174\u0175\u1E84\u1E85\u1E80\u1E81\u1E82\u1E83"
        ),
        "x-mac-greek": (
          // Python: 'mac_greek'
          "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\u20AC\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\xB7\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\xAD"
        ),
        "x-mac-icelandic": (
          // Python: 'mac_iceland'
          "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
        ),
        "x-mac-inuit": (
          // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
          "\u1403\u1404\u1405\u1406\u140A\u140B\u1431\u1432\u1433\u1434\u1438\u1439\u1449\u144E\u144F\u1450\u1451\u1455\u1456\u1466\u146D\u146E\u146F\u1470\u1472\u1473\u1483\u148B\u148C\u148D\u148E\u1490\u1491\xB0\u14A1\u14A5\u14A6\u2022\xB6\u14A7\xAE\xA9\u2122\u14A8\u14AA\u14AB\u14BB\u14C2\u14C3\u14C4\u14C5\u14C7\u14C8\u14D0\u14EF\u14F0\u14F1\u14F2\u14F4\u14F5\u1505\u14D5\u14D6\u14D7\u14D8\u14DA\u14DB\u14EA\u1528\u1529\u152A\u152B\u152D\u2026\xA0\u152E\u153E\u1555\u1556\u1557\u2013\u2014\u201C\u201D\u2018\u2019\u1558\u1559\u155A\u155D\u1546\u1547\u1548\u1549\u154B\u154C\u1550\u157F\u1580\u1581\u1582\u1583\u1584\u1585\u158F\u1590\u1591\u1592\u1593\u1594\u1595\u1671\u1672\u1673\u1674\u1675\u1676\u1596\u15A0\u15A1\u15A2\u15A3\u15A4\u15A5\u15A6\u157C\u0141\u0142"
        ),
        "x-mac-ce": (
          // Python: 'mac_latin2'
          "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026\xA0\u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7"
        ),
        macintosh: (
          // Python: 'mac_roman'
          "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
        ),
        "x-mac-romanian": (
          // Python: 'mac_romanian'
          "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u0218\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\u0103\u0219\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\u021A\u021B\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
        ),
        "x-mac-turkish": (
          // Python: 'mac_turkish'
          "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\uF8A0\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
        )
      };
      decode$1.MACSTRING = function(dataView, offset, dataLength, encoding2) {
        var table2 = eightBitMacEncodings[encoding2];
        if (table2 === void 0) {
          return void 0;
        }
        var result = "";
        for (var i = 0; i < dataLength; i++) {
          var c = dataView.getUint8(offset + i);
          if (c <= 127) {
            result += String.fromCharCode(c);
          } else {
            result += table2[c & 127];
          }
        }
        return result;
      };
      var macEncodingTableCache = typeof WeakMap === "function" && /* @__PURE__ */ new WeakMap();
      var macEncodingCacheKeys;
      var getMacEncodingTable = /* @__PURE__ */ __name(function(encoding2) {
        if (!macEncodingCacheKeys) {
          macEncodingCacheKeys = {};
          for (var e in eightBitMacEncodings) {
            macEncodingCacheKeys[e] = new String(e);
          }
        }
        var cacheKey = macEncodingCacheKeys[encoding2];
        if (cacheKey === void 0) {
          return void 0;
        }
        if (macEncodingTableCache) {
          var cachedTable = macEncodingTableCache.get(cacheKey);
          if (cachedTable !== void 0) {
            return cachedTable;
          }
        }
        var decodingTable = eightBitMacEncodings[encoding2];
        if (decodingTable === void 0) {
          return void 0;
        }
        var encodingTable = {};
        for (var i = 0; i < decodingTable.length; i++) {
          encodingTable[decodingTable.charCodeAt(i)] = i + 128;
        }
        if (macEncodingTableCache) {
          macEncodingTableCache.set(cacheKey, encodingTable);
        }
        return encodingTable;
      }, "getMacEncodingTable");
      encode$2.MACSTRING = function(str, encoding2) {
        var table2 = getMacEncodingTable(encoding2);
        if (table2 === void 0) {
          return void 0;
        }
        var result = [];
        for (var i = 0; i < str.length; i++) {
          var c = str.charCodeAt(i);
          if (c >= 128) {
            c = table2[c];
            if (c === void 0) {
              return void 0;
            }
          }
          result.push(c);
        }
        return result;
      };
      sizeOf$1.MACSTRING = function(str, encoding2) {
        var b = encode$2.MACSTRING(str, encoding2);
        if (b !== void 0) {
          return b.length;
        } else {
          return 0;
        }
      };
      encode$2.INDEX = function(l) {
        var i;
        var offset = 1;
        var offsets = [offset];
        var data = [];
        var dataSize = 0;
        for (i = 0; i < l.length; i += 1) {
          var v = encode$2.OBJECT(l[i]);
          Array.prototype.push.apply(data, v);
          dataSize += v.length;
          offset += v.length;
          offsets.push(offset);
        }
        if (data.length === 0) {
          return [0, 0];
        }
        var encodedOffsets = [];
        var offSize = 1 + Math.floor(Math.log(dataSize) / Math.log(2)) / 8 | 0;
        var offsetEncoder = [void 0, encode$2.BYTE, encode$2.USHORT, encode$2.UINT24, encode$2.ULONG][offSize];
        for (i = 0; i < offsets.length; i += 1) {
          var encodedOffset = offsetEncoder(offsets[i]);
          Array.prototype.push.apply(encodedOffsets, encodedOffset);
        }
        return Array.prototype.concat(
          encode$2.Card16(l.length),
          encode$2.OffSize(offSize),
          encodedOffsets,
          data
        );
      };
      sizeOf$1.INDEX = function(v) {
        return encode$2.INDEX(v).length;
      };
      encode$2.DICT = function(m) {
        var d = [];
        var keys = Object.keys(m);
        var length = keys.length;
        for (var i = 0; i < length; i += 1) {
          var k = parseInt(keys[i], 0);
          var v = m[k];
          d = d.concat(encode$2.OPERAND(v.value, v.type));
          d = d.concat(encode$2.OPERATOR(k));
        }
        return d;
      };
      sizeOf$1.DICT = function(m) {
        return encode$2.DICT(m).length;
      };
      encode$2.OPERATOR = function(v) {
        if (v < 1200) {
          return [v];
        } else {
          return [12, v - 1200];
        }
      };
      encode$2.OPERAND = function(v, type) {
        var d = [];
        if (Array.isArray(type)) {
          for (var i = 0; i < type.length; i += 1) {
            check.argument(v.length === type.length, "Not enough arguments given for type" + type);
            d = d.concat(encode$2.OPERAND(v[i], type[i]));
          }
        } else {
          if (type === "SID") {
            d = d.concat(encode$2.NUMBER(v));
          } else if (type === "offset") {
            d = d.concat(encode$2.NUMBER32(v));
          } else if (type === "number") {
            d = d.concat(encode$2.NUMBER(v));
          } else if (type === "real") {
            d = d.concat(encode$2.REAL(v));
          } else {
            throw new Error("Unknown operand type " + type);
          }
        }
        return d;
      };
      encode$2.OP = encode$2.BYTE;
      sizeOf$1.OP = sizeOf$1.BYTE;
      var wmm = typeof WeakMap === "function" && /* @__PURE__ */ new WeakMap();
      encode$2.CHARSTRING = function(ops) {
        if (wmm) {
          var cachedValue = wmm.get(ops);
          if (cachedValue !== void 0) {
            return cachedValue;
          }
        }
        var d = [];
        var length = ops.length;
        for (var i = 0; i < length; i += 1) {
          var op = ops[i];
          d = d.concat(encode$2[op.type](op.value));
        }
        if (wmm) {
          wmm.set(ops, d);
        }
        return d;
      };
      sizeOf$1.CHARSTRING = function(ops) {
        return encode$2.CHARSTRING(ops).length;
      };
      encode$2.OBJECT = function(v) {
        var encodingFunction = encode$2[v.type];
        check.argument(encodingFunction !== void 0, "No encoding function for type " + v.type);
        return encodingFunction(v.value);
      };
      sizeOf$1.OBJECT = function(v) {
        var sizeOfFunction = sizeOf$1[v.type];
        check.argument(sizeOfFunction !== void 0, "No sizeOf function for type " + v.type);
        return sizeOfFunction(v.value);
      };
      encode$2.TABLE = function(table2) {
        var d = [];
        var length = table2.fields.length;
        for (var i = 0; i < length; i += 1) {
          var field = table2.fields[i];
          var encodingFunction = encode$2[field.type];
          check.argument(encodingFunction !== void 0, "No encoding function for field type " + field.type);
          var value = table2[field.name];
          if (value === void 0) {
            value = field.value;
          }
          var bytes = encodingFunction(value);
          d = d.concat(bytes);
        }
        return d;
      };
      sizeOf$1.TABLE = function(table2) {
        var numBytes = 0;
        var length = table2.fields.length;
        for (var i = 0; i < length; i += 1) {
          var field = table2.fields[i];
          var sizeOfFunction = sizeOf$1[field.type];
          check.argument(sizeOfFunction !== void 0, "No sizeOf function for field type " + field.type);
          var value = table2[field.name];
          if (value === void 0) {
            value = field.value;
          }
          numBytes += sizeOfFunction(value);
        }
        return numBytes;
      };
      encode$2.LITERAL = function(v) {
        return v;
      };
      sizeOf$1.LITERAL = function(v) {
        return v.length;
      };
      var decode_1 = decode$1;
      var encode_1 = encode$2;
      var sizeOf_1 = sizeOf$1;
      var types = {
        decode: decode_1,
        encode: encode_1,
        sizeOf: sizeOf_1
      };
      var encode$1 = types.encode;
      var sizeOf = types.sizeOf;
      function Table(tableName, fields, options) {
        var i;
        for (i = 0; i < fields.length; i += 1) {
          var field = fields[i];
          this[field.name] = field.value;
        }
        this.tableName = tableName;
        this.fields = fields;
        if (options) {
          var optionKeys = Object.keys(options);
          for (i = 0; i < optionKeys.length; i += 1) {
            var k = optionKeys[i];
            var v = options[k];
            if (this[k] !== void 0) {
              this[k] = v;
            }
          }
        }
      }
      __name(Table, "Table");
      Table.prototype.sizeOf = function() {
        var v = 0;
        for (var i = 0; i < this.fields.length; i += 1) {
          var field = this.fields[i];
          var value = this[field.name];
          if (value === void 0) {
            value = field.value;
          }
          if (typeof value.sizeOf === "function") {
            v += value.sizeOf();
          } else {
            var sizeOfFunction = sizeOf[field.type];
            check.assert(typeof sizeOfFunction === "function", "Could not find sizeOf function for field" + field.name);
            v += sizeOfFunction(value);
          }
        }
        return v;
      };
      Table.prototype.encode = function() {
        return encode$1.TABLE(this);
      };
      var Table_1 = Table;
      var table = {
        Table: Table_1
      };
      var parse = createCommonjsModule(function(module3, exports3) {
        exports3.getByte = /* @__PURE__ */ __name(function getByte(dataView, offset) {
          return dataView.getUint8(offset);
        }, "getByte");
        exports3.getCard8 = exports3.getByte;
        exports3.getUShort = function(dataView, offset) {
          return dataView.getUint16(offset, false);
        };
        exports3.getCard16 = exports3.getUShort;
        exports3.getShort = function(dataView, offset) {
          return dataView.getInt16(offset, false);
        };
        exports3.getULong = function(dataView, offset) {
          return dataView.getUint32(offset, false);
        };
        exports3.getFixed = function(dataView, offset) {
          var decimal = dataView.getInt16(offset, false);
          var fraction = dataView.getUint16(offset + 2, false);
          return decimal + fraction / 65535;
        };
        exports3.getTag = function(dataView, offset) {
          var tag = "";
          for (var i = offset; i < offset + 4; i += 1) {
            tag += String.fromCharCode(dataView.getInt8(i));
          }
          return tag;
        };
        exports3.getOffset = function(dataView, offset, offSize) {
          var v = 0;
          for (var i = 0; i < offSize; i += 1) {
            v <<= 8;
            v += dataView.getUint8(offset + i);
          }
          return v;
        };
        exports3.getBytes = function(dataView, startOffset, endOffset) {
          var bytes = [];
          for (var i = startOffset; i < endOffset; i += 1) {
            bytes.push(dataView.getUint8(i));
          }
          return bytes;
        };
        exports3.bytesToString = function(bytes) {
          var s = "";
          for (var i = 0; i < bytes.length; i += 1) {
            s += String.fromCharCode(bytes[i]);
          }
          return s;
        };
        var typeOffsets = {
          byte: 1,
          uShort: 2,
          short: 2,
          uLong: 4,
          fixed: 4,
          longDateTime: 8,
          tag: 4
        };
        function Parser(data, offset) {
          this.data = data;
          this.offset = offset;
          this.relativeOffset = 0;
        }
        __name(Parser, "Parser");
        Parser.prototype.parseByte = function() {
          var v = this.data.getUint8(this.offset + this.relativeOffset);
          this.relativeOffset += 1;
          return v;
        };
        Parser.prototype.parseChar = function() {
          var v = this.data.getInt8(this.offset + this.relativeOffset);
          this.relativeOffset += 1;
          return v;
        };
        Parser.prototype.parseCard8 = Parser.prototype.parseByte;
        Parser.prototype.parseUShort = function() {
          var v = this.data.getUint16(this.offset + this.relativeOffset);
          this.relativeOffset += 2;
          return v;
        };
        Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
        Parser.prototype.parseSID = Parser.prototype.parseUShort;
        Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;
        Parser.prototype.parseShort = function() {
          var v = this.data.getInt16(this.offset + this.relativeOffset);
          this.relativeOffset += 2;
          return v;
        };
        Parser.prototype.parseF2Dot14 = function() {
          var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
          this.relativeOffset += 2;
          return v;
        };
        Parser.prototype.parseULong = function() {
          var v = exports3.getULong(this.data, this.offset + this.relativeOffset);
          this.relativeOffset += 4;
          return v;
        };
        Parser.prototype.parseFixed = function() {
          var v = exports3.getFixed(this.data, this.offset + this.relativeOffset);
          this.relativeOffset += 4;
          return v;
        };
        Parser.prototype.parseOffset16List = Parser.prototype.parseUShortList = function(count) {
          var offsets = new Array(count);
          var dataView = this.data;
          var offset = this.offset + this.relativeOffset;
          for (var i = 0; i < count; i++) {
            offsets[i] = exports3.getUShort(dataView, offset);
            offset += 2;
          }
          this.relativeOffset += count * 2;
          return offsets;
        };
        Parser.prototype.parseString = function(length) {
          var dataView = this.data;
          var offset = this.offset + this.relativeOffset;
          var string = "";
          this.relativeOffset += length;
          for (var i = 0; i < length; i++) {
            string += String.fromCharCode(dataView.getUint8(offset + i));
          }
          return string;
        };
        Parser.prototype.parseTag = function() {
          return this.parseString(4);
        };
        Parser.prototype.parseLongDateTime = function() {
          var v = exports3.getULong(this.data, this.offset + this.relativeOffset + 4);
          this.relativeOffset += 8;
          return v;
        };
        Parser.prototype.parseFixed = function() {
          var v = exports3.getULong(this.data, this.offset + this.relativeOffset);
          this.relativeOffset += 4;
          return v / 65536;
        };
        Parser.prototype.parseVersion = function() {
          var major = exports3.getUShort(this.data, this.offset + this.relativeOffset);
          var minor = exports3.getUShort(this.data, this.offset + this.relativeOffset + 2);
          this.relativeOffset += 4;
          return major + minor / 4096 / 10;
        };
        Parser.prototype.skip = function(type, amount) {
          if (amount === void 0) {
            amount = 1;
          }
          this.relativeOffset += typeOffsets[type] * amount;
        };
        exports3.Parser = Parser;
      });
      function parseCmapTable(data, start) {
        var i;
        var cmap2 = {};
        cmap2.version = parse.getUShort(data, start);
        check.argument(cmap2.version === 0, "cmap table version should be 0.");
        cmap2.numTables = parse.getUShort(data, start + 2);
        var offset = -1;
        for (i = 0; i < cmap2.numTables; i += 1) {
          var platformId = parse.getUShort(data, start + 4 + i * 8);
          var encodingId = parse.getUShort(data, start + 4 + i * 8 + 2);
          if (platformId === 3 && (encodingId === 1 || encodingId === 0)) {
            offset = parse.getULong(data, start + 4 + i * 8 + 4);
            break;
          }
        }
        if (offset === -1) {
          return null;
        }
        var p = new parse.Parser(data, start + offset);
        cmap2.format = p.parseUShort();
        check.argument(cmap2.format === 4, "Only format 4 cmap tables are supported.");
        cmap2.length = p.parseUShort();
        cmap2.language = p.parseUShort();
        var segCount;
        cmap2.segCount = segCount = p.parseUShort() >> 1;
        p.skip("uShort", 3);
        cmap2.glyphIndexMap = {};
        var endCountParser = new parse.Parser(data, start + offset + 14);
        var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
        var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
        var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
        var glyphIndexOffset = start + offset + 16 + segCount * 8;
        for (i = 0; i < segCount - 1; i += 1) {
          var glyphIndex;
          var endCount = endCountParser.parseUShort();
          var startCount = startCountParser.parseUShort();
          var idDelta = idDeltaParser.parseShort();
          var idRangeOffset = idRangeOffsetParser.parseUShort();
          for (var c = startCount; c <= endCount; c += 1) {
            if (idRangeOffset !== 0) {
              glyphIndexOffset = idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2;
              glyphIndexOffset += idRangeOffset;
              glyphIndexOffset += (c - startCount) * 2;
              glyphIndex = parse.getUShort(data, glyphIndexOffset);
              if (glyphIndex !== 0) {
                glyphIndex = glyphIndex + idDelta & 65535;
              }
            } else {
              glyphIndex = c + idDelta & 65535;
            }
            cmap2.glyphIndexMap[c] = glyphIndex;
          }
        }
        return cmap2;
      }
      __name(parseCmapTable, "parseCmapTable");
      function addSegment(t, code, glyphIndex) {
        t.segments.push({
          end: code,
          start: code,
          delta: -(code - glyphIndex),
          offset: 0
        });
      }
      __name(addSegment, "addSegment");
      function addTerminatorSegment(t) {
        t.segments.push({
          end: 65535,
          start: 65535,
          delta: 1,
          offset: 0
        });
      }
      __name(addTerminatorSegment, "addTerminatorSegment");
      function makeCmapTable(glyphs) {
        var i;
        var t = new table.Table("cmap", [
          { name: "version", type: "USHORT", value: 0 },
          { name: "numTables", type: "USHORT", value: 1 },
          { name: "platformID", type: "USHORT", value: 3 },
          { name: "encodingID", type: "USHORT", value: 1 },
          { name: "offset", type: "ULONG", value: 12 },
          { name: "format", type: "USHORT", value: 4 },
          { name: "length", type: "USHORT", value: 0 },
          { name: "language", type: "USHORT", value: 0 },
          { name: "segCountX2", type: "USHORT", value: 0 },
          { name: "searchRange", type: "USHORT", value: 0 },
          { name: "entrySelector", type: "USHORT", value: 0 },
          { name: "rangeShift", type: "USHORT", value: 0 }
        ]);
        t.segments = [];
        for (i = 0; i < glyphs.length; i += 1) {
          var glyph2 = glyphs.get(i);
          for (var j = 0; j < glyph2.unicodes.length; j += 1) {
            addSegment(t, glyph2.unicodes[j], i);
          }
          t.segments = t.segments.sort(function(a, b) {
            return a.start - b.start;
          });
        }
        addTerminatorSegment(t);
        var segCount;
        segCount = t.segments.length;
        t.segCountX2 = segCount * 2;
        t.searchRange = Math.pow(2, Math.floor(Math.log(segCount) / Math.log(2))) * 2;
        t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
        t.rangeShift = t.segCountX2 - t.searchRange;
        var endCounts = [];
        var startCounts = [];
        var idDeltas = [];
        var idRangeOffsets = [];
        var glyphIds = [];
        for (i = 0; i < segCount; i += 1) {
          var segment = t.segments[i];
          endCounts = endCounts.concat({ name: "end_" + i, type: "USHORT", value: segment.end });
          startCounts = startCounts.concat({ name: "start_" + i, type: "USHORT", value: segment.start });
          idDeltas = idDeltas.concat({ name: "idDelta_" + i, type: "SHORT", value: segment.delta });
          idRangeOffsets = idRangeOffsets.concat({ name: "idRangeOffset_" + i, type: "USHORT", value: segment.offset });
          if (segment.glyphId !== void 0) {
            glyphIds = glyphIds.concat({ name: "glyph_" + i, type: "USHORT", value: segment.glyphId });
          }
        }
        t.fields = t.fields.concat(endCounts);
        t.fields.push({ name: "reservedPad", type: "USHORT", value: 0 });
        t.fields = t.fields.concat(startCounts);
        t.fields = t.fields.concat(idDeltas);
        t.fields = t.fields.concat(idRangeOffsets);
        t.fields = t.fields.concat(glyphIds);
        t.length = 14 + // Subtable header
        endCounts.length * 2 + 2 + // reservedPad
        startCounts.length * 2 + idDeltas.length * 2 + idRangeOffsets.length * 2 + glyphIds.length * 2;
        return t;
      }
      __name(makeCmapTable, "makeCmapTable");
      var parse_1$e = parseCmapTable;
      var make$c = makeCmapTable;
      var cmap = {
        parse: parse_1$e,
        make: make$c
      };
      function line(ctx, x1, y1, x2, y2) {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
      __name(line, "line");
      var line_1 = line;
      var draw = {
        line: line_1
      };
      function getPathDefinition(glyph2, path2) {
        var _path = path2 || { commands: [] };
        return {
          configurable: true,
          get: function() {
            if (typeof _path === "function") {
              _path = _path();
            }
            return _path;
          },
          set: function(p) {
            _path = p;
          }
        };
      }
      __name(getPathDefinition, "getPathDefinition");
      function Glyph(options) {
        this.bindConstructorValues(options);
      }
      __name(Glyph, "Glyph");
      Glyph.prototype.bindConstructorValues = function(options) {
        this.index = options.index || 0;
        this.name = options.name || null;
        this.unicode = options.unicode || void 0;
        this.unicodes = options.unicodes || options.unicode !== void 0 ? [options.unicode] : [];
        if (options.xMin) {
          this.xMin = options.xMin;
        }
        if (options.yMin) {
          this.yMin = options.yMin;
        }
        if (options.xMax) {
          this.xMax = options.xMax;
        }
        if (options.yMax) {
          this.yMax = options.yMax;
        }
        if (options.advanceWidth) {
          this.advanceWidth = options.advanceWidth;
        }
        Object.defineProperty(this, "path", getPathDefinition(this, options.path));
      };
      Glyph.prototype.addUnicode = function(unicode) {
        if (this.unicodes.length === 0) {
          this.unicode = unicode;
        }
        this.unicodes.push(unicode);
      };
      Glyph.prototype.getPath = function(x, y, fontSize) {
        x = x !== void 0 ? x : 0;
        y = y !== void 0 ? y : 0;
        fontSize = fontSize !== void 0 ? fontSize : 72;
        var scale = 1 / this.path.unitsPerEm * fontSize;
        var p = new path.Path();
        var commands = this.path.commands;
        for (var i = 0; i < commands.length; i += 1) {
          var cmd = commands[i];
          if (cmd.type === "M") {
            p.moveTo(x + cmd.x * scale, y + -cmd.y * scale);
          } else if (cmd.type === "L") {
            p.lineTo(x + cmd.x * scale, y + -cmd.y * scale);
          } else if (cmd.type === "Q") {
            p.quadraticCurveTo(
              x + cmd.x1 * scale,
              y + -cmd.y1 * scale,
              x + cmd.x * scale,
              y + -cmd.y * scale
            );
          } else if (cmd.type === "C") {
            p.curveTo(
              x + cmd.x1 * scale,
              y + -cmd.y1 * scale,
              x + cmd.x2 * scale,
              y + -cmd.y2 * scale,
              x + cmd.x * scale,
              y + -cmd.y * scale
            );
          } else if (cmd.type === "Z") {
            p.closePath();
          }
        }
        return p;
      };
      Glyph.prototype.getContours = function() {
        if (this.points === void 0) {
          return [];
        }
        var contours = [];
        var currentContour = [];
        for (var i = 0; i < this.points.length; i += 1) {
          var pt = this.points[i];
          currentContour.push(pt);
          if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
          }
        }
        check.argument(currentContour.length === 0, "There are still points left in the current contour.");
        return contours;
      };
      Glyph.prototype.getMetrics = function() {
        var commands = this.path.commands;
        var xCoords = [];
        var yCoords = [];
        for (var i = 0; i < commands.length; i += 1) {
          var cmd = commands[i];
          if (cmd.type !== "Z") {
            xCoords.push(cmd.x);
            yCoords.push(cmd.y);
          }
          if (cmd.type === "Q" || cmd.type === "C") {
            xCoords.push(cmd.x1);
            yCoords.push(cmd.y1);
          }
          if (cmd.type === "C") {
            xCoords.push(cmd.x2);
            yCoords.push(cmd.y2);
          }
        }
        var metrics = {
          xMin: Math.min.apply(null, xCoords),
          yMin: Math.min.apply(null, yCoords),
          xMax: Math.max.apply(null, xCoords),
          yMax: Math.max.apply(null, yCoords),
          leftSideBearing: 0
        };
        if (!isFinite(metrics.xMin)) {
          metrics.xMin = 0;
        }
        if (!isFinite(metrics.xMax)) {
          metrics.xMax = this.advanceWidth;
        }
        if (!isFinite(metrics.yMin)) {
          metrics.yMin = 0;
        }
        if (!isFinite(metrics.yMax)) {
          metrics.yMax = 0;
        }
        metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
        return metrics;
      };
      Glyph.prototype.draw = function(ctx, x, y, fontSize) {
        this.getPath(x, y, fontSize).draw(ctx);
      };
      Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {
        function drawCircles(l, x2, y2, scale2) {
          var PI_SQ = Math.PI * 2;
          ctx.beginPath();
          for (var j = 0; j < l.length; j += 1) {
            ctx.moveTo(x2 + l[j].x * scale2, y2 + l[j].y * scale2);
            ctx.arc(x2 + l[j].x * scale2, y2 + l[j].y * scale2, 2, 0, PI_SQ, false);
          }
          ctx.closePath();
          ctx.fill();
        }
        __name(drawCircles, "drawCircles");
        x = x !== void 0 ? x : 0;
        y = y !== void 0 ? y : 0;
        fontSize = fontSize !== void 0 ? fontSize : 24;
        var scale = 1 / this.path.unitsPerEm * fontSize;
        var blueCircles = [];
        var redCircles = [];
        var path2 = this.path;
        for (var i = 0; i < path2.commands.length; i += 1) {
          var cmd = path2.commands[i];
          if (cmd.x !== void 0) {
            blueCircles.push({ x: cmd.x, y: -cmd.y });
          }
          if (cmd.x1 !== void 0) {
            redCircles.push({ x: cmd.x1, y: -cmd.y1 });
          }
          if (cmd.x2 !== void 0) {
            redCircles.push({ x: cmd.x2, y: -cmd.y2 });
          }
        }
        ctx.fillStyle = "blue";
        drawCircles(blueCircles, x, y, scale);
        ctx.fillStyle = "red";
        drawCircles(redCircles, x, y, scale);
      };
      Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
        var scale;
        x = x !== void 0 ? x : 0;
        y = y !== void 0 ? y : 0;
        fontSize = fontSize !== void 0 ? fontSize : 24;
        scale = 1 / this.path.unitsPerEm * fontSize;
        ctx.lineWidth = 1;
        ctx.strokeStyle = "black";
        draw.line(ctx, x, -1e4, x, 1e4);
        draw.line(ctx, -1e4, y, 1e4, y);
        var xMin = this.xMin || 0;
        var yMin = this.yMin || 0;
        var xMax = this.xMax || 0;
        var yMax = this.yMax || 0;
        var advanceWidth = this.advanceWidth || 0;
        ctx.strokeStyle = "blue";
        draw.line(ctx, x + xMin * scale, -1e4, x + xMin * scale, 1e4);
        draw.line(ctx, x + xMax * scale, -1e4, x + xMax * scale, 1e4);
        draw.line(ctx, -1e4, y + -yMin * scale, 1e4, y + -yMin * scale);
        draw.line(ctx, -1e4, y + -yMax * scale, 1e4, y + -yMax * scale);
        ctx.strokeStyle = "green";
        draw.line(ctx, x + advanceWidth * scale, -1e4, x + advanceWidth * scale, 1e4);
      };
      var Glyph_1 = Glyph;
      var glyph = {
        Glyph: Glyph_1
      };
      function GlyphSet(font2, glyphs) {
        this.font = font2;
        this.glyphs = {};
        if (Array.isArray(glyphs)) {
          for (var i = 0; i < glyphs.length; i++) {
            this.glyphs[i] = glyphs[i];
          }
        }
        this.length = glyphs && glyphs.length || 0;
      }
      __name(GlyphSet, "GlyphSet");
      GlyphSet.prototype.get = function(index) {
        if (typeof this.glyphs[index] === "function") {
          this.glyphs[index] = this.glyphs[index]();
        }
        return this.glyphs[index];
      };
      GlyphSet.prototype.push = function(index, loader) {
        this.glyphs[index] = loader;
        this.length++;
      };
      function glyphLoader(font2, index) {
        return new glyph.Glyph({ index, font: font2 });
      }
      __name(glyphLoader, "glyphLoader");
      function ttfGlyphLoader(font2, index, parseGlyph2, data, position, buildPath2) {
        return function() {
          var glyph$1 = new glyph.Glyph({ index, font: font2 });
          glyph$1.path = function() {
            parseGlyph2(glyph$1, data, position);
            var path2 = buildPath2(font2.glyphs, glyph$1);
            path2.unitsPerEm = font2.unitsPerEm;
            return path2;
          };
          return glyph$1;
        };
      }
      __name(ttfGlyphLoader, "ttfGlyphLoader");
      function cffGlyphLoader(font2, index, parseCFFCharstring2, charstring) {
        return function() {
          var glyph$1 = new glyph.Glyph({ index, font: font2 });
          glyph$1.path = function() {
            var path2 = parseCFFCharstring2(font2, glyph$1, charstring);
            path2.unitsPerEm = font2.unitsPerEm;
            return path2;
          };
          return glyph$1;
        };
      }
      __name(cffGlyphLoader, "cffGlyphLoader");
      var GlyphSet_1 = GlyphSet;
      var glyphLoader_1 = glyphLoader;
      var ttfGlyphLoader_1 = ttfGlyphLoader;
      var cffGlyphLoader_1 = cffGlyphLoader;
      var glyphset = {
        GlyphSet: GlyphSet_1,
        glyphLoader: glyphLoader_1,
        ttfGlyphLoader: ttfGlyphLoader_1,
        cffGlyphLoader: cffGlyphLoader_1
      };
      function equals(a, b) {
        if (a === b) {
          return true;
        } else if (Array.isArray(a) && Array.isArray(b)) {
          if (a.length !== b.length) {
            return false;
          }
          for (var i = 0; i < a.length; i += 1) {
            if (!equals(a[i], b[i])) {
              return false;
            }
          }
          return true;
        } else {
          return false;
        }
      }
      __name(equals, "equals");
      function parseCFFIndex(data, start, conversionFn) {
        var offsets = [];
        var objects = [];
        var count = parse.getCard16(data, start);
        var i;
        var objectOffset;
        var endOffset;
        if (count !== 0) {
          var offsetSize = parse.getByte(data, start + 2);
          objectOffset = start + (count + 1) * offsetSize + 2;
          var pos = start + 3;
          for (i = 0; i < count + 1; i += 1) {
            offsets.push(parse.getOffset(data, pos, offsetSize));
            pos += offsetSize;
          }
          endOffset = objectOffset + offsets[count];
        } else {
          endOffset = start + 2;
        }
        for (i = 0; i < offsets.length - 1; i += 1) {
          var value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);
          if (conversionFn) {
            value = conversionFn(value);
          }
          objects.push(value);
        }
        return { objects, startOffset: start, endOffset };
      }
      __name(parseCFFIndex, "parseCFFIndex");
      function parseFloatOperand(parser2) {
        var s = "";
        var eof = 15;
        var lookup = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
        while (true) {
          var b = parser2.parseByte();
          var n1 = b >> 4;
          var n2 = b & 15;
          if (n1 === eof) {
            break;
          }
          s += lookup[n1];
          if (n2 === eof) {
            break;
          }
          s += lookup[n2];
        }
        return parseFloat(s);
      }
      __name(parseFloatOperand, "parseFloatOperand");
      function parseOperand(parser2, b0) {
        var b1;
        var b2;
        var b3;
        var b4;
        if (b0 === 28) {
          b1 = parser2.parseByte();
          b2 = parser2.parseByte();
          return b1 << 8 | b2;
        }
        if (b0 === 29) {
          b1 = parser2.parseByte();
          b2 = parser2.parseByte();
          b3 = parser2.parseByte();
          b4 = parser2.parseByte();
          return b1 << 24 | b2 << 16 | b3 << 8 | b4;
        }
        if (b0 === 30) {
          return parseFloatOperand(parser2);
        }
        if (b0 >= 32 && b0 <= 246) {
          return b0 - 139;
        }
        if (b0 >= 247 && b0 <= 250) {
          b1 = parser2.parseByte();
          return (b0 - 247) * 256 + b1 + 108;
        }
        if (b0 >= 251 && b0 <= 254) {
          b1 = parser2.parseByte();
          return -(b0 - 251) * 256 - b1 - 108;
        }
        throw new Error("Invalid b0 " + b0);
      }
      __name(parseOperand, "parseOperand");
      function entriesToObject(entries) {
        var o = {};
        for (var i = 0; i < entries.length; i += 1) {
          var key = entries[i][0];
          var values = entries[i][1];
          var value;
          if (values.length === 1) {
            value = values[0];
          } else {
            value = values;
          }
          if (o.hasOwnProperty(key)) {
            throw new Error("Object " + o + " already has key " + key);
          }
          o[key] = value;
        }
        return o;
      }
      __name(entriesToObject, "entriesToObject");
      function parseCFFDict(data, start, size) {
        start = start !== void 0 ? start : 0;
        var parser2 = new parse.Parser(data, start);
        var entries = [];
        var operands = [];
        size = size !== void 0 ? size : data.length;
        while (parser2.relativeOffset < size) {
          var op = parser2.parseByte();
          if (op <= 21) {
            if (op === 12) {
              op = 1200 + parser2.parseByte();
            }
            entries.push([op, operands]);
            operands = [];
          } else {
            operands.push(parseOperand(parser2, op));
          }
        }
        return entriesToObject(entries);
      }
      __name(parseCFFDict, "parseCFFDict");
      function getCFFString(strings, index) {
        if (index <= 390) {
          index = encoding.cffStandardStrings[index];
        } else {
          index = strings[index - 391];
        }
        return index;
      }
      __name(getCFFString, "getCFFString");
      function interpretDict(dict, meta, strings) {
        var newDict = {};
        for (var i = 0; i < meta.length; i += 1) {
          var m = meta[i];
          var value = dict[m.op];
          if (value === void 0) {
            value = m.value !== void 0 ? m.value : null;
          }
          if (m.type === "SID") {
            value = getCFFString(strings, value);
          }
          newDict[m.name] = value;
        }
        return newDict;
      }
      __name(interpretDict, "interpretDict");
      function parseCFFHeader(data, start) {
        var header = {};
        header.formatMajor = parse.getCard8(data, start);
        header.formatMinor = parse.getCard8(data, start + 1);
        header.size = parse.getCard8(data, start + 2);
        header.offsetSize = parse.getCard8(data, start + 3);
        header.startOffset = start;
        header.endOffset = start + 4;
        return header;
      }
      __name(parseCFFHeader, "parseCFFHeader");
      var TOP_DICT_META = [
        { name: "version", op: 0, type: "SID" },
        { name: "notice", op: 1, type: "SID" },
        { name: "copyright", op: 1200, type: "SID" },
        { name: "fullName", op: 2, type: "SID" },
        { name: "familyName", op: 3, type: "SID" },
        { name: "weight", op: 4, type: "SID" },
        { name: "isFixedPitch", op: 1201, type: "number", value: 0 },
        { name: "italicAngle", op: 1202, type: "number", value: 0 },
        { name: "underlinePosition", op: 1203, type: "number", value: -100 },
        { name: "underlineThickness", op: 1204, type: "number", value: 50 },
        { name: "paintType", op: 1205, type: "number", value: 0 },
        { name: "charstringType", op: 1206, type: "number", value: 2 },
        { name: "fontMatrix", op: 1207, type: ["real", "real", "real", "real", "real", "real"], value: [1e-3, 0, 0, 1e-3, 0, 0] },
        { name: "uniqueId", op: 13, type: "number" },
        { name: "fontBBox", op: 5, type: ["number", "number", "number", "number"], value: [0, 0, 0, 0] },
        { name: "strokeWidth", op: 1208, type: "number", value: 0 },
        { name: "xuid", op: 14, type: [], value: null },
        { name: "charset", op: 15, type: "offset", value: 0 },
        { name: "encoding", op: 16, type: "offset", value: 0 },
        { name: "charStrings", op: 17, type: "offset", value: 0 },
        { name: "private", op: 18, type: ["number", "offset"], value: [0, 0] }
      ];
      var PRIVATE_DICT_META = [
        { name: "subrs", op: 19, type: "offset", value: 0 },
        { name: "defaultWidthX", op: 20, type: "number", value: 0 },
        { name: "nominalWidthX", op: 21, type: "number", value: 0 }
      ];
      function parseCFFTopDict(data, strings) {
        var dict = parseCFFDict(data, 0, data.byteLength);
        return interpretDict(dict, TOP_DICT_META, strings);
      }
      __name(parseCFFTopDict, "parseCFFTopDict");
      function parseCFFPrivateDict(data, start, size, strings) {
        var dict = parseCFFDict(data, start, size);
        return interpretDict(dict, PRIVATE_DICT_META, strings);
      }
      __name(parseCFFPrivateDict, "parseCFFPrivateDict");
      function parseCFFCharset(data, start, nGlyphs, strings) {
        var i;
        var sid;
        var count;
        var parser2 = new parse.Parser(data, start);
        nGlyphs -= 1;
        var charset = [".notdef"];
        var format = parser2.parseCard8();
        if (format === 0) {
          for (i = 0; i < nGlyphs; i += 1) {
            sid = parser2.parseSID();
            charset.push(getCFFString(strings, sid));
          }
        } else if (format === 1) {
          while (charset.length <= nGlyphs) {
            sid = parser2.parseSID();
            count = parser2.parseCard8();
            for (i = 0; i <= count; i += 1) {
              charset.push(getCFFString(strings, sid));
              sid += 1;
            }
          }
        } else if (format === 2) {
          while (charset.length <= nGlyphs) {
            sid = parser2.parseSID();
            count = parser2.parseCard16();
            for (i = 0; i <= count; i += 1) {
              charset.push(getCFFString(strings, sid));
              sid += 1;
            }
          }
        } else {
          throw new Error("Unknown charset format " + format);
        }
        return charset;
      }
      __name(parseCFFCharset, "parseCFFCharset");
      function parseCFFEncoding(data, start, charset) {
        var i;
        var code;
        var enc = {};
        var parser2 = new parse.Parser(data, start);
        var format = parser2.parseCard8();
        if (format === 0) {
          var nCodes = parser2.parseCard8();
          for (i = 0; i < nCodes; i += 1) {
            code = parser2.parseCard8();
            enc[code] = i;
          }
        } else if (format === 1) {
          var nRanges = parser2.parseCard8();
          code = 1;
          for (i = 0; i < nRanges; i += 1) {
            var first = parser2.parseCard8();
            var nLeft = parser2.parseCard8();
            for (var j = first; j <= first + nLeft; j += 1) {
              enc[j] = code;
              code += 1;
            }
          }
        } else {
          throw new Error("Unknown encoding format " + format);
        }
        return new encoding.CffEncoding(enc, charset);
      }
      __name(parseCFFEncoding, "parseCFFEncoding");
      function parseCFFCharstring(font2, glyph2, code) {
        var c1x;
        var c1y;
        var c2x;
        var c2y;
        var p = new path.Path();
        var stack = [];
        var nStems = 0;
        var haveWidth = false;
        var width = font2.defaultWidthX;
        var open = false;
        var x = 0;
        var y = 0;
        function newContour(x2, y2) {
          if (open) {
            p.closePath();
          }
          p.moveTo(x2, y2);
          open = true;
        }
        __name(newContour, "newContour");
        function parseStems() {
          var hasWidthArg;
          hasWidthArg = stack.length % 2 !== 0;
          if (hasWidthArg && !haveWidth) {
            width = stack.shift() + font2.nominalWidthX;
          }
          nStems += stack.length >> 1;
          stack.length = 0;
          haveWidth = true;
        }
        __name(parseStems, "parseStems");
        function parse2(code2) {
          var b1;
          var b2;
          var b3;
          var b4;
          var codeIndex;
          var subrCode;
          var jpx;
          var jpy;
          var c3x;
          var c3y;
          var c4x;
          var c4y;
          var i = 0;
          while (i < code2.length) {
            var v = code2[i];
            i += 1;
            switch (v) {
              case 1:
                parseStems();
                break;
              case 3:
                parseStems();
                break;
              case 4:
                if (stack.length > 1 && !haveWidth) {
                  width = stack.shift() + font2.nominalWidthX;
                  haveWidth = true;
                }
                y += stack.pop();
                newContour(x, y);
                break;
              case 5:
                while (stack.length > 0) {
                  x += stack.shift();
                  y += stack.shift();
                  p.lineTo(x, y);
                }
                break;
              case 6:
                while (stack.length > 0) {
                  x += stack.shift();
                  p.lineTo(x, y);
                  if (stack.length === 0) {
                    break;
                  }
                  y += stack.shift();
                  p.lineTo(x, y);
                }
                break;
              case 7:
                while (stack.length > 0) {
                  y += stack.shift();
                  p.lineTo(x, y);
                  if (stack.length === 0) {
                    break;
                  }
                  x += stack.shift();
                  p.lineTo(x, y);
                }
                break;
              case 8:
                while (stack.length > 0) {
                  c1x = x + stack.shift();
                  c1y = y + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x = c2x + stack.shift();
                  y = c2y + stack.shift();
                  p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
              case 10:
                codeIndex = stack.pop() + font2.subrsBias;
                subrCode = font2.subrs[codeIndex];
                if (subrCode) {
                  parse2(subrCode);
                }
                break;
              case 11:
                return;
              case 12:
                v = code2[i];
                i += 1;
                switch (v) {
                  case 35:
                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    jpx = c2x + stack.shift();
                    jpy = c2y + stack.shift();
                    c3x = jpx + stack.shift();
                    c3y = jpy + stack.shift();
                    c4x = c3x + stack.shift();
                    c4y = c3y + stack.shift();
                    x = c4x + stack.shift();
                    y = c4y + stack.shift();
                    stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                    p.curveTo(c3x, c3y, c4x, c4y, x, y);
                    break;
                  case 34:
                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    jpx = c2x + stack.shift();
                    jpy = c2y;
                    c3x = jpx + stack.shift();
                    c3y = c2y;
                    c4x = c3x + stack.shift();
                    c4y = y;
                    x = c4x + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                    p.curveTo(c3x, c3y, c4x, c4y, x, y);
                    break;
                  case 36:
                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    jpx = c2x + stack.shift();
                    jpy = c2y;
                    c3x = jpx + stack.shift();
                    c3y = c2y;
                    c4x = c3x + stack.shift();
                    c4y = c3y + stack.shift();
                    x = c4x + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                    p.curveTo(c3x, c3y, c4x, c4y, x, y);
                    break;
                  case 37:
                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    jpx = c2x + stack.shift();
                    jpy = c2y + stack.shift();
                    c3x = jpx + stack.shift();
                    c3y = jpy + stack.shift();
                    c4x = c3x + stack.shift();
                    c4y = c3y + stack.shift();
                    if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
                      x = c4x + stack.shift();
                    } else {
                      y = c4y + stack.shift();
                    }
                    p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                    p.curveTo(c3x, c3y, c4x, c4y, x, y);
                    break;
                  default:
                    console.log("Glyph " + glyph2.index + ": unknown operator 1200" + v);
                    stack.length = 0;
                }
                break;
              case 14:
                if (stack.length > 0 && !haveWidth) {
                  width = stack.shift() + font2.nominalWidthX;
                  haveWidth = true;
                }
                if (open) {
                  p.closePath();
                  open = false;
                }
                break;
              case 18:
                parseStems();
                break;
              case 19:
              case 20:
                parseStems();
                i += nStems + 7 >> 3;
                break;
              case 21:
                if (stack.length > 2 && !haveWidth) {
                  width = stack.shift() + font2.nominalWidthX;
                  haveWidth = true;
                }
                y += stack.pop();
                x += stack.pop();
                newContour(x, y);
                break;
              case 22:
                if (stack.length > 1 && !haveWidth) {
                  width = stack.shift() + font2.nominalWidthX;
                  haveWidth = true;
                }
                x += stack.pop();
                newContour(x, y);
                break;
              case 23:
                parseStems();
                break;
              case 24:
                while (stack.length > 2) {
                  c1x = x + stack.shift();
                  c1y = y + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x = c2x + stack.shift();
                  y = c2y + stack.shift();
                  p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                x += stack.shift();
                y += stack.shift();
                p.lineTo(x, y);
                break;
              case 25:
                while (stack.length > 6) {
                  x += stack.shift();
                  y += stack.shift();
                  p.lineTo(x, y);
                }
                c1x = x + stack.shift();
                c1y = y + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y = c2y + stack.shift();
                p.curveTo(c1x, c1y, c2x, c2y, x, y);
                break;
              case 26:
                if (stack.length % 2) {
                  x += stack.shift();
                }
                while (stack.length > 0) {
                  c1x = x;
                  c1y = y + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x = c2x;
                  y = c2y + stack.shift();
                  p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
              case 27:
                if (stack.length % 2) {
                  y += stack.shift();
                }
                while (stack.length > 0) {
                  c1x = x + stack.shift();
                  c1y = y;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x = c2x + stack.shift();
                  y = c2y;
                  p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
              case 28:
                b1 = code2[i];
                b2 = code2[i + 1];
                stack.push((b1 << 24 | b2 << 16) >> 16);
                i += 2;
                break;
              case 29:
                codeIndex = stack.pop() + font2.gsubrsBias;
                subrCode = font2.gsubrs[codeIndex];
                if (subrCode) {
                  parse2(subrCode);
                }
                break;
              case 30:
                while (stack.length > 0) {
                  c1x = x;
                  c1y = y + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x = c2x + stack.shift();
                  y = c2y + (stack.length === 1 ? stack.shift() : 0);
                  p.curveTo(c1x, c1y, c2x, c2y, x, y);
                  if (stack.length === 0) {
                    break;
                  }
                  c1x = x + stack.shift();
                  c1y = y;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  y = c2y + stack.shift();
                  x = c2x + (stack.length === 1 ? stack.shift() : 0);
                  p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
              case 31:
                while (stack.length > 0) {
                  c1x = x + stack.shift();
                  c1y = y;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  y = c2y + stack.shift();
                  x = c2x + (stack.length === 1 ? stack.shift() : 0);
                  p.curveTo(c1x, c1y, c2x, c2y, x, y);
                  if (stack.length === 0) {
                    break;
                  }
                  c1x = x;
                  c1y = y + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x = c2x + stack.shift();
                  y = c2y + (stack.length === 1 ? stack.shift() : 0);
                  p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
              default:
                if (v < 32) {
                  console.log("Glyph " + glyph2.index + ": unknown operator " + v);
                } else if (v < 247) {
                  stack.push(v - 139);
                } else if (v < 251) {
                  b1 = code2[i];
                  i += 1;
                  stack.push((v - 247) * 256 + b1 + 108);
                } else if (v < 255) {
                  b1 = code2[i];
                  i += 1;
                  stack.push(-(v - 251) * 256 - b1 - 108);
                } else {
                  b1 = code2[i];
                  b2 = code2[i + 1];
                  b3 = code2[i + 2];
                  b4 = code2[i + 3];
                  i += 4;
                  stack.push((b1 << 24 | b2 << 16 | b3 << 8 | b4) / 65536);
                }
            }
          }
        }
        __name(parse2, "parse");
        parse2(code);
        glyph2.advanceWidth = width;
        return p;
      }
      __name(parseCFFCharstring, "parseCFFCharstring");
      function calcCFFSubroutineBias(subrs) {
        var bias;
        if (subrs.length < 1240) {
          bias = 107;
        } else if (subrs.length < 33900) {
          bias = 1131;
        } else {
          bias = 32768;
        }
        return bias;
      }
      __name(calcCFFSubroutineBias, "calcCFFSubroutineBias");
      function parseCFFTable(data, start, font2) {
        font2.tables.cff = {};
        var header = parseCFFHeader(data, start);
        var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
        var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
        var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
        var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
        font2.gsubrs = globalSubrIndex.objects;
        font2.gsubrsBias = calcCFFSubroutineBias(font2.gsubrs);
        var topDictData = new DataView(new Uint8Array(topDictIndex.objects[0]).buffer);
        var topDict = parseCFFTopDict(topDictData, stringIndex.objects);
        font2.tables.cff.topDict = topDict;
        var privateDictOffset = start + topDict["private"][1];
        var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict["private"][0], stringIndex.objects);
        font2.defaultWidthX = privateDict.defaultWidthX;
        font2.nominalWidthX = privateDict.nominalWidthX;
        if (privateDict.subrs !== 0) {
          var subrOffset = privateDictOffset + privateDict.subrs;
          var subrIndex = parseCFFIndex(data, subrOffset);
          font2.subrs = subrIndex.objects;
          font2.subrsBias = calcCFFSubroutineBias(font2.subrs);
        } else {
          font2.subrs = [];
          font2.subrsBias = 0;
        }
        var charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
        font2.nGlyphs = charStringsIndex.objects.length;
        var charset = parseCFFCharset(data, start + topDict.charset, font2.nGlyphs, stringIndex.objects);
        if (topDict.encoding === 0) {
          font2.cffEncoding = new encoding.CffEncoding(encoding.cffStandardEncoding, charset);
        } else if (topDict.encoding === 1) {
          font2.cffEncoding = new encoding.CffEncoding(encoding.cffExpertEncoding, charset);
        } else {
          font2.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
        }
        font2.encoding = font2.encoding || font2.cffEncoding;
        font2.glyphs = new glyphset.GlyphSet(font2);
        for (var i = 0; i < font2.nGlyphs; i += 1) {
          var charString = charStringsIndex.objects[i];
          font2.glyphs.push(i, glyphset.cffGlyphLoader(font2, i, parseCFFCharstring, charString));
        }
      }
      __name(parseCFFTable, "parseCFFTable");
      function encodeString(s, strings) {
        var sid;
        var i = encoding.cffStandardStrings.indexOf(s);
        if (i >= 0) {
          sid = i;
        }
        i = strings.indexOf(s);
        if (i >= 0) {
          sid = i + encoding.cffStandardStrings.length;
        } else {
          sid = encoding.cffStandardStrings.length + strings.length;
          strings.push(s);
        }
        return sid;
      }
      __name(encodeString, "encodeString");
      function makeHeader() {
        return new table.Table("Header", [
          { name: "major", type: "Card8", value: 1 },
          { name: "minor", type: "Card8", value: 0 },
          { name: "hdrSize", type: "Card8", value: 4 },
          { name: "major", type: "Card8", value: 1 }
        ]);
      }
      __name(makeHeader, "makeHeader");
      function makeNameIndex(fontNames) {
        var t = new table.Table("Name INDEX", [
          { name: "names", type: "INDEX", value: [] }
        ]);
        t.names = [];
        for (var i = 0; i < fontNames.length; i += 1) {
          t.names.push({ name: "name_" + i, type: "NAME", value: fontNames[i] });
        }
        return t;
      }
      __name(makeNameIndex, "makeNameIndex");
      function makeDict(meta, attrs, strings) {
        var m = {};
        for (var i = 0; i < meta.length; i += 1) {
          var entry = meta[i];
          var value = attrs[entry.name];
          if (value !== void 0 && !equals(value, entry.value)) {
            if (entry.type === "SID") {
              value = encodeString(value, strings);
            }
            m[entry.op] = { name: entry.name, type: entry.type, value };
          }
        }
        return m;
      }
      __name(makeDict, "makeDict");
      function makeTopDict(attrs, strings) {
        var t = new table.Table("Top DICT", [
          { name: "dict", type: "DICT", value: {} }
        ]);
        t.dict = makeDict(TOP_DICT_META, attrs, strings);
        return t;
      }
      __name(makeTopDict, "makeTopDict");
      function makeTopDictIndex(topDict) {
        var t = new table.Table("Top DICT INDEX", [
          { name: "topDicts", type: "INDEX", value: [] }
        ]);
        t.topDicts = [{ name: "topDict_0", type: "TABLE", value: topDict }];
        return t;
      }
      __name(makeTopDictIndex, "makeTopDictIndex");
      function makeStringIndex(strings) {
        var t = new table.Table("String INDEX", [
          { name: "strings", type: "INDEX", value: [] }
        ]);
        t.strings = [];
        for (var i = 0; i < strings.length; i += 1) {
          t.strings.push({ name: "string_" + i, type: "STRING", value: strings[i] });
        }
        return t;
      }
      __name(makeStringIndex, "makeStringIndex");
      function makeGlobalSubrIndex() {
        return new table.Table("Global Subr INDEX", [
          { name: "subrs", type: "INDEX", value: [] }
        ]);
      }
      __name(makeGlobalSubrIndex, "makeGlobalSubrIndex");
      function makeCharsets(glyphNames, strings) {
        var t = new table.Table("Charsets", [
          { name: "format", type: "Card8", value: 0 }
        ]);
        for (var i = 0; i < glyphNames.length; i += 1) {
          var glyphName = glyphNames[i];
          var glyphSID = encodeString(glyphName, strings);
          t.fields.push({ name: "glyph_" + i, type: "SID", value: glyphSID });
        }
        return t;
      }
      __name(makeCharsets, "makeCharsets");
      function glyphToOps(glyph2) {
        var ops = [];
        var path2 = glyph2.path;
        ops.push({ name: "width", type: "NUMBER", value: glyph2.advanceWidth });
        var x = 0;
        var y = 0;
        for (var i = 0; i < path2.commands.length; i += 1) {
          var dx;
          var dy;
          var cmd = path2.commands[i];
          if (cmd.type === "Q") {
            var _13 = 1 / 3;
            var _23 = 2 / 3;
            cmd = {
              type: "C",
              x: cmd.x,
              y: cmd.y,
              x1: _13 * x + _23 * cmd.x1,
              y1: _13 * y + _23 * cmd.y1,
              x2: _13 * cmd.x + _23 * cmd.x1,
              y2: _13 * cmd.y + _23 * cmd.y1
            };
          }
          if (cmd.type === "M") {
            dx = Math.round(cmd.x - x);
            dy = Math.round(cmd.y - y);
            ops.push({ name: "dx", type: "NUMBER", value: dx });
            ops.push({ name: "dy", type: "NUMBER", value: dy });
            ops.push({ name: "rmoveto", type: "OP", value: 21 });
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
          } else if (cmd.type === "L") {
            dx = Math.round(cmd.x - x);
            dy = Math.round(cmd.y - y);
            ops.push({ name: "dx", type: "NUMBER", value: dx });
            ops.push({ name: "dy", type: "NUMBER", value: dy });
            ops.push({ name: "rlineto", type: "OP", value: 5 });
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
          } else if (cmd.type === "C") {
            var dx1 = Math.round(cmd.x1 - x);
            var dy1 = Math.round(cmd.y1 - y);
            var dx2 = Math.round(cmd.x2 - cmd.x1);
            var dy2 = Math.round(cmd.y2 - cmd.y1);
            dx = Math.round(cmd.x - cmd.x2);
            dy = Math.round(cmd.y - cmd.y2);
            ops.push({ name: "dx1", type: "NUMBER", value: dx1 });
            ops.push({ name: "dy1", type: "NUMBER", value: dy1 });
            ops.push({ name: "dx2", type: "NUMBER", value: dx2 });
            ops.push({ name: "dy2", type: "NUMBER", value: dy2 });
            ops.push({ name: "dx", type: "NUMBER", value: dx });
            ops.push({ name: "dy", type: "NUMBER", value: dy });
            ops.push({ name: "rrcurveto", type: "OP", value: 8 });
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
          }
        }
        ops.push({ name: "endchar", type: "OP", value: 14 });
        return ops;
      }
      __name(glyphToOps, "glyphToOps");
      function makeCharStringsIndex(glyphs) {
        var t = new table.Table("CharStrings INDEX", [
          { name: "charStrings", type: "INDEX", value: [] }
        ]);
        for (var i = 0; i < glyphs.length; i += 1) {
          var glyph2 = glyphs.get(i);
          var ops = glyphToOps(glyph2);
          t.charStrings.push({ name: glyph2.name, type: "CHARSTRING", value: ops });
        }
        return t;
      }
      __name(makeCharStringsIndex, "makeCharStringsIndex");
      function makePrivateDict(attrs, strings) {
        var t = new table.Table("Private DICT", [
          { name: "dict", type: "DICT", value: {} }
        ]);
        t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
        return t;
      }
      __name(makePrivateDict, "makePrivateDict");
      function makePrivateDictIndex(privateDict) {
        var t = new table.Table("Private DICT INDEX", [
          { name: "privateDicts", type: "INDEX", value: [] }
        ]);
        t.privateDicts = [{ name: "privateDict_0", type: "TABLE", value: privateDict }];
        return t;
      }
      __name(makePrivateDictIndex, "makePrivateDictIndex");
      function makeCFFTable(glyphs, options) {
        var t = new table.Table("CFF ", [
          { name: "header", type: "TABLE" },
          { name: "nameIndex", type: "TABLE" },
          { name: "topDictIndex", type: "TABLE" },
          { name: "stringIndex", type: "TABLE" },
          { name: "globalSubrIndex", type: "TABLE" },
          { name: "charsets", type: "TABLE" },
          { name: "charStringsIndex", type: "TABLE" },
          { name: "privateDictIndex", type: "TABLE" }
        ]);
        var fontScale = 1 / options.unitsPerEm;
        var attrs = {
          version: options.version,
          fullName: options.fullName,
          familyName: options.familyName,
          weight: options.weightName,
          fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
          charset: 999,
          encoding: 0,
          charStrings: 999,
          private: [0, 999]
        };
        var privateAttrs = {};
        var glyphNames = [];
        var glyph2;
        for (var i = 1; i < glyphs.length; i += 1) {
          glyph2 = glyphs.get(i);
          glyphNames.push(glyph2.name);
        }
        var strings = [];
        t.header = makeHeader();
        t.nameIndex = makeNameIndex([options.postScriptName]);
        var topDict = makeTopDict(attrs, strings);
        t.topDictIndex = makeTopDictIndex(topDict);
        t.globalSubrIndex = makeGlobalSubrIndex();
        t.charsets = makeCharsets(glyphNames, strings);
        t.charStringsIndex = makeCharStringsIndex(glyphs);
        var privateDict = makePrivateDict(privateAttrs, strings);
        t.privateDictIndex = makePrivateDictIndex(privateDict);
        t.stringIndex = makeStringIndex(strings);
        var startOffset = t.header.sizeOf() + t.nameIndex.sizeOf() + t.topDictIndex.sizeOf() + t.stringIndex.sizeOf() + t.globalSubrIndex.sizeOf();
        attrs.charset = startOffset;
        attrs.encoding = 0;
        attrs.charStrings = attrs.charset + t.charsets.sizeOf();
        attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();
        topDict = makeTopDict(attrs, strings);
        t.topDictIndex = makeTopDictIndex(topDict);
        return t;
      }
      __name(makeCFFTable, "makeCFFTable");
      var parse_1$d = parseCFFTable;
      var make$b = makeCFFTable;
      var cff = {
        parse: parse_1$d,
        make: make$b
      };
      function parseHeadTable(data, start) {
        var head2 = {};
        var p = new parse.Parser(data, start);
        head2.version = p.parseVersion();
        head2.fontRevision = Math.round(p.parseFixed() * 1e3) / 1e3;
        head2.checkSumAdjustment = p.parseULong();
        head2.magicNumber = p.parseULong();
        check.argument(head2.magicNumber === 1594834165, "Font header has wrong magic number.");
        head2.flags = p.parseUShort();
        head2.unitsPerEm = p.parseUShort();
        head2.created = p.parseLongDateTime();
        head2.modified = p.parseLongDateTime();
        head2.xMin = p.parseShort();
        head2.yMin = p.parseShort();
        head2.xMax = p.parseShort();
        head2.yMax = p.parseShort();
        head2.macStyle = p.parseUShort();
        head2.lowestRecPPEM = p.parseUShort();
        head2.fontDirectionHint = p.parseShort();
        head2.indexToLocFormat = p.parseShort();
        head2.glyphDataFormat = p.parseShort();
        return head2;
      }
      __name(parseHeadTable, "parseHeadTable");
      function makeHeadTable(options) {
        return new table.Table("head", [
          { name: "version", type: "FIXED", value: 65536 },
          { name: "fontRevision", type: "FIXED", value: 65536 },
          { name: "checkSumAdjustment", type: "ULONG", value: 0 },
          { name: "magicNumber", type: "ULONG", value: 1594834165 },
          { name: "flags", type: "USHORT", value: 0 },
          { name: "unitsPerEm", type: "USHORT", value: 1e3 },
          { name: "created", type: "LONGDATETIME", value: 0 },
          { name: "modified", type: "LONGDATETIME", value: 0 },
          { name: "xMin", type: "SHORT", value: 0 },
          { name: "yMin", type: "SHORT", value: 0 },
          { name: "xMax", type: "SHORT", value: 0 },
          { name: "yMax", type: "SHORT", value: 0 },
          { name: "macStyle", type: "USHORT", value: 0 },
          { name: "lowestRecPPEM", type: "USHORT", value: 0 },
          { name: "fontDirectionHint", type: "SHORT", value: 2 },
          { name: "indexToLocFormat", type: "SHORT", value: 0 },
          { name: "glyphDataFormat", type: "SHORT", value: 0 }
        ], options);
      }
      __name(makeHeadTable, "makeHeadTable");
      var parse_1$c = parseHeadTable;
      var make$a = makeHeadTable;
      var head = {
        parse: parse_1$c,
        make: make$a
      };
      function parseHheaTable(data, start) {
        var hhea2 = {};
        var p = new parse.Parser(data, start);
        hhea2.version = p.parseVersion();
        hhea2.ascender = p.parseShort();
        hhea2.descender = p.parseShort();
        hhea2.lineGap = p.parseShort();
        hhea2.advanceWidthMax = p.parseUShort();
        hhea2.minLeftSideBearing = p.parseShort();
        hhea2.minRightSideBearing = p.parseShort();
        hhea2.xMaxExtent = p.parseShort();
        hhea2.caretSlopeRise = p.parseShort();
        hhea2.caretSlopeRun = p.parseShort();
        hhea2.caretOffset = p.parseShort();
        p.relativeOffset += 8;
        hhea2.metricDataFormat = p.parseShort();
        hhea2.numberOfHMetrics = p.parseUShort();
        return hhea2;
      }
      __name(parseHheaTable, "parseHheaTable");
      function makeHheaTable(options) {
        return new table.Table("hhea", [
          { name: "version", type: "FIXED", value: 65536 },
          { name: "ascender", type: "FWORD", value: 0 },
          { name: "descender", type: "FWORD", value: 0 },
          { name: "lineGap", type: "FWORD", value: 0 },
          { name: "advanceWidthMax", type: "UFWORD", value: 0 },
          { name: "minLeftSideBearing", type: "FWORD", value: 0 },
          { name: "minRightSideBearing", type: "FWORD", value: 0 },
          { name: "xMaxExtent", type: "FWORD", value: 0 },
          { name: "caretSlopeRise", type: "SHORT", value: 1 },
          { name: "caretSlopeRun", type: "SHORT", value: 0 },
          { name: "caretOffset", type: "SHORT", value: 0 },
          { name: "reserved1", type: "SHORT", value: 0 },
          { name: "reserved2", type: "SHORT", value: 0 },
          { name: "reserved3", type: "SHORT", value: 0 },
          { name: "reserved4", type: "SHORT", value: 0 },
          { name: "metricDataFormat", type: "SHORT", value: 0 },
          { name: "numberOfHMetrics", type: "USHORT", value: 0 }
        ], options);
      }
      __name(makeHheaTable, "makeHheaTable");
      var parse_1$b = parseHheaTable;
      var make$9 = makeHheaTable;
      var hhea = {
        parse: parse_1$b,
        make: make$9
      };
      function parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {
        var advanceWidth;
        var leftSideBearing;
        var p = new parse.Parser(data, start);
        for (var i = 0; i < numGlyphs; i += 1) {
          if (i < numMetrics) {
            advanceWidth = p.parseUShort();
            leftSideBearing = p.parseShort();
          }
          var glyph2 = glyphs.get(i);
          glyph2.advanceWidth = advanceWidth;
          glyph2.leftSideBearing = leftSideBearing;
        }
      }
      __name(parseHmtxTable, "parseHmtxTable");
      function makeHmtxTable(glyphs) {
        var t = new table.Table("hmtx", []);
        for (var i = 0; i < glyphs.length; i += 1) {
          var glyph2 = glyphs.get(i);
          var advanceWidth = glyph2.advanceWidth || 0;
          var leftSideBearing = glyph2.leftSideBearing || 0;
          t.fields.push({ name: "advanceWidth_" + i, type: "USHORT", value: advanceWidth });
          t.fields.push({ name: "leftSideBearing_" + i, type: "SHORT", value: leftSideBearing });
        }
        return t;
      }
      __name(makeHmtxTable, "makeHmtxTable");
      var parse_1$a = parseHmtxTable;
      var make$8 = makeHmtxTable;
      var hmtx = {
        parse: parse_1$a,
        make: make$8
      };
      function makeLtagTable(tags) {
        var result = new table.Table("ltag", [
          { name: "version", type: "ULONG", value: 1 },
          { name: "flags", type: "ULONG", value: 0 },
          { name: "numTags", type: "ULONG", value: tags.length }
        ]);
        var stringPool = "";
        var stringPoolOffset = 12 + tags.length * 4;
        for (var i = 0; i < tags.length; ++i) {
          var pos = stringPool.indexOf(tags[i]);
          if (pos < 0) {
            pos = stringPool.length;
            stringPool += tags[i];
          }
          result.fields.push({ name: "offset " + i, type: "USHORT", value: stringPoolOffset + pos });
          result.fields.push({ name: "length " + i, type: "USHORT", value: tags[i].length });
        }
        result.fields.push({ name: "stringPool", type: "CHARARRAY", value: stringPool });
        return result;
      }
      __name(makeLtagTable, "makeLtagTable");
      function parseLtagTable(data, start) {
        var p = new parse.Parser(data, start);
        var tableVersion = p.parseULong();
        check.argument(tableVersion === 1, "Unsupported ltag table version.");
        p.skip("uLong", 1);
        var numTags = p.parseULong();
        var tags = [];
        for (var i = 0; i < numTags; i++) {
          var tag = "";
          var offset = start + p.parseUShort();
          var length = p.parseUShort();
          for (var j = offset; j < offset + length; ++j) {
            tag += String.fromCharCode(data.getInt8(j));
          }
          tags.push(tag);
        }
        return tags;
      }
      __name(parseLtagTable, "parseLtagTable");
      var make$7 = makeLtagTable;
      var parse_1$9 = parseLtagTable;
      var ltag = {
        make: make$7,
        parse: parse_1$9
      };
      function parseMaxpTable(data, start) {
        var maxp2 = {};
        var p = new parse.Parser(data, start);
        maxp2.version = p.parseVersion();
        maxp2.numGlyphs = p.parseUShort();
        if (maxp2.version === 1) {
          maxp2.maxPoints = p.parseUShort();
          maxp2.maxContours = p.parseUShort();
          maxp2.maxCompositePoints = p.parseUShort();
          maxp2.maxCompositeContours = p.parseUShort();
          maxp2.maxZones = p.parseUShort();
          maxp2.maxTwilightPoints = p.parseUShort();
          maxp2.maxStorage = p.parseUShort();
          maxp2.maxFunctionDefs = p.parseUShort();
          maxp2.maxInstructionDefs = p.parseUShort();
          maxp2.maxStackElements = p.parseUShort();
          maxp2.maxSizeOfInstructions = p.parseUShort();
          maxp2.maxComponentElements = p.parseUShort();
          maxp2.maxComponentDepth = p.parseUShort();
        }
        return maxp2;
      }
      __name(parseMaxpTable, "parseMaxpTable");
      function makeMaxpTable(numGlyphs) {
        return new table.Table("maxp", [
          { name: "version", type: "FIXED", value: 20480 },
          { name: "numGlyphs", type: "USHORT", value: numGlyphs }
        ]);
      }
      __name(makeMaxpTable, "makeMaxpTable");
      var parse_1$8 = parseMaxpTable;
      var make$6 = makeMaxpTable;
      var maxp = {
        parse: parse_1$8,
        make: make$6
      };
      var decode2 = types.decode;
      var encode2 = types.encode;
      var nameTableNames = [
        "copyright",
        // 0
        "fontFamily",
        // 1
        "fontSubfamily",
        // 2
        "uniqueID",
        // 3
        "fullName",
        // 4
        "version",
        // 5
        "postScriptName",
        // 6
        "trademark",
        // 7
        "manufacturer",
        // 8
        "designer",
        // 9
        "description",
        // 10
        "manufacturerURL",
        // 11
        "designerURL",
        // 12
        "licence",
        // 13
        "licenceURL",
        // 14
        "reserved",
        // 15
        "preferredFamily",
        // 16
        "preferredSubfamily",
        // 17
        "compatibleFullName",
        // 18
        "sampleText",
        // 19
        "postScriptFindFontName",
        // 20
        "wwsFamily",
        // 21
        "wwsSubfamily"
        // 22
      ];
      var macLanguages = {
        0: "en",
        1: "fr",
        2: "de",
        3: "it",
        4: "nl",
        5: "sv",
        6: "es",
        7: "da",
        8: "pt",
        9: "no",
        10: "he",
        11: "ja",
        12: "ar",
        13: "fi",
        14: "el",
        15: "is",
        16: "mt",
        17: "tr",
        18: "hr",
        19: "zh-Hant",
        20: "ur",
        21: "hi",
        22: "th",
        23: "ko",
        24: "lt",
        25: "pl",
        26: "hu",
        27: "es",
        28: "lv",
        29: "se",
        30: "fo",
        31: "fa",
        32: "ru",
        33: "zh",
        34: "nl-BE",
        35: "ga",
        36: "sq",
        37: "ro",
        38: "cz",
        39: "sk",
        40: "si",
        41: "yi",
        42: "sr",
        43: "mk",
        44: "bg",
        45: "uk",
        46: "be",
        47: "uz",
        48: "kk",
        49: "az-Cyrl",
        50: "az-Arab",
        51: "hy",
        52: "ka",
        53: "mo",
        54: "ky",
        55: "tg",
        56: "tk",
        57: "mn-CN",
        58: "mn",
        59: "ps",
        60: "ks",
        61: "ku",
        62: "sd",
        63: "bo",
        64: "ne",
        65: "sa",
        66: "mr",
        67: "bn",
        68: "as",
        69: "gu",
        70: "pa",
        71: "or",
        72: "ml",
        73: "kn",
        74: "ta",
        75: "te",
        76: "si",
        77: "my",
        78: "km",
        79: "lo",
        80: "vi",
        81: "id",
        82: "tl",
        83: "ms",
        84: "ms-Arab",
        85: "am",
        86: "ti",
        87: "om",
        88: "so",
        89: "sw",
        90: "rw",
        91: "rn",
        92: "ny",
        93: "mg",
        94: "eo",
        128: "cy",
        129: "eu",
        130: "ca",
        131: "la",
        132: "qu",
        133: "gn",
        134: "ay",
        135: "tt",
        136: "ug",
        137: "dz",
        138: "jv",
        139: "su",
        140: "gl",
        141: "af",
        142: "br",
        143: "iu",
        144: "gd",
        145: "gv",
        146: "ga",
        147: "to",
        148: "el-polyton",
        149: "kl",
        150: "az",
        151: "nn"
      };
      var macLanguageToScript = {
        0: 0,
        // langEnglish → smRoman
        1: 0,
        // langFrench → smRoman
        2: 0,
        // langGerman → smRoman
        3: 0,
        // langItalian → smRoman
        4: 0,
        // langDutch → smRoman
        5: 0,
        // langSwedish → smRoman
        6: 0,
        // langSpanish → smRoman
        7: 0,
        // langDanish → smRoman
        8: 0,
        // langPortuguese → smRoman
        9: 0,
        // langNorwegian → smRoman
        10: 5,
        // langHebrew → smHebrew
        11: 1,
        // langJapanese → smJapanese
        12: 4,
        // langArabic → smArabic
        13: 0,
        // langFinnish → smRoman
        14: 6,
        // langGreek → smGreek
        15: 0,
        // langIcelandic → smRoman (modified)
        16: 0,
        // langMaltese → smRoman
        17: 0,
        // langTurkish → smRoman (modified)
        18: 0,
        // langCroatian → smRoman (modified)
        19: 2,
        // langTradChinese → smTradChinese
        20: 4,
        // langUrdu → smArabic
        21: 9,
        // langHindi → smDevanagari
        22: 21,
        // langThai → smThai
        23: 3,
        // langKorean → smKorean
        24: 29,
        // langLithuanian → smCentralEuroRoman
        25: 29,
        // langPolish → smCentralEuroRoman
        26: 29,
        // langHungarian → smCentralEuroRoman
        27: 29,
        // langEstonian → smCentralEuroRoman
        28: 29,
        // langLatvian → smCentralEuroRoman
        29: 0,
        // langSami → smRoman
        30: 0,
        // langFaroese → smRoman (modified)
        31: 4,
        // langFarsi → smArabic (modified)
        32: 7,
        // langRussian → smCyrillic
        33: 25,
        // langSimpChinese → smSimpChinese
        34: 0,
        // langFlemish → smRoman
        35: 0,
        // langIrishGaelic → smRoman (modified)
        36: 0,
        // langAlbanian → smRoman
        37: 0,
        // langRomanian → smRoman (modified)
        38: 29,
        // langCzech → smCentralEuroRoman
        39: 29,
        // langSlovak → smCentralEuroRoman
        40: 0,
        // langSlovenian → smRoman (modified)
        41: 5,
        // langYiddish → smHebrew
        42: 7,
        // langSerbian → smCyrillic
        43: 7,
        // langMacedonian → smCyrillic
        44: 7,
        // langBulgarian → smCyrillic
        45: 7,
        // langUkrainian → smCyrillic (modified)
        46: 7,
        // langByelorussian → smCyrillic
        47: 7,
        // langUzbek → smCyrillic
        48: 7,
        // langKazakh → smCyrillic
        49: 7,
        // langAzerbaijani → smCyrillic
        50: 4,
        // langAzerbaijanAr → smArabic
        51: 24,
        // langArmenian → smArmenian
        52: 23,
        // langGeorgian → smGeorgian
        53: 7,
        // langMoldavian → smCyrillic
        54: 7,
        // langKirghiz → smCyrillic
        55: 7,
        // langTajiki → smCyrillic
        56: 7,
        // langTurkmen → smCyrillic
        57: 27,
        // langMongolian → smMongolian
        58: 7,
        // langMongolianCyr → smCyrillic
        59: 4,
        // langPashto → smArabic
        60: 4,
        // langKurdish → smArabic
        61: 4,
        // langKashmiri → smArabic
        62: 4,
        // langSindhi → smArabic
        63: 26,
        // langTibetan → smTibetan
        64: 9,
        // langNepali → smDevanagari
        65: 9,
        // langSanskrit → smDevanagari
        66: 9,
        // langMarathi → smDevanagari
        67: 13,
        // langBengali → smBengali
        68: 13,
        // langAssamese → smBengali
        69: 11,
        // langGujarati → smGujarati
        70: 10,
        // langPunjabi → smGurmukhi
        71: 12,
        // langOriya → smOriya
        72: 17,
        // langMalayalam → smMalayalam
        73: 16,
        // langKannada → smKannada
        74: 14,
        // langTamil → smTamil
        75: 15,
        // langTelugu → smTelugu
        76: 18,
        // langSinhalese → smSinhalese
        77: 19,
        // langBurmese → smBurmese
        78: 20,
        // langKhmer → smKhmer
        79: 22,
        // langLao → smLao
        80: 30,
        // langVietnamese → smVietnamese
        81: 0,
        // langIndonesian → smRoman
        82: 0,
        // langTagalog → smRoman
        83: 0,
        // langMalayRoman → smRoman
        84: 4,
        // langMalayArabic → smArabic
        85: 28,
        // langAmharic → smEthiopic
        86: 28,
        // langTigrinya → smEthiopic
        87: 28,
        // langOromo → smEthiopic
        88: 0,
        // langSomali → smRoman
        89: 0,
        // langSwahili → smRoman
        90: 0,
        // langKinyarwanda → smRoman
        91: 0,
        // langRundi → smRoman
        92: 0,
        // langNyanja → smRoman
        93: 0,
        // langMalagasy → smRoman
        94: 0,
        // langEsperanto → smRoman
        128: 0,
        // langWelsh → smRoman (modified)
        129: 0,
        // langBasque → smRoman
        130: 0,
        // langCatalan → smRoman
        131: 0,
        // langLatin → smRoman
        132: 0,
        // langQuechua → smRoman
        133: 0,
        // langGuarani → smRoman
        134: 0,
        // langAymara → smRoman
        135: 7,
        // langTatar → smCyrillic
        136: 4,
        // langUighur → smArabic
        137: 26,
        // langDzongkha → smTibetan
        138: 0,
        // langJavaneseRom → smRoman
        139: 0,
        // langSundaneseRom → smRoman
        140: 0,
        // langGalician → smRoman
        141: 0,
        // langAfrikaans → smRoman
        142: 0,
        // langBreton → smRoman (modified)
        143: 28,
        // langInuktitut → smEthiopic (modified)
        144: 0,
        // langScottishGaelic → smRoman (modified)
        145: 0,
        // langManxGaelic → smRoman (modified)
        146: 0,
        // langIrishGaelicScript → smRoman (modified)
        147: 0,
        // langTongan → smRoman
        148: 6,
        // langGreekAncient → smRoman
        149: 0,
        // langGreenlandic → smRoman
        150: 0,
        // langAzerbaijanRoman → smRoman
        151: 0
        // langNynorsk → smRoman
      };
      var windowsLanguages = {
        1078: "af",
        1052: "sq",
        1156: "gsw",
        1118: "am",
        5121: "ar-DZ",
        15361: "ar-BH",
        3073: "ar",
        2049: "ar-IQ",
        11265: "ar-JO",
        13313: "ar-KW",
        12289: "ar-LB",
        4097: "ar-LY",
        6145: "ary",
        8193: "ar-OM",
        16385: "ar-QA",
        1025: "ar-SA",
        10241: "ar-SY",
        7169: "aeb",
        14337: "ar-AE",
        9217: "ar-YE",
        1067: "hy",
        1101: "as",
        2092: "az-Cyrl",
        1068: "az",
        1133: "ba",
        1069: "eu",
        1059: "be",
        2117: "bn",
        1093: "bn-IN",
        8218: "bs-Cyrl",
        5146: "bs",
        1150: "br",
        1026: "bg",
        1027: "ca",
        3076: "zh-HK",
        5124: "zh-MO",
        2052: "zh",
        4100: "zh-SG",
        1028: "zh-TW",
        1155: "co",
        1050: "hr",
        4122: "hr-BA",
        1029: "cs",
        1030: "da",
        1164: "prs",
        1125: "dv",
        2067: "nl-BE",
        1043: "nl",
        3081: "en-AU",
        10249: "en-BZ",
        4105: "en-CA",
        9225: "en-029",
        16393: "en-IN",
        6153: "en-IE",
        8201: "en-JM",
        17417: "en-MY",
        5129: "en-NZ",
        13321: "en-PH",
        18441: "en-SG",
        7177: "en-ZA",
        11273: "en-TT",
        2057: "en-GB",
        1033: "en",
        12297: "en-ZW",
        1061: "et",
        1080: "fo",
        1124: "fil",
        1035: "fi",
        2060: "fr-BE",
        3084: "fr-CA",
        1036: "fr",
        5132: "fr-LU",
        6156: "fr-MC",
        4108: "fr-CH",
        1122: "fy",
        1110: "gl",
        1079: "ka",
        3079: "de-AT",
        1031: "de",
        5127: "de-LI",
        4103: "de-LU",
        2055: "de-CH",
        1032: "el",
        1135: "kl",
        1095: "gu",
        1128: "ha",
        1037: "he",
        1081: "hi",
        1038: "hu",
        1039: "is",
        1136: "ig",
        1057: "id",
        1117: "iu",
        2141: "iu-Latn",
        2108: "ga",
        1076: "xh",
        1077: "zu",
        1040: "it",
        2064: "it-CH",
        1041: "ja",
        1099: "kn",
        1087: "kk",
        1107: "km",
        1158: "quc",
        1159: "rw",
        1089: "sw",
        1111: "kok",
        1042: "ko",
        1088: "ky",
        1108: "lo",
        1062: "lv",
        1063: "lt",
        2094: "dsb",
        1134: "lb",
        1071: "mk",
        2110: "ms-BN",
        1086: "ms",
        1100: "ml",
        1082: "mt",
        1153: "mi",
        1146: "arn",
        1102: "mr",
        1148: "moh",
        1104: "mn",
        2128: "mn-CN",
        1121: "ne",
        1044: "nb",
        2068: "nn",
        1154: "oc",
        1096: "or",
        1123: "ps",
        1045: "pl",
        1046: "pt",
        2070: "pt-PT",
        1094: "pa",
        1131: "qu-BO",
        2155: "qu-EC",
        3179: "qu",
        1048: "ro",
        1047: "rm",
        1049: "ru",
        9275: "smn",
        4155: "smj-NO",
        5179: "smj",
        3131: "se-FI",
        1083: "se",
        2107: "se-SE",
        8251: "sms",
        6203: "sma-NO",
        7227: "sms",
        1103: "sa",
        7194: "sr-Cyrl-BA",
        3098: "sr",
        6170: "sr-Latn-BA",
        2074: "sr-Latn",
        1132: "nso",
        1074: "tn",
        1115: "si",
        1051: "sk",
        1060: "sl",
        11274: "es-AR",
        16394: "es-BO",
        13322: "es-CL",
        9226: "es-CO",
        5130: "es-CR",
        7178: "es-DO",
        12298: "es-EC",
        17418: "es-SV",
        4106: "es-GT",
        18442: "es-HN",
        2058: "es-MX",
        19466: "es-NI",
        6154: "es-PA",
        15370: "es-PY",
        10250: "es-PE",
        20490: "es-PR",
        // Microsoft has defined two different language codes for
        // “Spanish with modern sorting” and “Spanish with traditional
        // sorting”. This makes sense for collation APIs, and it would be
        // possible to express this in BCP 47 language tags via Unicode
        // extensions (eg., es-u-co-trad is Spanish with traditional
        // sorting). However, for storing names in fonts, the distinction
        // does not make sense, so we give “es” in both cases.
        3082: "es",
        1034: "es",
        21514: "es-US",
        14346: "es-UY",
        8202: "es-VE",
        2077: "sv-FI",
        1053: "sv",
        1114: "syr",
        1064: "tg",
        2143: "tzm",
        1097: "ta",
        1092: "tt",
        1098: "te",
        1054: "th",
        1105: "bo",
        1055: "tr",
        1090: "tk",
        1152: "ug",
        1058: "uk",
        1070: "hsb",
        1056: "ur",
        2115: "uz-Cyrl",
        1091: "uz",
        1066: "vi",
        1106: "cy",
        1160: "wo",
        1157: "sah",
        1144: "ii",
        1130: "yo"
      };
      function getLanguageCode(platformID, languageID, ltag2) {
        switch (platformID) {
          case 0:
            if (languageID === 65535) {
              return "und";
            } else if (ltag2) {
              return ltag2[languageID];
            }
            break;
          case 1:
            return macLanguages[languageID];
          case 3:
            return windowsLanguages[languageID];
        }
        return void 0;
      }
      __name(getLanguageCode, "getLanguageCode");
      var utf16 = "utf-16";
      var macScriptEncodings = {
        0: "macintosh",
        // smRoman
        1: "x-mac-japanese",
        // smJapanese
        2: "x-mac-chinesetrad",
        // smTradChinese
        3: "x-mac-korean",
        // smKorean
        6: "x-mac-greek",
        // smGreek
        7: "x-mac-cyrillic",
        // smCyrillic
        9: "x-mac-devanagai",
        // smDevanagari
        10: "x-mac-gurmukhi",
        // smGurmukhi
        11: "x-mac-gujarati",
        // smGujarati
        12: "x-mac-oriya",
        // smOriya
        13: "x-mac-bengali",
        // smBengali
        14: "x-mac-tamil",
        // smTamil
        15: "x-mac-telugu",
        // smTelugu
        16: "x-mac-kannada",
        // smKannada
        17: "x-mac-malayalam",
        // smMalayalam
        18: "x-mac-sinhalese",
        // smSinhalese
        19: "x-mac-burmese",
        // smBurmese
        20: "x-mac-khmer",
        // smKhmer
        21: "x-mac-thai",
        // smThai
        22: "x-mac-lao",
        // smLao
        23: "x-mac-georgian",
        // smGeorgian
        24: "x-mac-armenian",
        // smArmenian
        25: "x-mac-chinesesimp",
        // smSimpChinese
        26: "x-mac-tibetan",
        // smTibetan
        27: "x-mac-mongolian",
        // smMongolian
        28: "x-mac-ethiopic",
        // smEthiopic
        29: "x-mac-ce",
        // smCentralEuroRoman
        30: "x-mac-vietnamese",
        // smVietnamese
        31: "x-mac-extarabic"
        // smExtArabic
      };
      var macLanguageEncodings = {
        15: "x-mac-icelandic",
        // langIcelandic
        17: "x-mac-turkish",
        // langTurkish
        18: "x-mac-croatian",
        // langCroatian
        24: "x-mac-ce",
        // langLithuanian
        25: "x-mac-ce",
        // langPolish
        26: "x-mac-ce",
        // langHungarian
        27: "x-mac-ce",
        // langEstonian
        28: "x-mac-ce",
        // langLatvian
        30: "x-mac-icelandic",
        // langFaroese
        37: "x-mac-romanian",
        // langRomanian
        38: "x-mac-ce",
        // langCzech
        39: "x-mac-ce",
        // langSlovak
        40: "x-mac-ce",
        // langSlovenian
        143: "x-mac-inuit",
        // langInuktitut
        146: "x-mac-gaelic"
        // langIrishGaelicScript
      };
      function getEncoding(platformID, encodingID, languageID) {
        switch (platformID) {
          case 0:
            return utf16;
          case 1:
            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];
          case 3:
            if (encodingID === 1 || encodingID === 10) {
              return utf16;
            }
            break;
        }
        return void 0;
      }
      __name(getEncoding, "getEncoding");
      function parseNameTable(data, start, ltag2) {
        var name2 = {};
        var p = new parse.Parser(data, start);
        var format = p.parseUShort();
        var count = p.parseUShort();
        var stringOffset = p.offset + p.parseUShort();
        for (var i = 0; i < count; i++) {
          var platformID = p.parseUShort();
          var encodingID = p.parseUShort();
          var languageID = p.parseUShort();
          var nameID = p.parseUShort();
          var property = nameTableNames[nameID] || nameID;
          var byteLength = p.parseUShort();
          var offset = p.parseUShort();
          var language = getLanguageCode(platformID, languageID, ltag2);
          var encoding2 = getEncoding(platformID, encodingID, languageID);
          if (encoding2 !== void 0 && language !== void 0) {
            var text;
            if (encoding2 === utf16) {
              text = decode2.UTF16(data, stringOffset + offset, byteLength);
            } else {
              text = decode2.MACSTRING(data, stringOffset + offset, byteLength, encoding2);
            }
            if (text) {
              var translations = name2[property];
              if (translations === void 0) {
                translations = name2[property] = {};
              }
              translations[language] = text;
            }
          }
        }
        if (format === 1) {
          p.parseUShort();
        }
        return name2;
      }
      __name(parseNameTable, "parseNameTable");
      function reverseDict(dict) {
        var result = {};
        for (var key in dict) {
          result[dict[key]] = parseInt(key);
        }
        return result;
      }
      __name(reverseDict, "reverseDict");
      function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
        return new table.Table("NameRecord", [
          { name: "platformID", type: "USHORT", value: platformID },
          { name: "encodingID", type: "USHORT", value: encodingID },
          { name: "languageID", type: "USHORT", value: languageID },
          { name: "nameID", type: "USHORT", value: nameID },
          { name: "length", type: "USHORT", value: length },
          { name: "offset", type: "USHORT", value: offset }
        ]);
      }
      __name(makeNameRecord, "makeNameRecord");
      function findSubArray(needle, haystack) {
        var needleLength = needle.length;
        var limit = haystack.length - needleLength + 1;
        loop:
          for (var pos = 0; pos < limit; pos++) {
            for (; pos < limit; pos++) {
              for (var k = 0; k < needleLength; k++) {
                if (haystack[pos + k] !== needle[k]) {
                  continue loop;
                }
              }
              return pos;
            }
          }
        return -1;
      }
      __name(findSubArray, "findSubArray");
      function addStringToPool(s, pool) {
        var offset = findSubArray(s, pool);
        if (offset < 0) {
          offset = pool.length;
          for (var i = 0, len = s.length; i < len; ++i) {
            pool.push(s[i]);
          }
        }
        return offset;
      }
      __name(addStringToPool, "addStringToPool");
      function makeNameTable(names, ltag2) {
        var nameID;
        var nameIDs = [];
        var namesWithNumericKeys = {};
        var nameTableIds = reverseDict(nameTableNames);
        for (var key in names) {
          var id = nameTableIds[key];
          if (id === void 0) {
            id = key;
          }
          nameID = parseInt(id);
          namesWithNumericKeys[nameID] = names[key];
          nameIDs.push(nameID);
        }
        var macLanguageIds = reverseDict(macLanguages);
        var windowsLanguageIds = reverseDict(windowsLanguages);
        var nameRecords = [];
        var stringPool = [];
        for (var i = 0; i < nameIDs.length; i++) {
          nameID = nameIDs[i];
          var translations = namesWithNumericKeys[nameID];
          for (var lang in translations) {
            var text = translations[lang];
            var macPlatform = 1;
            var macLanguage = macLanguageIds[lang];
            var macScript = macLanguageToScript[macLanguage];
            var macEncoding = getEncoding(macPlatform, macScript, macLanguage);
            var macName = encode2.MACSTRING(text, macEncoding);
            if (macName === void 0) {
              macPlatform = 0;
              macLanguage = ltag2.indexOf(lang);
              if (macLanguage < 0) {
                macLanguage = ltag2.length;
                ltag2.push(lang);
              }
              macScript = 4;
              macName = encode2.UTF16(text);
            }
            var macNameOffset = addStringToPool(macName, stringPool);
            nameRecords.push(makeNameRecord(
              macPlatform,
              macScript,
              macLanguage,
              nameID,
              macName.length,
              macNameOffset
            ));
            var winLanguage = windowsLanguageIds[lang];
            if (winLanguage !== void 0) {
              var winName = encode2.UTF16(text);
              var winNameOffset = addStringToPool(winName, stringPool);
              nameRecords.push(makeNameRecord(
                3,
                1,
                winLanguage,
                nameID,
                winName.length,
                winNameOffset
              ));
            }
          }
        }
        nameRecords.sort(function(a, b) {
          return a.platformID - b.platformID || a.encodingID - b.encodingID || a.languageID - b.languageID || a.nameID - b.nameID;
        });
        var t = new table.Table("name", [
          { name: "format", type: "USHORT", value: 0 },
          { name: "count", type: "USHORT", value: nameRecords.length },
          { name: "stringOffset", type: "USHORT", value: 6 + nameRecords.length * 12 }
        ]);
        for (var r = 0; r < nameRecords.length; r++) {
          t.fields.push({ name: "record_" + r, type: "TABLE", value: nameRecords[r] });
        }
        t.fields.push({ name: "strings", type: "LITERAL", value: stringPool });
        return t;
      }
      __name(makeNameTable, "makeNameTable");
      var parse_1$7 = parseNameTable;
      var make$5 = makeNameTable;
      var name = {
        parse: parse_1$7,
        make: make$5
      };
      var unicodeRanges = [
        { begin: 0, end: 127 },
        // Basic Latin
        { begin: 128, end: 255 },
        // Latin-1 Supplement
        { begin: 256, end: 383 },
        // Latin Extended-A
        { begin: 384, end: 591 },
        // Latin Extended-B
        { begin: 592, end: 687 },
        // IPA Extensions
        { begin: 688, end: 767 },
        // Spacing Modifier Letters
        { begin: 768, end: 879 },
        // Combining Diacritical Marks
        { begin: 880, end: 1023 },
        // Greek and Coptic
        { begin: 11392, end: 11519 },
        // Coptic
        { begin: 1024, end: 1279 },
        // Cyrillic
        { begin: 1328, end: 1423 },
        // Armenian
        { begin: 1424, end: 1535 },
        // Hebrew
        { begin: 42240, end: 42559 },
        // Vai
        { begin: 1536, end: 1791 },
        // Arabic
        { begin: 1984, end: 2047 },
        // NKo
        { begin: 2304, end: 2431 },
        // Devanagari
        { begin: 2432, end: 2559 },
        // Bengali
        { begin: 2560, end: 2687 },
        // Gurmukhi
        { begin: 2688, end: 2815 },
        // Gujarati
        { begin: 2816, end: 2943 },
        // Oriya
        { begin: 2944, end: 3071 },
        // Tamil
        { begin: 3072, end: 3199 },
        // Telugu
        { begin: 3200, end: 3327 },
        // Kannada
        { begin: 3328, end: 3455 },
        // Malayalam
        { begin: 3584, end: 3711 },
        // Thai
        { begin: 3712, end: 3839 },
        // Lao
        { begin: 4256, end: 4351 },
        // Georgian
        { begin: 6912, end: 7039 },
        // Balinese
        { begin: 4352, end: 4607 },
        // Hangul Jamo
        { begin: 7680, end: 7935 },
        // Latin Extended Additional
        { begin: 7936, end: 8191 },
        // Greek Extended
        { begin: 8192, end: 8303 },
        // General Punctuation
        { begin: 8304, end: 8351 },
        // Superscripts And Subscripts
        { begin: 8352, end: 8399 },
        // Currency Symbol
        { begin: 8400, end: 8447 },
        // Combining Diacritical Marks For Symbols
        { begin: 8448, end: 8527 },
        // Letterlike Symbols
        { begin: 8528, end: 8591 },
        // Number Forms
        { begin: 8592, end: 8703 },
        // Arrows
        { begin: 8704, end: 8959 },
        // Mathematical Operators
        { begin: 8960, end: 9215 },
        // Miscellaneous Technical
        { begin: 9216, end: 9279 },
        // Control Pictures
        { begin: 9280, end: 9311 },
        // Optical Character Recognition
        { begin: 9312, end: 9471 },
        // Enclosed Alphanumerics
        { begin: 9472, end: 9599 },
        // Box Drawing
        { begin: 9600, end: 9631 },
        // Block Elements
        { begin: 9632, end: 9727 },
        // Geometric Shapes
        { begin: 9728, end: 9983 },
        // Miscellaneous Symbols
        { begin: 9984, end: 10175 },
        // Dingbats
        { begin: 12288, end: 12351 },
        // CJK Symbols And Punctuation
        { begin: 12352, end: 12447 },
        // Hiragana
        { begin: 12448, end: 12543 },
        // Katakana
        { begin: 12544, end: 12591 },
        // Bopomofo
        { begin: 12592, end: 12687 },
        // Hangul Compatibility Jamo
        { begin: 43072, end: 43135 },
        // Phags-pa
        { begin: 12800, end: 13055 },
        // Enclosed CJK Letters And Months
        { begin: 13056, end: 13311 },
        // CJK Compatibility
        { begin: 44032, end: 55215 },
        // Hangul Syllables
        { begin: 55296, end: 57343 },
        // Non-Plane 0 *
        { begin: 67840, end: 67871 },
        // Phoenicia
        { begin: 19968, end: 40959 },
        // CJK Unified Ideographs
        { begin: 57344, end: 63743 },
        // Private Use Area (plane 0)
        { begin: 12736, end: 12783 },
        // CJK Strokes
        { begin: 64256, end: 64335 },
        // Alphabetic Presentation Forms
        { begin: 64336, end: 65023 },
        // Arabic Presentation Forms-A
        { begin: 65056, end: 65071 },
        // Combining Half Marks
        { begin: 65040, end: 65055 },
        // Vertical Forms
        { begin: 65104, end: 65135 },
        // Small Form Variants
        { begin: 65136, end: 65279 },
        // Arabic Presentation Forms-B
        { begin: 65280, end: 65519 },
        // Halfwidth And Fullwidth Forms
        { begin: 65520, end: 65535 },
        // Specials
        { begin: 3840, end: 4095 },
        // Tibetan
        { begin: 1792, end: 1871 },
        // Syriac
        { begin: 1920, end: 1983 },
        // Thaana
        { begin: 3456, end: 3583 },
        // Sinhala
        { begin: 4096, end: 4255 },
        // Myanmar
        { begin: 4608, end: 4991 },
        // Ethiopic
        { begin: 5024, end: 5119 },
        // Cherokee
        { begin: 5120, end: 5759 },
        // Unified Canadian Aboriginal Syllabics
        { begin: 5760, end: 5791 },
        // Ogham
        { begin: 5792, end: 5887 },
        // Runic
        { begin: 6016, end: 6143 },
        // Khmer
        { begin: 6144, end: 6319 },
        // Mongolian
        { begin: 10240, end: 10495 },
        // Braille Patterns
        { begin: 40960, end: 42127 },
        // Yi Syllables
        { begin: 5888, end: 5919 },
        // Tagalog
        { begin: 66304, end: 66351 },
        // Old Italic
        { begin: 66352, end: 66383 },
        // Gothic
        { begin: 66560, end: 66639 },
        // Deseret
        { begin: 118784, end: 119039 },
        // Byzantine Musical Symbols
        { begin: 119808, end: 120831 },
        // Mathematical Alphanumeric Symbols
        { begin: 1044480, end: 1048573 },
        // Private Use (plane 15)
        { begin: 65024, end: 65039 },
        // Variation Selectors
        { begin: 917504, end: 917631 },
        // Tags
        { begin: 6400, end: 6479 },
        // Limbu
        { begin: 6480, end: 6527 },
        // Tai Le
        { begin: 6528, end: 6623 },
        // New Tai Lue
        { begin: 6656, end: 6687 },
        // Buginese
        { begin: 11264, end: 11359 },
        // Glagolitic
        { begin: 11568, end: 11647 },
        // Tifinagh
        { begin: 19904, end: 19967 },
        // Yijing Hexagram Symbols
        { begin: 43008, end: 43055 },
        // Syloti Nagri
        { begin: 65536, end: 65663 },
        // Linear B Syllabary
        { begin: 65856, end: 65935 },
        // Ancient Greek Numbers
        { begin: 66432, end: 66463 },
        // Ugaritic
        { begin: 66464, end: 66527 },
        // Old Persian
        { begin: 66640, end: 66687 },
        // Shavian
        { begin: 66688, end: 66735 },
        // Osmanya
        { begin: 67584, end: 67647 },
        // Cypriot Syllabary
        { begin: 68096, end: 68191 },
        // Kharoshthi
        { begin: 119552, end: 119647 },
        // Tai Xuan Jing Symbols
        { begin: 73728, end: 74751 },
        // Cuneiform
        { begin: 119648, end: 119679 },
        // Counting Rod Numerals
        { begin: 7040, end: 7103 },
        // Sundanese
        { begin: 7168, end: 7247 },
        // Lepcha
        { begin: 7248, end: 7295 },
        // Ol Chiki
        { begin: 43136, end: 43231 },
        // Saurashtra
        { begin: 43264, end: 43311 },
        // Kayah Li
        { begin: 43312, end: 43359 },
        // Rejang
        { begin: 43520, end: 43615 },
        // Cham
        { begin: 65936, end: 65999 },
        // Ancient Symbols
        { begin: 66e3, end: 66047 },
        // Phaistos Disc
        { begin: 66208, end: 66271 },
        // Carian
        { begin: 127024, end: 127135 }
        // Domino Tiles
      ];
      function getUnicodeRange(unicode) {
        for (var i = 0; i < unicodeRanges.length; i += 1) {
          var range = unicodeRanges[i];
          if (unicode >= range.begin && unicode < range.end) {
            return i;
          }
        }
        return -1;
      }
      __name(getUnicodeRange, "getUnicodeRange");
      function parseOS2Table(data, start) {
        var os22 = {};
        var p = new parse.Parser(data, start);
        os22.version = p.parseUShort();
        os22.xAvgCharWidth = p.parseShort();
        os22.usWeightClass = p.parseUShort();
        os22.usWidthClass = p.parseUShort();
        os22.fsType = p.parseUShort();
        os22.ySubscriptXSize = p.parseShort();
        os22.ySubscriptYSize = p.parseShort();
        os22.ySubscriptXOffset = p.parseShort();
        os22.ySubscriptYOffset = p.parseShort();
        os22.ySuperscriptXSize = p.parseShort();
        os22.ySuperscriptYSize = p.parseShort();
        os22.ySuperscriptXOffset = p.parseShort();
        os22.ySuperscriptYOffset = p.parseShort();
        os22.yStrikeoutSize = p.parseShort();
        os22.yStrikeoutPosition = p.parseShort();
        os22.sFamilyClass = p.parseShort();
        os22.panose = [];
        for (var i = 0; i < 10; i++) {
          os22.panose[i] = p.parseByte();
        }
        os22.ulUnicodeRange1 = p.parseULong();
        os22.ulUnicodeRange2 = p.parseULong();
        os22.ulUnicodeRange3 = p.parseULong();
        os22.ulUnicodeRange4 = p.parseULong();
        os22.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
        os22.fsSelection = p.parseUShort();
        os22.usFirstCharIndex = p.parseUShort();
        os22.usLastCharIndex = p.parseUShort();
        os22.sTypoAscender = p.parseShort();
        os22.sTypoDescender = p.parseShort();
        os22.sTypoLineGap = p.parseShort();
        os22.usWinAscent = p.parseUShort();
        os22.usWinDescent = p.parseUShort();
        if (os22.version >= 1) {
          os22.ulCodePageRange1 = p.parseULong();
          os22.ulCodePageRange2 = p.parseULong();
        }
        if (os22.version >= 2) {
          os22.sxHeight = p.parseShort();
          os22.sCapHeight = p.parseShort();
          os22.usDefaultChar = p.parseUShort();
          os22.usBreakChar = p.parseUShort();
          os22.usMaxContent = p.parseUShort();
        }
        return os22;
      }
      __name(parseOS2Table, "parseOS2Table");
      function makeOS2Table(options) {
        return new table.Table("OS/2", [
          { name: "version", type: "USHORT", value: 3 },
          { name: "xAvgCharWidth", type: "SHORT", value: 0 },
          { name: "usWeightClass", type: "USHORT", value: 0 },
          { name: "usWidthClass", type: "USHORT", value: 0 },
          { name: "fsType", type: "USHORT", value: 0 },
          { name: "ySubscriptXSize", type: "SHORT", value: 650 },
          { name: "ySubscriptYSize", type: "SHORT", value: 699 },
          { name: "ySubscriptXOffset", type: "SHORT", value: 0 },
          { name: "ySubscriptYOffset", type: "SHORT", value: 140 },
          { name: "ySuperscriptXSize", type: "SHORT", value: 650 },
          { name: "ySuperscriptYSize", type: "SHORT", value: 699 },
          { name: "ySuperscriptXOffset", type: "SHORT", value: 0 },
          { name: "ySuperscriptYOffset", type: "SHORT", value: 479 },
          { name: "yStrikeoutSize", type: "SHORT", value: 49 },
          { name: "yStrikeoutPosition", type: "SHORT", value: 258 },
          { name: "sFamilyClass", type: "SHORT", value: 0 },
          { name: "bFamilyType", type: "BYTE", value: 0 },
          { name: "bSerifStyle", type: "BYTE", value: 0 },
          { name: "bWeight", type: "BYTE", value: 0 },
          { name: "bProportion", type: "BYTE", value: 0 },
          { name: "bContrast", type: "BYTE", value: 0 },
          { name: "bStrokeVariation", type: "BYTE", value: 0 },
          { name: "bArmStyle", type: "BYTE", value: 0 },
          { name: "bLetterform", type: "BYTE", value: 0 },
          { name: "bMidline", type: "BYTE", value: 0 },
          { name: "bXHeight", type: "BYTE", value: 0 },
          { name: "ulUnicodeRange1", type: "ULONG", value: 0 },
          { name: "ulUnicodeRange2", type: "ULONG", value: 0 },
          { name: "ulUnicodeRange3", type: "ULONG", value: 0 },
          { name: "ulUnicodeRange4", type: "ULONG", value: 0 },
          { name: "achVendID", type: "CHARARRAY", value: "XXXX" },
          { name: "fsSelection", type: "USHORT", value: 0 },
          { name: "usFirstCharIndex", type: "USHORT", value: 0 },
          { name: "usLastCharIndex", type: "USHORT", value: 0 },
          { name: "sTypoAscender", type: "SHORT", value: 0 },
          { name: "sTypoDescender", type: "SHORT", value: 0 },
          { name: "sTypoLineGap", type: "SHORT", value: 0 },
          { name: "usWinAscent", type: "USHORT", value: 0 },
          { name: "usWinDescent", type: "USHORT", value: 0 },
          { name: "ulCodePageRange1", type: "ULONG", value: 0 },
          { name: "ulCodePageRange2", type: "ULONG", value: 0 },
          { name: "sxHeight", type: "SHORT", value: 0 },
          { name: "sCapHeight", type: "SHORT", value: 0 },
          { name: "usDefaultChar", type: "USHORT", value: 0 },
          { name: "usBreakChar", type: "USHORT", value: 0 },
          { name: "usMaxContext", type: "USHORT", value: 0 }
        ], options);
      }
      __name(makeOS2Table, "makeOS2Table");
      var unicodeRanges_1 = unicodeRanges;
      var getUnicodeRange_1 = getUnicodeRange;
      var parse_1$6 = parseOS2Table;
      var make$4 = makeOS2Table;
      var os2 = {
        unicodeRanges: unicodeRanges_1,
        getUnicodeRange: getUnicodeRange_1,
        parse: parse_1$6,
        make: make$4
      };
      function parsePostTable(data, start) {
        var post2 = {};
        var p = new parse.Parser(data, start);
        var i;
        post2.version = p.parseVersion();
        post2.italicAngle = p.parseFixed();
        post2.underlinePosition = p.parseShort();
        post2.underlineThickness = p.parseShort();
        post2.isFixedPitch = p.parseULong();
        post2.minMemType42 = p.parseULong();
        post2.maxMemType42 = p.parseULong();
        post2.minMemType1 = p.parseULong();
        post2.maxMemType1 = p.parseULong();
        switch (post2.version) {
          case 1:
            post2.names = encoding.standardNames.slice();
            break;
          case 2:
            post2.numberOfGlyphs = p.parseUShort();
            post2.glyphNameIndex = new Array(post2.numberOfGlyphs);
            for (i = 0; i < post2.numberOfGlyphs; i++) {
              post2.glyphNameIndex[i] = p.parseUShort();
            }
            post2.names = [];
            for (i = 0; i < post2.numberOfGlyphs; i++) {
              if (post2.glyphNameIndex[i] >= encoding.standardNames.length) {
                var nameLength = p.parseChar();
                post2.names.push(p.parseString(nameLength));
              }
            }
            break;
          case 2.5:
            post2.numberOfGlyphs = p.parseUShort();
            post2.offset = new Array(post2.numberOfGlyphs);
            for (i = 0; i < post2.numberOfGlyphs; i++) {
              post2.offset[i] = p.parseChar();
            }
            break;
        }
        return post2;
      }
      __name(parsePostTable, "parsePostTable");
      function makePostTable() {
        return new table.Table("post", [
          { name: "version", type: "FIXED", value: 196608 },
          { name: "italicAngle", type: "FIXED", value: 0 },
          { name: "underlinePosition", type: "FWORD", value: 0 },
          { name: "underlineThickness", type: "FWORD", value: 0 },
          { name: "isFixedPitch", type: "ULONG", value: 0 },
          { name: "minMemType42", type: "ULONG", value: 0 },
          { name: "maxMemType42", type: "ULONG", value: 0 },
          { name: "minMemType1", type: "ULONG", value: 0 },
          { name: "maxMemType1", type: "ULONG", value: 0 }
        ]);
      }
      __name(makePostTable, "makePostTable");
      var parse_1$5 = parsePostTable;
      var make$3 = makePostTable;
      var post = {
        parse: parse_1$5,
        make: make$3
      };
      function log2(v) {
        return Math.log(v) / Math.log(2) | 0;
      }
      __name(log2, "log2");
      function computeCheckSum(bytes) {
        while (bytes.length % 4 !== 0) {
          bytes.push(0);
        }
        var sum = 0;
        for (var i = 0; i < bytes.length; i += 4) {
          sum += (bytes[i] << 24) + (bytes[i + 1] << 16) + (bytes[i + 2] << 8) + bytes[i + 3];
        }
        sum %= Math.pow(2, 32);
        return sum;
      }
      __name(computeCheckSum, "computeCheckSum");
      function makeTableRecord(tag, checkSum, offset, length) {
        return new table.Table("Table Record", [
          { name: "tag", type: "TAG", value: tag !== void 0 ? tag : "" },
          { name: "checkSum", type: "ULONG", value: checkSum !== void 0 ? checkSum : 0 },
          { name: "offset", type: "ULONG", value: offset !== void 0 ? offset : 0 },
          { name: "length", type: "ULONG", value: length !== void 0 ? length : 0 }
        ]);
      }
      __name(makeTableRecord, "makeTableRecord");
      function makeSfntTable(tables) {
        var sfnt2 = new table.Table("sfnt", [
          { name: "version", type: "TAG", value: "OTTO" },
          { name: "numTables", type: "USHORT", value: 0 },
          { name: "searchRange", type: "USHORT", value: 0 },
          { name: "entrySelector", type: "USHORT", value: 0 },
          { name: "rangeShift", type: "USHORT", value: 0 }
        ]);
        sfnt2.tables = tables;
        sfnt2.numTables = tables.length;
        var highestPowerOf2 = Math.pow(2, log2(sfnt2.numTables));
        sfnt2.searchRange = 16 * highestPowerOf2;
        sfnt2.entrySelector = log2(highestPowerOf2);
        sfnt2.rangeShift = sfnt2.numTables * 16 - sfnt2.searchRange;
        var recordFields = [];
        var tableFields = [];
        var offset = sfnt2.sizeOf() + makeTableRecord().sizeOf() * sfnt2.numTables;
        while (offset % 4 !== 0) {
          offset += 1;
          tableFields.push({ name: "padding", type: "BYTE", value: 0 });
        }
        for (var i = 0; i < tables.length; i += 1) {
          var t = tables[i];
          check.argument(t.tableName.length === 4, "Table name" + t.tableName + " is invalid.");
          var tableLength = t.sizeOf();
          var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
          recordFields.push({ name: tableRecord.tag + " Table Record", type: "TABLE", value: tableRecord });
          tableFields.push({ name: t.tableName + " table", type: "TABLE", value: t });
          offset += tableLength;
          check.argument(!isNaN(offset), "Something went wrong calculating the offset.");
          while (offset % 4 !== 0) {
            offset += 1;
            tableFields.push({ name: "padding", type: "BYTE", value: 0 });
          }
        }
        recordFields.sort(function(r1, r2) {
          if (r1.value.tag > r2.value.tag) {
            return 1;
          } else {
            return -1;
          }
        });
        sfnt2.fields = sfnt2.fields.concat(recordFields);
        sfnt2.fields = sfnt2.fields.concat(tableFields);
        return sfnt2;
      }
      __name(makeSfntTable, "makeSfntTable");
      function metricsForChar(font2, chars, notFoundMetrics) {
        for (var i = 0; i < chars.length; i += 1) {
          var glyphIndex = font2.charToGlyphIndex(chars[i]);
          if (glyphIndex > 0) {
            var glyph2 = font2.glyphs.get(glyphIndex);
            return glyph2.getMetrics();
          }
        }
        return notFoundMetrics;
      }
      __name(metricsForChar, "metricsForChar");
      function average(vs) {
        var sum = 0;
        for (var i = 0; i < vs.length; i += 1) {
          sum += vs[i];
        }
        return sum / vs.length;
      }
      __name(average, "average");
      function fontToSfntTable(font2) {
        var xMins = [];
        var yMins = [];
        var xMaxs = [];
        var yMaxs = [];
        var advanceWidths = [];
        var leftSideBearings = [];
        var rightSideBearings = [];
        var firstCharIndex;
        var lastCharIndex = 0;
        var ulUnicodeRange1 = 0;
        var ulUnicodeRange2 = 0;
        var ulUnicodeRange3 = 0;
        var ulUnicodeRange4 = 0;
        for (var i = 0; i < font2.glyphs.length; i += 1) {
          var glyph2 = font2.glyphs.get(i);
          var unicode = glyph2.unicode | 0;
          if (firstCharIndex > unicode || firstCharIndex === null) {
            firstCharIndex = unicode;
          }
          if (lastCharIndex < unicode) {
            lastCharIndex = unicode;
          }
          var position = os2.getUnicodeRange(unicode);
          if (position < 32) {
            ulUnicodeRange1 |= 1 << position;
          } else if (position < 64) {
            ulUnicodeRange2 |= 1 << position - 32;
          } else if (position < 96) {
            ulUnicodeRange3 |= 1 << position - 64;
          } else if (position < 123) {
            ulUnicodeRange4 |= 1 << position - 96;
          } else {
            throw new Error("Unicode ranges bits > 123 are reserved for internal usage");
          }
          if (glyph2.name === ".notdef")
            continue;
          var metrics = glyph2.getMetrics();
          xMins.push(metrics.xMin);
          yMins.push(metrics.yMin);
          xMaxs.push(metrics.xMax);
          yMaxs.push(metrics.yMax);
          leftSideBearings.push(metrics.leftSideBearing);
          rightSideBearings.push(metrics.rightSideBearing);
          advanceWidths.push(glyph2.advanceWidth);
        }
        var globals = {
          xMin: Math.min.apply(null, xMins),
          yMin: Math.min.apply(null, yMins),
          xMax: Math.max.apply(null, xMaxs),
          yMax: Math.max.apply(null, yMaxs),
          advanceWidthMax: Math.max.apply(null, advanceWidths),
          advanceWidthAvg: average(advanceWidths),
          minLeftSideBearing: Math.min.apply(null, leftSideBearings),
          maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
          minRightSideBearing: Math.min.apply(null, rightSideBearings)
        };
        globals.ascender = font2.ascender !== void 0 ? font2.ascender : globals.yMax;
        globals.descender = font2.descender !== void 0 ? font2.descender : globals.yMin;
        var headTable = head.make({
          unitsPerEm: font2.unitsPerEm,
          xMin: globals.xMin,
          yMin: globals.yMin,
          xMax: globals.xMax,
          yMax: globals.yMax
        });
        var hheaTable = hhea.make({
          ascender: globals.ascender,
          descender: globals.descender,
          advanceWidthMax: globals.advanceWidthMax,
          minLeftSideBearing: globals.minLeftSideBearing,
          minRightSideBearing: globals.minRightSideBearing,
          xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
          numberOfHMetrics: font2.glyphs.length
        });
        var maxpTable = maxp.make(font2.glyphs.length);
        var os2Table = os2.make({
          xAvgCharWidth: Math.round(globals.advanceWidthAvg),
          usWeightClass: 500,
          // Medium FIXME Make this configurable
          usWidthClass: 5,
          // Medium (normal) FIXME Make this configurable
          usFirstCharIndex: firstCharIndex,
          usLastCharIndex: lastCharIndex,
          ulUnicodeRange1,
          ulUnicodeRange2,
          ulUnicodeRange3,
          ulUnicodeRange4,
          // See http://typophile.com/node/13081 for more info on vertical metrics.
          // We get metrics for typical characters (such as "x" for xHeight).
          // We provide some fallback characters if characters are unavailable: their
          // ordering was chosen experimentally.
          sTypoAscender: globals.ascender,
          sTypoDescender: globals.descender,
          sTypoLineGap: 0,
          usWinAscent: globals.ascender,
          usWinDescent: -globals.descender,
          sxHeight: metricsForChar(font2, "xyvw", { yMax: 0 }).yMax,
          sCapHeight: metricsForChar(font2, "HIKLEFJMNTZBDPRAGOQSUVWXY", globals).yMax,
          usBreakChar: font2.hasChar(" ") ? 32 : 0
          // Use space as the break character, if available.
        });
        var hmtxTable = hmtx.make(font2.glyphs);
        var cmapTable = cmap.make(font2.glyphs);
        var englishFamilyName = font2.getEnglishName("fontFamily");
        var englishStyleName = font2.getEnglishName("fontSubfamily");
        var englishFullName = englishFamilyName + " " + englishStyleName;
        var postScriptName = font2.getEnglishName("postScriptName");
        if (!postScriptName) {
          postScriptName = englishFamilyName.replace(/\s/g, "") + "-" + englishStyleName;
        }
        var names = {};
        for (var n in font2.names) {
          names[n] = font2.names[n];
        }
        if (!names.uniqueID) {
          names.uniqueID = { en: font2.getEnglishName("manufacturer") + ":" + englishFullName };
        }
        if (!names.postScriptName) {
          names.postScriptName = { en: postScriptName };
        }
        if (!names.preferredFamily) {
          names.preferredFamily = font2.names.fontFamily;
        }
        if (!names.preferredSubfamily) {
          names.preferredSubfamily = font2.names.fontSubfamily;
        }
        var languageTags = [];
        var nameTable = name.make(names, languageTags);
        var ltagTable = languageTags.length > 0 ? ltag.make(languageTags) : void 0;
        var postTable = post.make();
        var cffTable = cff.make(font2.glyphs, {
          version: font2.getEnglishName("version"),
          fullName: englishFullName,
          familyName: englishFamilyName,
          weightName: englishStyleName,
          postScriptName,
          unitsPerEm: font2.unitsPerEm
        });
        var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
        if (ltagTable) {
          tables.push(ltagTable);
        }
        var sfntTable = makeSfntTable(tables);
        var bytes = sfntTable.encode();
        var checkSum = computeCheckSum(bytes);
        var tableFields = sfntTable.fields;
        var checkSumAdjusted = false;
        for (i = 0; i < tableFields.length; i += 1) {
          if (tableFields[i].name === "head table") {
            tableFields[i].value.checkSumAdjustment = 2981146554 - checkSum;
            checkSumAdjusted = true;
            break;
          }
        }
        if (!checkSumAdjusted) {
          throw new Error("Could not find head table with checkSum to adjust.");
        }
        return sfntTable;
      }
      __name(fontToSfntTable, "fontToSfntTable");
      var computeCheckSum_1 = computeCheckSum;
      var make$2 = makeSfntTable;
      var fontToTable = fontToSfntTable;
      var sfnt = {
        computeCheckSum: computeCheckSum_1,
        make: make$2,
        fontToTable
      };
      function Font(options) {
        options = options || {};
        this.names = {
          fontFamily: { en: options.familyName || " " },
          fontSubfamily: { en: options.styleName || " " },
          designer: { en: options.designer || " " },
          designerURL: { en: options.designerURL || " " },
          manufacturer: { en: options.manufacturer || " " },
          manufacturerURL: { en: options.manufacturerURL || " " },
          license: { en: options.license || " " },
          licenseURL: { en: options.licenseURL || " " },
          version: { en: options.version || "Version 0.1" },
          description: { en: options.description || " " },
          copyright: { en: options.copyright || " " },
          trademark: { en: options.trademark || " " }
        };
        this.unitsPerEm = options.unitsPerEm || 1e3;
        this.ascender = options.ascender;
        this.descender = options.descender;
        this.supported = true;
        this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);
        this.encoding = new encoding.DefaultEncoding(this);
        this.tables = {};
      }
      __name(Font, "Font");
      Font.prototype.hasChar = function(c) {
        return this.encoding.charToGlyphIndex(c) !== null;
      };
      Font.prototype.charToGlyphIndex = function(s) {
        return this.encoding.charToGlyphIndex(s);
      };
      Font.prototype.charToGlyph = function(c) {
        var glyphIndex = this.charToGlyphIndex(c);
        var glyph2 = this.glyphs.get(glyphIndex);
        if (!glyph2) {
          glyph2 = this.glyphs.get(0);
        }
        return glyph2;
      };
      Font.prototype.stringToGlyphs = function(s) {
        var glyphs = [];
        for (var i = 0; i < s.length; i += 1) {
          var c = s[i];
          glyphs.push(this.charToGlyph(c));
        }
        return glyphs;
      };
      Font.prototype.nameToGlyphIndex = function(name2) {
        return this.glyphNames.nameToGlyphIndex(name2);
      };
      Font.prototype.nameToGlyph = function(name2) {
        var glyphIndex = this.nametoGlyphIndex(name2);
        var glyph2 = this.glyphs.get(glyphIndex);
        if (!glyph2) {
          glyph2 = this.glyphs.get(0);
        }
        return glyph2;
      };
      Font.prototype.glyphIndexToName = function(gid) {
        if (!this.glyphNames.glyphIndexToName) {
          return "";
        }
        return this.glyphNames.glyphIndexToName(gid);
      };
      Font.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
        leftGlyph = leftGlyph.index || leftGlyph;
        rightGlyph = rightGlyph.index || rightGlyph;
        var gposKerning = this.getGposKerningValue;
        return gposKerning ? gposKerning(leftGlyph, rightGlyph) : this.kerningPairs[leftGlyph + "," + rightGlyph] || 0;
      };
      Font.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
        x = x !== void 0 ? x : 0;
        y = y !== void 0 ? y : 0;
        fontSize = fontSize !== void 0 ? fontSize : 72;
        options = options || {};
        var kerning = options.kerning === void 0 ? true : options.kerning;
        var fontScale = 1 / this.unitsPerEm * fontSize;
        var glyphs = this.stringToGlyphs(text);
        for (var i = 0; i < glyphs.length; i += 1) {
          var glyph2 = glyphs[i];
          callback(glyph2, x, y, fontSize, options);
          if (glyph2.advanceWidth) {
            x += glyph2.advanceWidth * fontScale;
          }
          if (kerning && i < glyphs.length - 1) {
            var kerningValue = this.getKerningValue(glyph2, glyphs[i + 1]);
            x += kerningValue * fontScale;
          }
        }
      };
      Font.prototype.getPath = function(text, x, y, fontSize, options) {
        var fullPath = new path.Path();
        this.forEachGlyph(text, x, y, fontSize, options, function(glyph2, gX, gY, gFontSize) {
          var glyphPath = glyph2.getPath(gX, gY, gFontSize);
          fullPath.extend(glyphPath);
        });
        return fullPath;
      };
      Font.prototype.draw = function(ctx, text, x, y, fontSize, options) {
        this.getPath(text, x, y, fontSize, options).draw(ctx);
      };
      Font.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
        this.forEachGlyph(text, x, y, fontSize, options, function(glyph2, gX, gY, gFontSize) {
          glyph2.drawPoints(ctx, gX, gY, gFontSize);
        });
      };
      Font.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
        this.forEachGlyph(text, x, y, fontSize, options, function(glyph2, gX, gY, gFontSize) {
          glyph2.drawMetrics(ctx, gX, gY, gFontSize);
        });
      };
      Font.prototype.getEnglishName = function(name2) {
        var translations = this.names[name2];
        if (translations) {
          return translations.en;
        }
      };
      Font.prototype.validate = function() {
        var _this = this;
        function assert(predicate, message) {
        }
        __name(assert, "assert");
        function assertNamePresent(name2) {
          var englishName = _this.getEnglishName(name2);
          assert(englishName && englishName.trim().length > 0);
        }
        __name(assertNamePresent, "assertNamePresent");
        assertNamePresent("fontFamily");
        assertNamePresent("weightName");
        assertNamePresent("manufacturer");
        assertNamePresent("copyright");
        assertNamePresent("version");
        assert(this.unitsPerEm > 0);
      };
      Font.prototype.toTables = function() {
        return sfnt.fontToTable(this);
      };
      Font.prototype.toBuffer = function() {
        var sfntTable = this.toTables();
        var bytes = sfntTable.encode();
        var buffer = new ArrayBuffer(bytes.length);
        var intArray = new Uint8Array(buffer);
        for (var i = 0; i < bytes.length; i++) {
          intArray[i] = bytes[i];
        }
        return buffer;
      };
      Font.prototype.download = function() {
        var familyName = this.getEnglishName("fontFamily");
        var styleName = this.getEnglishName("fontSubfamily");
        var fileName = familyName.replace(/\s/g, "") + "-" + styleName + ".otf";
        var buffer = this.toBuffer();
        window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
        window.requestFileSystem(
          window.TEMPORARY,
          buffer.byteLength,
          function(fs) {
            fs.root.getFile(fileName, { create: true }, function(fileEntry) {
              fileEntry.createWriter(function(writer) {
                var dataView = new DataView(buffer);
                var blob = new Blob([dataView], { type: "font/opentype" });
                writer.write(blob);
                writer.addEventListener("writeend", function() {
                  location.href = fileEntry.toURL();
                }, false);
              });
            });
          },
          function(err) {
            throw err;
          }
        );
      };
      var Font_1 = Font;
      var font = {
        Font: Font_1
      };
      function addName(name2, names) {
        var nameString = JSON.stringify(name2);
        var nameID = 256;
        for (var nameKey in names) {
          var n = parseInt(nameKey);
          if (!n || n < 256) {
            continue;
          }
          if (JSON.stringify(names[nameKey]) === nameString) {
            return n;
          }
          if (nameID <= n) {
            nameID = n + 1;
          }
        }
        names[nameID] = name2;
        return nameID;
      }
      __name(addName, "addName");
      function makeFvarAxis(axis, names) {
        var nameID = addName(axis.name, names);
        return new table.Table("fvarAxis", [
          { name: "tag", type: "TAG", value: axis.tag },
          { name: "minValue", type: "FIXED", value: axis.minValue << 16 },
          { name: "defaultValue", type: "FIXED", value: axis.defaultValue << 16 },
          { name: "maxValue", type: "FIXED", value: axis.maxValue << 16 },
          { name: "flags", type: "USHORT", value: 0 },
          { name: "nameID", type: "USHORT", value: nameID }
        ]);
      }
      __name(makeFvarAxis, "makeFvarAxis");
      function parseFvarAxis(data, start, names) {
        var axis = {};
        var p = new parse.Parser(data, start);
        axis.tag = p.parseTag();
        axis.minValue = p.parseFixed();
        axis.defaultValue = p.parseFixed();
        axis.maxValue = p.parseFixed();
        p.skip("uShort", 1);
        axis.name = names[p.parseUShort()] || {};
        return axis;
      }
      __name(parseFvarAxis, "parseFvarAxis");
      function makeFvarInstance(inst, axes, names) {
        var nameID = addName(inst.name, names);
        var fields = [
          { name: "nameID", type: "USHORT", value: nameID },
          { name: "flags", type: "USHORT", value: 0 }
        ];
        for (var i = 0; i < axes.length; ++i) {
          var axisTag = axes[i].tag;
          fields.push({
            name: "axis " + axisTag,
            type: "FIXED",
            value: inst.coordinates[axisTag] << 16
          });
        }
        return new table.Table("fvarInstance", fields);
      }
      __name(makeFvarInstance, "makeFvarInstance");
      function parseFvarInstance(data, start, axes, names) {
        var inst = {};
        var p = new parse.Parser(data, start);
        inst.name = names[p.parseUShort()] || {};
        p.skip("uShort", 1);
        inst.coordinates = {};
        for (var i = 0; i < axes.length; ++i) {
          inst.coordinates[axes[i].tag] = p.parseFixed();
        }
        return inst;
      }
      __name(parseFvarInstance, "parseFvarInstance");
      function makeFvarTable(fvar2, names) {
        var result = new table.Table("fvar", [
          { name: "version", type: "ULONG", value: 65536 },
          { name: "offsetToData", type: "USHORT", value: 0 },
          { name: "countSizePairs", type: "USHORT", value: 2 },
          { name: "axisCount", type: "USHORT", value: fvar2.axes.length },
          { name: "axisSize", type: "USHORT", value: 20 },
          { name: "instanceCount", type: "USHORT", value: fvar2.instances.length },
          { name: "instanceSize", type: "USHORT", value: 4 + fvar2.axes.length * 4 }
        ]);
        result.offsetToData = result.sizeOf();
        for (var i = 0; i < fvar2.axes.length; i++) {
          result.fields.push({
            name: "axis " + i,
            type: "TABLE",
            value: makeFvarAxis(fvar2.axes[i], names)
          });
        }
        for (var j = 0; j < fvar2.instances.length; j++) {
          result.fields.push({
            name: "instance " + j,
            type: "TABLE",
            value: makeFvarInstance(fvar2.instances[j], fvar2.axes, names)
          });
        }
        return result;
      }
      __name(makeFvarTable, "makeFvarTable");
      function parseFvarTable(data, start, names) {
        var p = new parse.Parser(data, start);
        var tableVersion = p.parseULong();
        check.argument(tableVersion === 65536, "Unsupported fvar table version.");
        var offsetToData = p.parseOffset16();
        p.skip("uShort", 1);
        var axisCount = p.parseUShort();
        var axisSize = p.parseUShort();
        var instanceCount = p.parseUShort();
        var instanceSize = p.parseUShort();
        var axes = [];
        for (var i = 0; i < axisCount; i++) {
          axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));
        }
        var instances = [];
        var instanceStart = start + offsetToData + axisCount * axisSize;
        for (var j = 0; j < instanceCount; j++) {
          instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));
        }
        return { axes, instances };
      }
      __name(parseFvarTable, "parseFvarTable");
      var make$1 = makeFvarTable;
      var parse_1$4 = parseFvarTable;
      var fvar = {
        make: make$1,
        parse: parse_1$4
      };
      function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
        var v;
        if ((flag & shortVectorBitMask) > 0) {
          v = p.parseByte();
          if ((flag & sameBitMask) === 0) {
            v = -v;
          }
          v = previousValue + v;
        } else {
          if ((flag & sameBitMask) > 0) {
            v = previousValue;
          } else {
            v = previousValue + p.parseShort();
          }
        }
        return v;
      }
      __name(parseGlyphCoordinate, "parseGlyphCoordinate");
      function parseGlyph(glyph2, data, start) {
        var p = new parse.Parser(data, start);
        glyph2.numberOfContours = p.parseShort();
        glyph2.xMin = p.parseShort();
        glyph2.yMin = p.parseShort();
        glyph2.xMax = p.parseShort();
        glyph2.yMax = p.parseShort();
        var flags;
        var flag;
        if (glyph2.numberOfContours > 0) {
          var i;
          var endPointIndices = glyph2.endPointIndices = [];
          for (i = 0; i < glyph2.numberOfContours; i += 1) {
            endPointIndices.push(p.parseUShort());
          }
          glyph2.instructionLength = p.parseUShort();
          glyph2.instructions = [];
          for (i = 0; i < glyph2.instructionLength; i += 1) {
            glyph2.instructions.push(p.parseByte());
          }
          var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
          flags = [];
          for (i = 0; i < numberOfCoordinates; i += 1) {
            flag = p.parseByte();
            flags.push(flag);
            if ((flag & 8) > 0) {
              var repeatCount = p.parseByte();
              for (var j = 0; j < repeatCount; j += 1) {
                flags.push(flag);
                i += 1;
              }
            }
          }
          check.argument(flags.length === numberOfCoordinates, "Bad flags.");
          if (endPointIndices.length > 0) {
            var points = [];
            var point;
            if (numberOfCoordinates > 0) {
              for (i = 0; i < numberOfCoordinates; i += 1) {
                flag = flags[i];
                point = {};
                point.onCurve = !!(flag & 1);
                point.lastPointOfContour = endPointIndices.indexOf(i) >= 0;
                points.push(point);
              }
              var px = 0;
              for (i = 0; i < numberOfCoordinates; i += 1) {
                flag = flags[i];
                point = points[i];
                point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
                px = point.x;
              }
              var py = 0;
              for (i = 0; i < numberOfCoordinates; i += 1) {
                flag = flags[i];
                point = points[i];
                point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
                py = point.y;
              }
            }
            glyph2.points = points;
          } else {
            glyph2.points = [];
          }
        } else if (glyph2.numberOfContours === 0) {
          glyph2.points = [];
        } else {
          glyph2.isComposite = true;
          glyph2.points = [];
          glyph2.components = [];
          var moreComponents = true;
          while (moreComponents) {
            flags = p.parseUShort();
            var component = {
              glyphIndex: p.parseUShort(),
              xScale: 1,
              scale01: 0,
              scale10: 0,
              yScale: 1,
              dx: 0,
              dy: 0
            };
            if ((flags & 1) > 0) {
              component.dx = p.parseShort();
              component.dy = p.parseShort();
            } else {
              component.dx = p.parseChar();
              component.dy = p.parseChar();
            }
            if ((flags & 8) > 0) {
              component.xScale = component.yScale = p.parseF2Dot14();
            } else if ((flags & 64) > 0) {
              component.xScale = p.parseF2Dot14();
              component.yScale = p.parseF2Dot14();
            } else if ((flags & 128) > 0) {
              component.xScale = p.parseF2Dot14();
              component.scale01 = p.parseF2Dot14();
              component.scale10 = p.parseF2Dot14();
              component.yScale = p.parseF2Dot14();
            }
            glyph2.components.push(component);
            moreComponents = !!(flags & 32);
          }
        }
      }
      __name(parseGlyph, "parseGlyph");
      function transformPoints(points, transform) {
        var newPoints = [];
        for (var i = 0; i < points.length; i += 1) {
          var pt = points[i];
          var newPt = {
            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
            onCurve: pt.onCurve,
            lastPointOfContour: pt.lastPointOfContour
          };
          newPoints.push(newPt);
        }
        return newPoints;
      }
      __name(transformPoints, "transformPoints");
      function getContours(points) {
        var contours = [];
        var currentContour = [];
        for (var i = 0; i < points.length; i += 1) {
          var pt = points[i];
          currentContour.push(pt);
          if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
          }
        }
        check.argument(currentContour.length === 0, "There are still points left in the current contour.");
        return contours;
      }
      __name(getContours, "getContours");
      function getPath(points) {
        var p = new path.Path();
        if (!points) {
          return p;
        }
        var contours = getContours(points);
        for (var i = 0; i < contours.length; i += 1) {
          var contour = contours[i];
          var firstPt = contour[0];
          var lastPt = contour[contour.length - 1];
          var curvePt;
          var realFirstPoint;
          if (firstPt.onCurve) {
            curvePt = null;
            realFirstPoint = true;
          } else {
            if (lastPt.onCurve) {
              firstPt = lastPt;
            } else {
              firstPt = { x: (firstPt.x + lastPt.x) / 2, y: (firstPt.y + lastPt.y) / 2 };
            }
            curvePt = firstPt;
            realFirstPoint = false;
          }
          p.moveTo(firstPt.x, firstPt.y);
          for (var j = realFirstPoint ? 1 : 0; j < contour.length; j += 1) {
            var pt = contour[j];
            var prevPt = j === 0 ? firstPt : contour[j - 1];
            if (prevPt.onCurve && pt.onCurve) {
              p.lineTo(pt.x, pt.y);
            } else if (prevPt.onCurve && !pt.onCurve) {
              curvePt = pt;
            } else if (!prevPt.onCurve && !pt.onCurve) {
              var midPt = { x: (prevPt.x + pt.x) / 2, y: (prevPt.y + pt.y) / 2 };
              p.quadraticCurveTo(prevPt.x, prevPt.y, midPt.x, midPt.y);
              curvePt = pt;
            } else if (!prevPt.onCurve && pt.onCurve) {
              p.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
              curvePt = null;
            } else {
              throw new Error("Invalid state.");
            }
          }
          if (firstPt !== lastPt) {
            if (curvePt) {
              p.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
            } else {
              p.lineTo(firstPt.x, firstPt.y);
            }
          }
        }
        p.closePath();
        return p;
      }
      __name(getPath, "getPath");
      function buildPath(glyphs, glyph2) {
        if (glyph2.isComposite) {
          for (var j = 0; j < glyph2.components.length; j += 1) {
            var component = glyph2.components[j];
            var componentGlyph = glyphs.get(component.glyphIndex);
            componentGlyph.getPath();
            if (componentGlyph.points) {
              var transformedPoints = transformPoints(componentGlyph.points, component);
              glyph2.points = glyph2.points.concat(transformedPoints);
            }
          }
        }
        return getPath(glyph2.points);
      }
      __name(buildPath, "buildPath");
      function parseGlyfTable(data, start, loca2, font2) {
        var glyphs = new glyphset.GlyphSet(font2);
        var i;
        for (i = 0; i < loca2.length - 1; i += 1) {
          var offset = loca2[i];
          var nextOffset = loca2[i + 1];
          if (offset !== nextOffset) {
            glyphs.push(i, glyphset.ttfGlyphLoader(font2, i, parseGlyph, data, start + offset, buildPath));
          } else {
            glyphs.push(i, glyphset.glyphLoader(font2, i));
          }
        }
        return glyphs;
      }
      __name(parseGlyfTable, "parseGlyfTable");
      var parse_1$3 = parseGlyfTable;
      var glyf = {
        parse: parse_1$3
      };
      function parseTaggedListTable(data, start) {
        var p = new parse.Parser(data, start);
        var n = p.parseUShort();
        var list = [];
        for (var i = 0; i < n; i++) {
          list[p.parseTag()] = { offset: p.parseUShort() };
        }
        return list;
      }
      __name(parseTaggedListTable, "parseTaggedListTable");
      function parseCoverageTable(data, start) {
        var p = new parse.Parser(data, start);
        var format = p.parseUShort();
        var count = p.parseUShort();
        if (format === 1) {
          return p.parseUShortList(count);
        } else if (format === 2) {
          var coverage = [];
          for (; count--; ) {
            var begin = p.parseUShort();
            var end = p.parseUShort();
            var index = p.parseUShort();
            for (var i = begin; i <= end; i++) {
              coverage[index++] = i;
            }
          }
          return coverage;
        }
      }
      __name(parseCoverageTable, "parseCoverageTable");
      function parseClassDefTable(data, start) {
        var p = new parse.Parser(data, start);
        var format = p.parseUShort();
        if (format === 1) {
          var startGlyph = p.parseUShort();
          var glyphCount = p.parseUShort();
          var classes = p.parseUShortList(glyphCount);
          return function(glyphID) {
            return classes[glyphID - startGlyph] || 0;
          };
        } else if (format === 2) {
          var rangeCount = p.parseUShort();
          var startGlyphs = [];
          var endGlyphs = [];
          var classValues = [];
          for (var i = 0; i < rangeCount; i++) {
            startGlyphs[i] = p.parseUShort();
            endGlyphs[i] = p.parseUShort();
            classValues[i] = p.parseUShort();
          }
          return function(glyphID) {
            var l = 0;
            var r = startGlyphs.length - 1;
            while (l < r) {
              var c = l + r + 1 >> 1;
              if (glyphID < startGlyphs[c]) {
                r = c - 1;
              } else {
                l = c;
              }
            }
            if (startGlyphs[l] <= glyphID && glyphID <= endGlyphs[l]) {
              return classValues[l] || 0;
            }
            return 0;
          };
        }
      }
      __name(parseClassDefTable, "parseClassDefTable");
      function parsePairPosSubTable(data, start) {
        var p = new parse.Parser(data, start);
        var format = p.parseUShort();
        var coverageOffset = p.parseUShort();
        var coverage = parseCoverageTable(data, start + coverageOffset);
        var valueFormat1 = p.parseUShort();
        var valueFormat2 = p.parseUShort();
        var value1;
        if (valueFormat1 !== 4 || valueFormat2 !== 0)
          return;
        var sharedPairSets = {};
        if (format === 1) {
          var pairSetCount = p.parseUShort();
          var pairSet = [];
          var pairSetOffsets = p.parseOffset16List(pairSetCount);
          for (var firstGlyph = 0; firstGlyph < pairSetCount; firstGlyph++) {
            var pairSetOffset = pairSetOffsets[firstGlyph];
            var sharedPairSet = sharedPairSets[pairSetOffset];
            if (!sharedPairSet) {
              sharedPairSet = {};
              p.relativeOffset = pairSetOffset;
              var pairValueCount = p.parseUShort();
              for (; pairValueCount--; ) {
                var secondGlyph = p.parseUShort();
                if (valueFormat1)
                  value1 = p.parseShort();
                if (valueFormat2)
                  p.parseShort();
                sharedPairSet[secondGlyph] = value1;
              }
            }
            pairSet[coverage[firstGlyph]] = sharedPairSet;
          }
          return function(leftGlyph, rightGlyph) {
            var pairs = pairSet[leftGlyph];
            if (pairs)
              return pairs[rightGlyph];
          };
        } else if (format === 2) {
          var classDef1Offset = p.parseUShort();
          var classDef2Offset = p.parseUShort();
          var class1Count = p.parseUShort();
          var class2Count = p.parseUShort();
          var getClass1 = parseClassDefTable(data, start + classDef1Offset);
          var getClass2 = parseClassDefTable(data, start + classDef2Offset);
          var kerningMatrix = [];
          for (var i = 0; i < class1Count; i++) {
            var kerningRow = kerningMatrix[i] = [];
            for (var j = 0; j < class2Count; j++) {
              if (valueFormat1)
                value1 = p.parseShort();
              if (valueFormat2)
                p.parseShort();
              kerningRow[j] = value1;
            }
          }
          var covered = {};
          for (i = 0; i < coverage.length; i++)
            covered[coverage[i]] = 1;
          return function(leftGlyph, rightGlyph) {
            if (!covered[leftGlyph])
              return;
            var class1 = getClass1(leftGlyph);
            var class2 = getClass2(rightGlyph);
            var kerningRow2 = kerningMatrix[class1];
            if (kerningRow2) {
              return kerningRow2[class2];
            }
          };
        }
      }
      __name(parsePairPosSubTable, "parsePairPosSubTable");
      function parseLookupTable(data, start) {
        var p = new parse.Parser(data, start);
        var lookupType = p.parseUShort();
        var lookupFlag = p.parseUShort();
        var useMarkFilteringSet = lookupFlag & 16;
        var subTableCount = p.parseUShort();
        var subTableOffsets = p.parseOffset16List(subTableCount);
        var table2 = {
          lookupType,
          lookupFlag,
          markFilteringSet: useMarkFilteringSet ? p.parseUShort() : -1
        };
        if (lookupType === 2) {
          var subtables = [];
          for (var i = 0; i < subTableCount; i++) {
            subtables.push(parsePairPosSubTable(data, start + subTableOffsets[i]));
          }
          table2.getKerningValue = function(leftGlyph, rightGlyph) {
            for (var i2 = subtables.length; i2--; ) {
              var value = subtables[i2](leftGlyph, rightGlyph);
              if (value !== void 0)
                return value;
            }
            return 0;
          };
        }
        return table2;
      }
      __name(parseLookupTable, "parseLookupTable");
      function parseGposTable(data, start, font2) {
        var p = new parse.Parser(data, start);
        var tableVersion = p.parseFixed();
        check.argument(tableVersion === 1, "Unsupported GPOS table version.");
        parseTaggedListTable(data, start + p.parseUShort());
        parseTaggedListTable(data, start + p.parseUShort());
        var lookupListOffset = p.parseUShort();
        p.relativeOffset = lookupListOffset;
        var lookupCount = p.parseUShort();
        var lookupTableOffsets = p.parseOffset16List(lookupCount);
        var lookupListAbsoluteOffset = start + lookupListOffset;
        for (var i = 0; i < lookupCount; i++) {
          var table2 = parseLookupTable(data, lookupListAbsoluteOffset + lookupTableOffsets[i]);
          if (table2.lookupType === 2 && !font2.getGposKerningValue)
            font2.getGposKerningValue = table2.getKerningValue;
        }
      }
      __name(parseGposTable, "parseGposTable");
      var parse_1$2 = parseGposTable;
      var gpos = {
        parse: parse_1$2
      };
      function parseKernTable(data, start) {
        var pairs = {};
        var p = new parse.Parser(data, start);
        var tableVersion = p.parseUShort();
        check.argument(tableVersion === 0, "Unsupported kern table version.");
        p.skip("uShort", 1);
        var subTableVersion = p.parseUShort();
        check.argument(subTableVersion === 0, "Unsupported kern sub-table version.");
        p.skip("uShort", 2);
        var nPairs = p.parseUShort();
        p.skip("uShort", 3);
        for (var i = 0; i < nPairs; i += 1) {
          var leftIndex = p.parseUShort();
          var rightIndex = p.parseUShort();
          var value = p.parseShort();
          pairs[leftIndex + "," + rightIndex] = value;
        }
        return pairs;
      }
      __name(parseKernTable, "parseKernTable");
      var parse_1$1 = parseKernTable;
      var kern = {
        parse: parse_1$1
      };
      function parseLocaTable(data, start, numGlyphs, shortVersion) {
        var p = new parse.Parser(data, start);
        var parseFn = shortVersion ? p.parseUShort : p.parseULong;
        var glyphOffsets = [];
        for (var i = 0; i < numGlyphs + 1; i += 1) {
          var glyphOffset = parseFn.call(p);
          if (shortVersion) {
            glyphOffset *= 2;
          }
          glyphOffsets.push(glyphOffset);
        }
        return glyphOffsets;
      }
      __name(parseLocaTable, "parseLocaTable");
      var parse_1 = parseLocaTable;
      var loca = {
        parse: parse_1
      };
      function toArrayBuffer(buffer) {
        var arrayBuffer = new ArrayBuffer(buffer.length);
        var data = new Uint8Array(arrayBuffer);
        for (var i = 0; i < buffer.length; i += 1) {
          data[i] = buffer[i];
        }
        return arrayBuffer;
      }
      __name(toArrayBuffer, "toArrayBuffer");
      function loadFromFile(path2, callback) {
        var fs = require$$0__default["default"];
        fs.readFile(path2, function(err, buffer) {
          if (err) {
            return callback(err.message);
          }
          callback(null, toArrayBuffer(buffer));
        });
      }
      __name(loadFromFile, "loadFromFile");
      function loadFromUrl(url, callback) {
        var request = new XMLHttpRequest();
        request.open("get", url, true);
        request.responseType = "arraybuffer";
        request.onload = function() {
          if (request.status !== 200) {
            return callback("Font could not be loaded: " + request.statusText);
          }
          return callback(null, request.response);
        };
        request.send();
      }
      __name(loadFromUrl, "loadFromUrl");
      function parseBuffer(buffer) {
        var indexToLocFormat;
        var ltagTable;
        var cffOffset;
        var fvarOffset;
        var glyfOffset;
        var gposOffset;
        var hmtxOffset;
        var kernOffset;
        var locaOffset;
        var nameOffset;
        var font$1 = new font.Font();
        var data = new DataView(buffer, 0);
        var version = parse.getFixed(data, 0);
        if (version === 1) {
          font$1.outlinesFormat = "truetype";
        } else {
          version = parse.getTag(data, 0);
          if (version === "OTTO") {
            font$1.outlinesFormat = "cff";
          } else {
            throw new Error("Unsupported OpenType version " + version);
          }
        }
        var numTables = parse.getUShort(data, 4);
        var p = 12;
        for (var i = 0; i < numTables; i += 1) {
          var tag = parse.getTag(data, p);
          var offset = parse.getULong(data, p + 8);
          switch (tag) {
            case "cmap":
              font$1.tables.cmap = cmap.parse(data, offset);
              font$1.encoding = new encoding.CmapEncoding(font$1.tables.cmap);
              break;
            case "fvar":
              fvarOffset = offset;
              break;
            case "head":
              font$1.tables.head = head.parse(data, offset);
              font$1.unitsPerEm = font$1.tables.head.unitsPerEm;
              indexToLocFormat = font$1.tables.head.indexToLocFormat;
              break;
            case "hhea":
              font$1.tables.hhea = hhea.parse(data, offset);
              font$1.ascender = font$1.tables.hhea.ascender;
              font$1.descender = font$1.tables.hhea.descender;
              font$1.numberOfHMetrics = font$1.tables.hhea.numberOfHMetrics;
              break;
            case "hmtx":
              hmtxOffset = offset;
              break;
            case "ltag":
              ltagTable = ltag.parse(data, offset);
              break;
            case "maxp":
              font$1.tables.maxp = maxp.parse(data, offset);
              font$1.numGlyphs = font$1.tables.maxp.numGlyphs;
              break;
            case "name":
              nameOffset = offset;
              break;
            case "OS/2":
              font$1.tables.os2 = os2.parse(data, offset);
              break;
            case "post":
              font$1.tables.post = post.parse(data, offset);
              font$1.glyphNames = new encoding.GlyphNames(font$1.tables.post);
              break;
            case "glyf":
              glyfOffset = offset;
              break;
            case "loca":
              locaOffset = offset;
              break;
            case "CFF ":
              cffOffset = offset;
              break;
            case "kern":
              kernOffset = offset;
              break;
            case "GPOS":
              gposOffset = offset;
              break;
          }
          p += 16;
        }
        font$1.tables.name = name.parse(data, nameOffset, ltagTable);
        font$1.names = font$1.tables.name;
        if (glyfOffset && locaOffset) {
          var shortVersion = indexToLocFormat === 0;
          var locaTable = loca.parse(data, locaOffset, font$1.numGlyphs, shortVersion);
          font$1.glyphs = glyf.parse(data, glyfOffset, locaTable, font$1);
        } else if (cffOffset) {
          cff.parse(data, cffOffset, font$1);
        } else {
          throw new Error("Font doesn't contain TrueType or CFF outlines.");
        }
        hmtx.parse(data, hmtxOffset, font$1.numberOfHMetrics, font$1.numGlyphs, font$1.glyphs);
        encoding.addGlyphNames(font$1);
        if (kernOffset) {
          font$1.kerningPairs = kern.parse(data, kernOffset);
        } else {
          font$1.kerningPairs = {};
        }
        if (gposOffset) {
          gpos.parse(data, gposOffset, font$1);
        }
        if (fvarOffset) {
          font$1.tables.fvar = fvar.parse(data, fvarOffset, font$1.names);
        }
        return font$1;
      }
      __name(parseBuffer, "parseBuffer");
      function load(url, callback) {
        var isNode = typeof window === "undefined";
        var loadFn = isNode ? loadFromFile : loadFromUrl;
        loadFn(url, function(err, arrayBuffer) {
          if (err) {
            return callback(err);
          }
          var font2 = parseBuffer(arrayBuffer);
          return callback(null, font2);
        });
      }
      __name(load, "load");
      function loadSync(url) {
        var fs = require$$0__default["default"];
        var buffer = fs.readFileSync(url);
        return parseBuffer(toArrayBuffer(buffer));
      }
      __name(loadSync, "loadSync");
      var load_1 = load;
      var loadSync_1 = loadSync;
      const _fonts = {};
      function registerFont2(binaryPath, family, weight, style, variant) {
        _fonts[family] = {
          binary: binaryPath,
          family,
          weight,
          style,
          variant,
          loaded: false,
          font: null,
          load: function(cb) {
            if (this.loaded) {
              if (cb)
                cb();
              return;
            }
            const self2 = this;
            load_1(binaryPath, function(err, font2) {
              if (err)
                throw new Error("Could not load font: " + err);
              self2.loaded = true;
              self2.font = font2;
              if (cb)
                cb();
            });
          },
          loadSync: function() {
            if (this.loaded) {
              return;
            }
            try {
              this.font = loadSync_1(binaryPath);
              this.loaded = true;
              return this;
            } catch (err) {
              throw new Error("Could not load font: " + err);
            }
          },
          loadPromise: function() {
            return new Promise((res, rej) => {
              this.load(() => res());
            });
          }
        };
        return _fonts[family];
      }
      __name(registerFont2, "registerFont");
      const debug_list_of_fonts = _fonts;
      function findFont(family) {
        if (_fonts[family])
          return _fonts[family];
        family = Object.keys(_fonts)[0];
        return _fonts[family];
      }
      __name(findFont, "findFont");
      function processTextPath(ctx, text, x, y, fill, hAlign, vAlign) {
        let font2 = findFont(ctx._font.family);
        if (!font2) {
          console.warn("Font missing", ctx._font);
        }
        const metrics = measureText(ctx, text);
        if (hAlign === "end" || hAlign === "right")
          x = x - metrics.width;
        if (hAlign === "center")
          x = x - metrics.width / 2;
        if (vAlign === "top")
          y = y + metrics.emHeightAscent;
        if (vAlign === "middle")
          y = y + metrics.emHeightAscent / 2 + metrics.emHeightDescent / 2;
        if (vAlign === "bottom")
          y = y + metrics.emHeightDescent;
        const size = ctx._font.size;
        font2.load(function() {
          const path2 = font2.font.getPath(text, x, y, size);
          ctx.beginPath();
          path2.commands.forEach(function(cmd) {
            switch (cmd.type) {
              case "M":
                ctx.moveTo(cmd.x, cmd.y);
                break;
              case "Q":
                ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
                break;
              case "L":
                ctx.lineTo(cmd.x, cmd.y);
                break;
              case "C":
                ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                break;
              case "Z": {
                ctx.closePath();
                fill ? ctx.fill() : ctx.stroke();
                ctx.beginPath();
                break;
              }
            }
          });
        });
      }
      __name(processTextPath, "processTextPath");
      function measureText(ctx, text) {
        let font2 = findFont(ctx._font.family);
        if (!font2)
          console.warn("WARNING. Can't find font family ", ctx._font);
        if (!font2.font)
          console.warn("WARNING. Can't find font family ", ctx._font);
        const fsize = ctx._font.size;
        const glyphs = font2.font.stringToGlyphs(text);
        let advance = 0;
        glyphs.forEach(function(g) {
          advance += g.advanceWidth;
        });
        return {
          width: advance / font2.font.unitsPerEm * fsize,
          emHeightAscent: font2.font.ascender / font2.font.unitsPerEm * fsize,
          emHeightDescent: font2.font.descender / font2.font.unitsPerEm * fsize
        };
      }
      __name(measureText, "measureText");
      const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
      function Transform(context) {
        this.context = context;
        this.matrix = [1, 0, 0, 1, 0, 0];
        this.stack = [];
        this.setContext = function(context2) {
          this.context = context2;
        };
        this.getMatrix = function() {
          return this.matrix;
        };
        this.setMatrix = function(m) {
          this.matrix = [m[0], m[1], m[2], m[3], m[4], m[5]];
          this.setTransform();
        };
        this.cloneMatrix = function(m) {
          return [m[0], m[1], m[2], m[3], m[4], m[5]];
        };
        this.cloneTransform = function() {
          let trans = new Transform();
          trans.setMatrix(this.getMatrix());
          return trans;
        };
        this.asDomMatrix = function() {
          return {
            is2D: true,
            isIdentity: false,
            a: this.matrix[0],
            b: this.matrix[1],
            c: this.matrix[2],
            d: this.matrix[3],
            e: this.matrix[4]
          };
        };
        this.fromDomMatrix = function(dom) {
          return [dom.a, dom.b, dom.c, dom.d, dom.e, dom.f];
        };
        this.save = function() {
          let matrix = this.cloneMatrix(this.getMatrix());
          this.stack.push(matrix);
          if (this.context)
            this.context.save();
        };
        this.restore = function() {
          if (this.stack.length > 0) {
            let matrix = this.stack.pop();
            this.setMatrix(matrix);
          }
          if (this.context)
            this.context.restore();
        };
        this.setTransform = function() {
          if (this.context) {
            this.context.setTransform(
              this.matrix[0],
              this.matrix[1],
              this.matrix[2],
              this.matrix[3],
              this.matrix[4],
              this.matrix[5]
            );
          }
        };
        this.translate = function(x, y) {
          this.matrix[4] += this.matrix[0] * x + this.matrix[2] * y;
          this.matrix[5] += this.matrix[1] * x + this.matrix[3] * y;
          this.setTransform();
        };
        this.rotate = function(rad) {
          const c = Math.cos(rad);
          const s = Math.sin(rad);
          const m11 = this.matrix[0] * c + this.matrix[2] * s;
          const m12 = this.matrix[1] * c + this.matrix[3] * s;
          const m21 = this.matrix[0] * -s + this.matrix[2] * c;
          const m22 = this.matrix[1] * -s + this.matrix[3] * c;
          this.matrix[0] = m11;
          this.matrix[1] = m12;
          this.matrix[2] = m21;
          this.matrix[3] = m22;
          this.setTransform();
        };
        this.scale = function(sx, sy) {
          this.matrix[0] *= sx;
          this.matrix[1] *= sx;
          this.matrix[2] *= sy;
          this.matrix[3] *= sy;
          this.setTransform();
        };
        this.rotateDegrees = function(deg) {
          const rad = deg * Math.PI / 180;
          this.rotate(rad);
        };
        this.rotateAbout = function(rad, x, y) {
          this.translate(x, y);
          this.rotate(rad);
          this.translate(-x, -y);
          this.setTransform();
        };
        this.rotateDegreesAbout = function(deg, x, y) {
          this.translate(x, y);
          this.rotateDegrees(deg);
          this.translate(-x, -y);
          this.setTransform();
        };
        this.identity = function() {
          this.m = IDENTITY_MATRIX;
          this.setTransform();
        };
        this.isIdentity = function() {
          for (let i = 0; i < this.matrix.length; i++) {
            if (this.matrix[i] !== IDENTITY_MATRIX[i])
              return false;
          }
          return true;
        };
        this.multiply = function(matrix) {
          const m11 = this.matrix[0] * matrix[0] + this.matrix[2] * matrix[1];
          const m12 = this.matrix[1] * matrix[0] + this.matrix[3] * matrix[1];
          const m21 = this.matrix[0] * matrix[2] + this.matrix[2] * matrix[3];
          const m22 = this.matrix[1] * matrix[2] + this.matrix[3] * matrix[3];
          const dx = this.matrix[0] * matrix[4] + this.matrix[2] * matrix[5] + this.matrix[4];
          const dy = this.matrix[1] * matrix[4] + this.matrix[3] * matrix[5] + this.matrix[5];
          this.matrix[0] = m11;
          this.matrix[1] = m12;
          this.matrix[2] = m21;
          this.matrix[3] = m22;
          this.matrix[4] = dx;
          this.matrix[5] = dy;
          this.setTransform();
        };
        this.invert = function() {
          const d = 1 / (this.matrix[0] * this.matrix[3] - this.matrix[1] * this.matrix[2]);
          const m0 = this.matrix[3] * d;
          const m1 = -this.matrix[1] * d;
          const m2 = -this.matrix[2] * d;
          const m3 = this.matrix[0] * d;
          const m4 = d * (this.matrix[2] * this.matrix[5] - this.matrix[3] * this.matrix[4]);
          const m5 = d * (this.matrix[1] * this.matrix[4] - this.matrix[0] * this.matrix[5]);
          this.matrix[0] = m0;
          this.matrix[1] = m1;
          this.matrix[2] = m2;
          this.matrix[3] = m3;
          this.matrix[4] = m4;
          this.matrix[5] = m5;
          this.setTransform();
        };
        this.transformPoint = function(pt) {
          const x = pt.x;
          const y = pt.y;
          return new Point(
            x * this.matrix[0] + y * this.matrix[2] + this.matrix[4],
            x * this.matrix[1] + y * this.matrix[3] + this.matrix[5]
          );
        };
      }
      __name(Transform, "Transform");
      const fromBytesBigEndian = /* @__PURE__ */ __name(function(highByte, secondHighByte, thirdHighByte, lowByte) {
        return (highByte << 24 | secondHighByte << 16 | thirdHighByte << 8 | lowByte) >>> 0;
      }, "fromBytesBigEndian");
      const getByteBigEndian = /* @__PURE__ */ __name(function(uint32value, byteNo) {
        return uint32value >>> 8 * (3 - byteNo) & 255;
      }, "getByteBigEndian");
      const getBytesBigEndian = /* @__PURE__ */ __name(function(uint32value) {
        return [
          getByteBigEndian(uint32value, 0),
          getByteBigEndian(uint32value, 1),
          getByteBigEndian(uint32value, 2),
          getByteBigEndian(uint32value, 3)
        ];
      }, "getBytesBigEndian");
      const toUint32 = /* @__PURE__ */ __name(function(number) {
        return number >>> 0;
      }, "toUint32");
      const or = /* @__PURE__ */ __name(function(uint32val0, argv) {
        let result = uint32val0;
        for (let index = 1; index < arguments.length; index += 1) {
          result = result | arguments[index];
        }
        return result >>> 0;
      }, "or");
      const and = /* @__PURE__ */ __name(function(uint32val0, argv) {
        let result = uint32val0;
        for (let index = 1; index < arguments.length; index += 1) {
          result = result & arguments[index];
        }
        return result >>> 0;
      }, "and");
      const shiftLeft = /* @__PURE__ */ __name(function(uint32val, numBits) {
        return uint32val << numBits >>> 0;
      }, "shiftLeft");
      function clamp(value, min, max) {
        if (value < min)
          return min;
        if (value > max)
          return max;
        return value;
      }
      __name(clamp, "clamp");
      const lerp = /* @__PURE__ */ __name(function(a, b, t) {
        return a + (b - a) * t;
      }, "lerp");
      function colorStringToUint32(str) {
        if (!str)
          return 0;
        if (str.indexOf("#") === 0) {
          if (str.length === 4) {
            let redNibble = parseInt(str[1], 16);
            let red = redNibble << 4 | redNibble;
            let greenNibble = parseInt(str[2], 16);
            let green = greenNibble << 4 | greenNibble;
            let blueNibble = parseInt(str[3], 16);
            let blue = blueNibble << 4 | blueNibble;
            let int = toUint32(red << 16 | green << 8 | blue);
            int = shiftLeft(int, 8);
            return or(int, 255);
          } else if (str.length === 5) {
            let redNibble = parseInt(str[1], 16);
            let red = redNibble << 4 | redNibble;
            let greenNibble = parseInt(str[2], 16);
            let green = greenNibble << 4 | greenNibble;
            let blueNibble = parseInt(str[3], 16);
            let blue = blueNibble << 4 | blueNibble;
            let alphaNibble = parseInt(str[4], 16);
            let alpha = alphaNibble << 4 | alphaNibble;
            let int = toUint32(red << 16 | green << 8 | blue);
            int = shiftLeft(int, 8);
            return or(int, alpha);
          } else if (str.length === 7) {
            let int = toUint32(parseInt(str.substring(1), 16));
            int = shiftLeft(int, 8);
            return or(int, 255);
          } else if (str.length === 9) {
            return toUint32(parseInt(str.substring(1), 16));
          }
        }
        if (str.indexOf("rgba") === 0) {
          const parts = str.trim().substring(4).replace("(", "").replace(")", "").split(",");
          return fromBytesBigEndian(
            parseInt(parts[0]),
            parseInt(parts[1]),
            parseInt(parts[2]),
            Math.floor(parseFloat(parts[3]) * 255)
          );
        }
        if (str.indexOf("rgb") === 0) {
          const parts = str.trim().substring(3).replace("(", "").replace(")", "").split(",");
          return fromBytesBigEndian(parseInt(parts[0]), parseInt(parts[1]), parseInt(parts[2]), 255);
        }
        if (NAMED_COLORS.hasOwnProperty(str)) {
          return NAMED_COLORS[str];
        }
        throw new Error("unknown style format: " + str);
      }
      __name(colorStringToUint32, "colorStringToUint32");
      class CanvasGradient {
        constructor() {
          this.stops = [];
        }
        addColorStop(t, colorstring) {
          const color = colorStringToUint32(colorstring);
          this.stops.push({ t, color });
        }
        _lerpStops(t) {
          const first = getBytesBigEndian(this.stops[0].color).map((b) => b / 255);
          const second = getBytesBigEndian(this.stops[1].color).map((b) => b / 255);
          const fc = first.map((f, i) => lerp(f, second[i], t)).map((c) => c * 255);
          return fromBytesBigEndian(fc[0], fc[1], fc[2], 255);
        }
      }
      __name(CanvasGradient, "CanvasGradient");
      class LinearGradient extends CanvasGradient {
        constructor(x0, y0, x1, y1) {
          super();
          this.start = new Point(x0, y0);
          this.end = new Point(x1, y1);
        }
        colorAt(x, y) {
          const pc = new Point(x, y);
          let V = this.end.subtract(this.start);
          const d = V.magnitude();
          V = V.divide(d);
          const V0 = pc.subtract(this.start);
          let t = V0.dotProduct(V);
          t = clamp(t / d, 0, 1);
          return this._lerpStops(t);
        }
      }
      __name(LinearGradient, "LinearGradient");
      class RadialGradient extends CanvasGradient {
        constructor(x0, y0, x1, y1) {
          super();
          this.start = new Point(x0, y0);
        }
        colorAt(x, y) {
          const pc = new Point(x, y);
          const dist = pc.distance(this.start);
          let t = clamp(dist / 10, 0, 1);
          return this._lerpStops(t);
        }
      }
      __name(RadialGradient, "RadialGradient");
      const PATH_COMMAND = {
        MOVE: "m",
        LINE: "l",
        QUADRATIC_CURVE: "q",
        BEZIER_CURVE: "b"
      };
      class Context {
        /**
         * Creates a new pure image Context
         *
         * @param {Bitmap} bitmap An instance of the {@link Bitmap} class
         * @memberof Context
         */
        constructor(bitmap) {
          this.bitmap = bitmap;
          this._fillColor = NAMED_COLORS.black;
          this._strokeColor = NAMED_COLORS.black;
          this._lineWidth = 1;
          this._globalAlpha = 1;
          this._transform = new Transform();
          this._font = {
            family: "invalid",
            size: 12
          };
          this.textAlign = "start";
          this.textBaseline = "alphabetic";
          this.imageSmoothingEnabled = true;
          this._clip = null;
          this._fillStyle_text = "";
          this._strokeStyle_text = "";
          this.states = [];
        }
        /**
         * The color or style to use inside shapes. The default is #000 (black).
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle
         * @type {string}
         */
        get fillStyle() {
          return this._fillStyle_text;
        }
        /**
         * @param {string} val
         * @example ctx.fillStyle = 'rgba(0, 25, 234, 0.6)';
         */
        set fillStyle(val) {
          if (val instanceof CanvasGradient) {
            this._fillColor = val;
          } else {
            this._fillColor = colorStringToUint32(val);
            this._fillStyle_text = val;
          }
        }
        /**
         * The color or style to use for the lines around shapes. The default is #000 (black).
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle
         * @type {string}
         */
        get strokeStyle() {
          return this._strokeStyle_text;
        }
        /**
         * @param {string} val
         * @example ctx.strokeStyle = 'rgba(0, 25, 234, 0.6)';
         */
        set strokeStyle(val) {
          if (val instanceof CanvasGradient) {
            this._strokeStyle_text = val;
          } else {
            this._strokeColor = colorStringToUint32(val);
            this._strokeStyle_text = val;
          }
        }
        /**
         * The thickness of lines in space units. When getting, it returns the current value (1.0 by default). When setting, zero, negative, `Infinity` and `NaN` values are ignored; otherwise the current value is set to the new value.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineWidth
         * @type {number}
         */
        get lineWidth() {
          return this._lineWidth;
        }
        /**
         * @param {string} val
         * @example ctx.lineWidth = 15;
         */
        set lineWidth(val) {
          this._lineWidth = val;
        }
        /**
         * The alpha value that is applied to shapes and images before they are drawn onto the canvas. The value is in the range from 0.0 (fully transparent) to 1.0 (fully opaque).
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalAlpha
         * @type {Boolean}
         */
        get globalAlpha() {
          return this._globalAlpha;
        }
        /**
         * @param {boolean} val
         * @example ctx.globalAlpha = 1;
         */
        set globalAlpha(val) {
          this._globalAlpha = clamp(val, 0, 1);
        }
        /**
         * The current text style being used when drawing text. This string uses the same syntax as the CSS font specifier
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font
         * @type {string} a string representing the font size and family to use
         */
        get font() {
        }
        /**
         * @param {string} font to use. Note that the font weight is not supported.
         * @example ctx.font = '16px serif'
         */
        set font(val) {
          const n = val.trim().indexOf(" ");
          this._font.size = parseInt(val.slice(0, n));
          this._font.family = val.slice(n).trim();
        }
        createLinearGradient(x0, y0, x1, y1) {
          return new LinearGradient(x0, y0, x1, y1);
        }
        createRadialGradient(x0, y0) {
          return new RadialGradient(x0, y0);
        }
        /**
         * Saves the entire state of the canvas by pushing the current state onto a stack
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/save
         *
         * @returns {void}
         *
         * @memberof Context
         */
        save() {
          this.states.push({
            _clip: this._clip
          });
          this._transform.save();
        }
        /**
         * Adds a translation transformation by moving the canvas and its origin `x` horizontally and `y` vertically on the grid
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/translate
         *
         * @param {number} x X position
         * @param {number} y Y position
         *
         * @returns {void}
         *
         * @memberof Context
         */
        translate(x, y) {
          this._transform.translate(x, y);
        }
        /**
         * Add a rotation to the transformation matrix. The angle argument represents a clockwise rotation angle and is expressed in adians
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/rotate
         *
         * @param {number} angle Degrees of rotation (in radians)
         *
         * @returns {void}
         *
         * @memberof Context
         */
        rotate(angle) {
          this._transform.rotate(angle);
        }
        /**
         * Adds a scaling transformation to the canvas units by `x` horizontally and by `y` vertically
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/rotate
         *
         * @param {number} sx Scale X amount
         * @param {number} sy Scale Y amount
         *
         * @returns {void}
         *
         * @memberof Context
         */
        scale(sx, sy) {
          this._transform.scale(sx, sy);
        }
        transform(...args) {
          let new_mat = [...args];
          this._transform.multiply(new_mat);
        }
        setTransform(...args) {
          this._transform.identity();
          if (args[0].is2D) {
            let new_mat = this._transform.fromDomMatrix(args[0]);
            this._transform.multiply(new_mat);
          } else {
            this._transform.multiply([...args]);
          }
        }
        getTransform() {
          return this._transform.asDomMatrix();
        }
        /**
         * Restores the most recently saved canvas state by popping the top entry in the drawing state stack. If there is no saved state, this method does nothing.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore
         *
         * @returns {void}
         *
         * @memberof Context
         */
        restore() {
          this._transform.restore();
          let state = this.states.pop();
          if (state) {
            this._clip = state._clip;
          }
        }
        /**
         * Draws a filled rectangle whose starting point is at the coordinates `(x, y)` with the specified width and height and whose style is determined by the fillStyle attribute.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillRect
         *
         * @param {number} x X position
         * @param {number} y Y position
         * @param {number} w Width
         * @param {number} h Height
         *
         * @returns {void}
         *
         * @memberof Context
         */
        fillRect(x, y, w, h) {
          if (this._transform.isIdentity()) {
            for (let i = x; i < x + w; i++) {
              for (let j = y; j < y + h; j++) {
                this.fillPixelWithColor(i, j, this.calculateRGBA(i, j));
              }
            }
          } else {
            let old_path = this.path;
            let old_closed = this._closed;
            this.beginPath();
            this.rect(x - 1e-4, y - 1e-4, w, h);
            this.closePath();
            this.fill();
            this.path = old_path;
            this._closed = old_closed;
          }
        }
        /**
         * Sets all pixels in the rectangle defined by starting point `(x, y)` and size `(width, height)` to transparent black, erasing any previously drawn content.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/clearRect
         *
         * @param {number} x X position
         * @param {number} y Y position
         * @param {number} w Width
         * @param {number} h Height
         *
         * @returns {void}
         *
         * @memberof Context
         */
        clearRect(x, y, w, h) {
          for (let i = x; i < x + w; i++) {
            for (let j = y; j < y + h; j++) {
              if (this.bitmap._isValidCoords(x, y))
                this.bitmap.setPixelRGBA(i, j, TRANSPARENT_BLACK);
            }
          }
        }
        /**
         * Paints a rectangle which has a starting point at `(x, y)` and has a `w` width and an `h` height onto the canvas, using the current stroke style.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeRect
         *
         * @param {number} x X position
         * @param {number} y Y position
         * @param {number} w Width
         * @param {number} h Height
         *
         * @returns {void}
         *
         * @memberof Context
         */
        strokeRect(x, y, w, h) {
          for (let i = x; i < x + w; i++) {
            this.fillPixelWithColor(i, y, this.calculateRGBA_stroke(i, y));
            this.fillPixelWithColor(i, y + h, this.calculateRGBA_stroke(i, y + h));
          }
          for (let j = y; j < y + h; j++) {
            this.bitmap.setPixelRGBA(x, j, this._strokeColor);
            this.bitmap.setPixelRGBA(x + w, j, this._strokeColor);
            this.fillPixelWithColor(x, j, this.calculateRGBA_stroke(x, j));
            this.fillPixelWithColor(x + w, j, this.calculateRGBA_stroke(x + w, j));
          }
        }
        /**
         * Set the background colour of a single pixel denoted by the `x` and `y` co-ordinates
         *
         * @param {number} x The x axis of the pixel
         * @param {number} y The y axis of the pixel
         *
         * @returns {void}
         *
         * @memberof Context
         */
        fillPixel(x, y) {
          if (!this.pixelInsideClip(x, y)) {
            return;
          }
          if (!this.bitmap._isValidCoords(x, y))
            return;
          const new_pixel = this.calculateRGBA(x, y);
          const old_pixel = this.bitmap.getPixelRGBA(x, y);
          const final_pixel = this.composite(x, y, old_pixel, new_pixel);
          this.bitmap.setPixelRGBA(x, y, final_pixel);
        }
        /**
         * Paints a pixel which has an x axis position of `x` and a y axis position of `y`
         *
         * @param {number} x The x axis of the pixel to stroke
         * @param {number} y The y axis of the pixel to stroke
         *
         * @returns {void}
         *
         * @memberof Context
         */
        strokePixel(x, y) {
          if (!this.pixelInsideClip(x, y)) {
            return;
          }
          const new_pixel = this.calculateRGBA_stroke(x, y);
          const old_pixel = this.bitmap.getPixelRGBA(x, y);
          const final_pixel = this.composite(x, y, old_pixel, new_pixel);
          this.bitmap.setPixelRGBA(x, y, final_pixel);
        }
        /**
         * Fill Pixel With Color
         *
         * @param {number} x   The x axis of the pixel to fill
         * @param {number} y   The y axis of the pixel to fill
         * @param {number} col
         *
         * @ignore
         *
         * @returns {void}
         *
         * @memberof Context
         */
        fillPixelWithColor(x, y, col) {
          if (!this.pixelInsideClip(x, y)) {
            return;
          }
          if (!this.bitmap._isValidCoords(x, y))
            return;
          const new_pixel = col;
          const old_pixel = this.bitmap.getPixelRGBA(x, y);
          const final_pixel = this.composite(x, y, old_pixel, new_pixel);
          this.bitmap.setPixelRGBA(x, y, final_pixel);
        }
        /**
         * Composite
         *
         * @param {number} i Unused
         * @param {number} j Unused
         * @param {number} old_pixel
         * @param {number} new_pixel
         *
         * @ignore
         *
         * @returns {void}
         *
         * @memberof Context
         */
        composite(i, j, old_pixel, new_pixel) {
          const old_rgba = getBytesBigEndian(old_pixel);
          const new_rgba = getBytesBigEndian(new_pixel);
          const A = new_rgba.map((b) => b / 255);
          const B = old_rgba.map((b) => b / 255);
          A[3] = A[3] * this._globalAlpha;
          function compit(ca, cb, aa, ab) {
            return (ca * aa + cb * ab * (1 - aa)) / (aa + ab * (1 - aa));
          }
          __name(compit, "compit");
          const C = A.slice(0, 3).map((comp, i2) => compit(A[i2], B[i2], A[3], B[3]));
          const Cf = C.map((c) => c * 255);
          return fromBytesBigEndian(
            Cf[0],
            Cf[1],
            Cf[2],
            // R, G, B,
            Math.max(old_rgba[3], new_rgba[3])
            // alpha
          );
        }
        /**
         * Calculate RGBA
         *
         * @param {number} x X position
         * @param {number} y Y position
         *
         * @ignore
         *
         * @returns {number}
         *
         * @memberof Context
         */
        calculateRGBA(x, y) {
          if (this._fillColor instanceof CanvasGradient) {
            return this._fillColor.colorAt(x, y);
          }
          return this._fillColor;
        }
        /**
         * Calculate RGBA Stroke
         *
         * @param {number} x X position
         * @param {number} y Y position
         *
         * @ignore
         *
         * @returns {number}
         *
         * @memberof Context
         */
        calculateRGBA_stroke(x, y) {
          return this._strokeColor;
        }
        /**
         * Get Image Data
         *
         * @param {number} x X position
         * @param {number} y Y position
         * @param {number} w Width
         * @param {number} h Height
         *
         * @ignore
         *
         * @returns {Bitmap}
         *
         * @memberof Context
         */
        getImageData(x, y, w, h) {
          return this.bitmap._copySubBitmap(x, y, w, h);
        }
        /**
         * *Put Image Data
         *
         * @param {Bitmap} imageData Image ID
         * @param {number} x  X position
         * @param {number} y  Y position
         *
         * @ignore
         *
         * @returns {void}
         *
         * @memberof Context
         */
        putImageData(imageData, x, y) {
          this.bitmap._pasteSubBitmap(imageData, x, y);
        }
        /**
         * Provides different ways to draw an image onto the canvas.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage
         *
         * @param {Bitmap} bitmap An instance of the {@link Bitmap} class to use for drawing
         * @param {number} sx     The X coordinate of the top left corner of the sub-rectangle of the source image to draw into the destination context.
         * @param {number} sy     The Y coordinate of the top left corner of the sub-rectangle of the source image to draw into the destination context.
         * @param {number} sw     The width of the sub-rectangle of the source {@link Bitmap} to draw into the destination context. If not specified, the entire rectangle from the coordinates specified by `sx` and `sy` to the bottom-right corner of the image is used.
         * @param {number} sh     The height of the sub-rectangle of the source {@link Bitmap} to draw into the destination context.
         * @param {number} dx     The X coordinate in the destination canvas at which to place the top-left corner of the source {@link Bitmap}
         * @param {number} dy     The Y coordinate in the destination canvas at which to place the top-left corner of the source {@link Bitmap}
         * @param {number} dw     The width to draw the {@link Bitmap} in the destination canvas. This allows scaling of the drawn image. If not specified, the image is not scaled in width when drawn
         * @param {number} dh     The height to draw the {@link Bitmap} in the destination canvas. This allows scaling of the drawn image. If not specified, the image is not scaled in height when drawn
         *
         * @returns {void}
         *
         * @memberof Context
         */
        drawImage(bitmap, sx, sy, sw, sh, dx, dy, dw, dh) {
          if (typeof sw === "undefined")
            return this.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, sx, sy, bitmap.width, bitmap.height);
          if (typeof dx === "undefined")
            return this.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, sx, sy, sw, sh);
          let src_bounds = new Bounds2(sx, sy, sx + sw, sy + sh);
          let pts = [
            new Point(dx, dy),
            new Point(dx + dw, dy),
            new Point(dx + dw, dy + dh),
            new Point(dx, dy + dh)
          ];
          pts = pts.map((pt) => this._transform.transformPoint(pt));
          let dst_bounds = calc_min_bounds(pts);
          let bitmap_bounds = new Bounds2(0, 0, this.bitmap.width, this.bitmap.height);
          dst_bounds = dst_bounds.intersect(bitmap_bounds);
          let inv = this._transform.cloneTransform();
          inv.invert();
          function remap(n, a1, a2, b1, b2) {
            let t = (n - a1) / (a2 - a1);
            return t * (b2 - b1) + b1;
          }
          __name(remap, "remap");
          for (let i = dst_bounds.x1; i < dst_bounds.x2; i++) {
            for (let j = dst_bounds.y1; j < dst_bounds.y2; j++) {
              let dst_pt = new Point(i, j);
              let src_pt = inv.transformPoint(dst_pt).round();
              src_pt = new Point(
                remap(src_pt.x, dx, dx + dw, sx, sx + sw),
                remap(src_pt.y, dy, dy + dh, sy, sy + sh)
              );
              if (src_bounds.contains(src_pt)) {
                const rgba = bitmap.getPixelRGBA(src_pt.x, src_pt.y);
                if (this.pixelInsideClip(dst_pt.x, dst_pt.y) && this.bitmap._isValidCoords(dst_pt.x, dst_pt.y)) {
                  this.bitmap.setPixelRGBA(dst_pt.x, dst_pt.y, rgba);
                }
              }
            }
          }
        }
        /**
         * Starts a new path by emptying the list of sub-paths. Call this method when you want to create a new path.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/beginPath
         *
         * @returns {void}
         *
         * @memberof Context
         */
        beginPath() {
          this.path = [];
          this._closed = false;
        }
        /**
         * Moves the starting point of a new sub-path to the (x, y) coordinates.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/moveTo
         *
         * @param {number} x The x axis of the point.
         * @param {number} y The y axis of the point.
         *
         * @returns {void}
         *
         * @memberof Context
        * */
        moveTo(x, y) {
          return this._moveTo(new Point(x, y));
        }
        /**
         * Moves the starting point of a new sub-path to the (x, y) coordinates.
         *
         * @param {Point} pt A `point` object representing a set of co-ordinates to move the "pen" to.
         *
         * @example
         * //All of the following are valid:
         * this._moveTo({x: 20, y: 40})
         * this._moveTo(new Point(20, 40))
         *
         * @returns {void}
         *
         * @memberof Context
        * */
        _moveTo(pt) {
          pt = this._transform.transformPoint(pt);
          this.pathstart = pt;
          this.path.push([PATH_COMMAND.MOVE, pt]);
        }
        /**
         * Connects the last point in the sub-path to the x, y coordinates with a straight line (but does not actually draw it).
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineTo
         *
         * @param {number} x The x axis of the coordinate for the end of the line.
         * @param {number} y The y axis of the coordinate for the end of the line.
         *
         * @returns {void}
         *
         * @memberof Context
         */
        lineTo(x, y) {
          return this._lineTo(new Point(x, y));
        }
        /**
         * Connects the last point in the sub-path to the x, y coordinates with a straight line (but does not actually draw it).
         *
         * @param {Point} pt A point object to draw a line to from the current set of co-ordinates
         *
         * @returns {void}
         *
         * @memberof Context
         */
        _lineTo(pt) {
          this.path.push([PATH_COMMAND.LINE, this._transform.transformPoint(pt)]);
        }
        /**
         * Adds a quadratic Bézier curve to the path. It requires two points. The first point is a control point and the second one is the end point. The starting point is the last point in the current path, which can be changed using moveTo() before creating the quadratic Bézier curve.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/quadraticCurveTo
         *
         * @param {number} cp1x The x axis of the coordinate for the control point.
         * @param {number} cp1y The y axis of the coordinate for the control point.
         * @param {number} x    The x axis of the coordinate for the end point.
         * @param {number} y    The y axis of the coordinate for the end point.
         *
         * @returns {void}
         *
         * @memberof Context
         */
        quadraticCurveTo(cp1x, cp1y, x, y) {
          let cp1 = this._transform.transformPoint(new Point(cp1x, cp1y));
          let pt = this._transform.transformPoint(new Point(x, y));
          this.path.push([PATH_COMMAND.QUADRATIC_CURVE, cp1, pt]);
        }
        /**
         * Adds a cubic Bézier curve to the path. It requires three points. The first two points are control points and the third one is the end point. The starting point is the last point in the current path, which can be changed using moveTo() before creating the Bézier curve.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/bezierCurveTo
         *
         * @param {number} cp1x The x axis of the coordinate for the first control point.
         * @param {number} cp1y The y axis of the coordinate for first control point.
         * @param {number} cp2x The x axis of the coordinate for the second control point.
         * @param {number} cp2y The y axis of the coordinate for the second control point.
         * @param {number} x    The x axis of the coordinate for the end point.
         * @param {number} y    The y axis of the coordinate for the end point.
         *
         * @returns {void}
         *
         * @memberof Context
         */
        bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
          this._bezierCurveTo(new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
        }
        /**
         * Bezier Curve To
         *
         * @param {number} cp1 Curve point 1
         * @param {number} cp2 Curve point 2
         * @param {Point}  pt
         *
         * @returns {void}
         *
         * @memberof Context
        * */
        _bezierCurveTo(cp1, cp2, pt) {
          cp1 = this._transform.transformPoint(cp1);
          cp2 = this._transform.transformPoint(cp2);
          pt = this._transform.transformPoint(pt);
          this.path.push([PATH_COMMAND.BEZIER_CURVE, cp1, cp2, pt]);
        }
        /**
         * Adds an arc to the path which is centered at (x, y) position with radius r starting at startAngle and ending at endAngle going in the given direction by anticlockwise (defaulting to clockwise).
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/arc
         *
         * @param {number}  x         The x coordinate of the arc's center
         * @param {number}  y         The y coordinate of the arc's center
         * @param {number}  rad       The arc's radius
         * @param {number}  start     The angle at which the arc starts, measured clockwise from the positive x axis and expressed in radians
         * @param {number}  end       The angle at which the arc ends, measured clockwise from the positive x axis and expressed in radians
         * @param {boolean} anticlockwise A boolean which, if true, causes the arc to be drawn anticlockwise between the two angles.
         *
         * @returns {void}
         *
         * @memberof Context
         */
        arc(x, y, rad, start, end, anticlockwise) {
          function calcPoint(angle) {
            let px = x + Math.cos(angle) * rad;
            let py = y + Math.sin(angle) * rad;
            return new Point(px, py);
          }
          __name(calcPoint, "calcPoint");
          if (start > end)
            end += Math.PI * 2;
          let step = Math.PI / 16;
          if (anticlockwise) {
            let temp = end;
            end = start + Math.PI * 2;
            start = temp;
          }
          this._moveTo(calcPoint(start));
          for (let a = start; a <= end; a += step) {
            this._lineTo(calcPoint(a));
          }
          this._lineTo(calcPoint(end));
        }
        /**
         * Arc To
         *
         * @ignore
         *
         * @throws {Error} Method is not yet implemented
         *
         * @memberof Context
         */
        arcTo() {
          throw new Error("arcTo not yet supported");
        }
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/rect
         * Draws a rectangle with the upper left corner at the specified (x, y)
         *
         * @returns {void}
         *
         * @memberof Context
         *
         *
         * @param {number}  x         The x coordinate of the rectangle
         * @param {number}  y         The y coordinate of the rectangle
         * @param {number}  width     The width of the rectangle
         * @param {number}  height    The height of the rectangle
         *
         *
         * @memberof Context
         */
        rect(x, y, width, height) {
          this.moveTo(x, y);
          this.lineTo(x + width, y);
          this.lineTo(x + width, y + height);
          this.lineTo(x, y + height);
          this.lineTo(x, y);
        }
        /**
         * Ellipse
         *
         * @ignore
         *
         * @throws {Error} Method is not yet implemented
         *
         * @memberof Context
         */
        ellipse() {
          throw new Error("ellipse not yet supported");
        }
        /**
         * Turns the path currently being built into the current clipping path.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/clip
         *
         * @returns {void}
         *
         * @memberof Context
         */
        clip() {
          this._clip = pathToLines(this.path);
        }
        /**
         * Measure Text
         *
         * @ignore
         *
         * @throws {Error} Method is not yet implemented
         *
         * @memberof Context
         */
        measureText(string) {
          return measureText(this, string);
        }
        /**
         * Causes the point of the pen to move back to the start of the current sub-path. It tries to add a straight line (but does not actually draw it) from the current point to the start. If the shape has already been closed or has only one point, this function does nothing.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/closePath
         *
         * @returns {void}
         *
         * @memberof Context
         */
        closePath() {
          if (!this._closed) {
            this.path.push([PATH_COMMAND.LINE, this.pathstart]);
            this._closed = true;
          }
        }
        /**
         * Strokes the current or given path with the current stroke style
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/stroke
         *
         * @returns {void}
         *
         * @memberof Context
         */
        stroke() {
          let flat_path = flatten_path(this.path);
          let stroke_path = path_to_stroked_path(flat_path, this.lineWidth / 2);
          const lines = pathToLines(stroke_path);
          const old_fillStyle = this.fillStyle;
          this.fillStyle = this.strokeStyle;
          this.imageSmoothingEnabled ? this.fill_aa(lines) : this.fill_noaa(lines);
          this.fillStyle = old_fillStyle;
          if (this.debug) {
            this.save();
            let old_ss = this.strokeStyle;
            let old_lw = this.lineWidth;
            this.strokeStyle = "red";
            this.lineWidth = 1;
            console.log("path is", this.path);
            pathToLines(this.path).forEach((line2) => this.drawLine(line2));
            console.log("flat path is", flat_path);
            pathToLines(flat_path).forEach((line2) => this.drawLine(line2));
            console.log("stroke path is", stroke_path);
            pathToLines(stroke_path).forEach((line2) => this.drawLine(line2));
            console.log("final lines are", lines);
            this.strokeStyle = old_ss;
            this.lineWidth = old_lw;
            this.restore();
          }
        }
        /**
         * Draw a line using the correct anti-aliased, or non-anti-aliased line drawing function based on the value of {@link imageSmoothingEnabled}
         *
         * @param {Line} line A set of co-ordinates representing the start and end of the line. You can also pass a plain js object if you wish
         * @example
         * //All of the following are valid:
         * ctx.drawLine({start: {x: 20, y:42}, end: {x: 20, y:90}})
         * ctx.drawLine(new Line(new Point(20, 42), new Point(20, 90)))
         * ctx.drawLine(new Line(20, 42, 20, 90))
         *
         * @returns {void}
         *
         * @memberof Context
         */
        drawLine(line2) {
          if (line2.is_invalid())
            return console.error("cannot draw line", line2);
          this.imageSmoothingEnabled ? this.drawLine_aa(line2) : this.drawLine_noaa(line2);
        }
        /**
         *
         * Draw a line without anti-aliasing using Bresenham's algorithm
         *
         * @param {Line} line A set of co-ordinates representing the start and end of the line. You can also pass a plain js object if you wish
         * @example
         * //All of the following are valid:
         * ctx.drawLine({start: {x: 20, y:42}, end: {x: 20, y:90}})
         * ctx.drawLine(new Line(new Point(20, 42), new Point(20, 90)))
         * ctx.drawLine(new Line(20, 42, 20, 90))
         *
         * @returns {void}
         *
         * @memberof Context
         */
        drawLine_noaa(line2) {
          let x0 = Math.floor(line2.start.x);
          let y0 = Math.floor(line2.start.y);
          const x1 = Math.floor(line2.end.x);
          const y1 = Math.floor(line2.end.y);
          const dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
          const dy = Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
          let err = (dx > dy ? dx : -dy) / 2;
          while (true) {
            this.strokePixel(x0, y0);
            if (x0 === x1 && y0 === y1)
              break;
            const e2 = err;
            if (e2 > -dx) {
              err -= dy;
              x0 += sx;
            }
            if (e2 < dy) {
              err += dx;
              y0 += sy;
            }
          }
        }
        /**
         * Draw Line Anti-aliased
         *
         * Draw anti-aliased line using Bresenham's algorithm
         *
         * @see http://members.chello.at/~easyfilter/bresenham.html
         *
         * @param {Line} line A set of co-ordinates representing the start and end of the line. You can also pass a plain js object if you wish
         * @example
         * //All of the following are valid:
         * ctx.drawLine({start: {x: 20, y:42}, end: {x: 20, y:90}})
         * ctx.drawLine(new Line(new Point(20, 42), new Point(20, 90)))
         * ctx.drawLine(new Line(20, 42, 20, 90))
         *
         * @memberof Context
         */
        drawLine_aa(line2) {
          let width = this._lineWidth;
          let x0 = Math.floor(line2.start.x);
          let y0 = Math.floor(line2.start.y);
          let x1 = Math.floor(line2.end.x);
          let y1 = Math.floor(line2.end.y);
          let dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
          let dy = Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
          let err = dx - dy, e2, x2, y2;
          let ed = dx + dy === 0 ? 1 : Math.sqrt(dx * dx + dy * dy);
          let rgb = and(this._strokeColor, 4294967040);
          let a1 = and(this._strokeColor, 255);
          for (width = (width + 1) / 2; ; ) {
            const alpha = ~~Math.max(0, 255 * (Math.abs(err - dx + dy) / ed - width + 1));
            const a2 = 255 - alpha;
            const color = or(rgb, a1 * a2 / 255);
            this.fillPixelWithColor(x0, y0, color);
            e2 = err;
            x2 = x0;
            if (2 * e2 >= -dx) {
              for (e2 += dy, y2 = y0; e2 < ed * width && (y1 !== y2 || dx > dy); e2 += dx) {
                const alpha2 = ~~Math.max(0, 255 * (Math.abs(e2) / ed - width + 1));
                const a22 = 255 - alpha2;
                const color2 = or(rgb, a1 * a22 / 255);
                this.fillPixelWithColor(x0, y2 += sy, color2);
              }
              if (x0 === x1)
                break;
              e2 = err;
              err -= dy;
              x0 += sx;
            }
            if (2 * e2 <= dy) {
              for (e2 = dx - e2; e2 < ed * width && (x1 !== x2 || dx < dy); e2 += dy) {
                const alpha2 = ~~Math.max(0, 255 * (Math.abs(e2) / ed - width + 1));
                const a22 = 255 - alpha2;
                const color2 = or(rgb, a1 * a22 / 255);
                this.fillPixelWithColor(x2 += sx, y0, color2);
              }
              if (y0 === y1)
                break;
              err += dx;
              y0 += sy;
            }
          }
        }
        /**
         * Fills the current or given path with the current fill style. Uses {@link fill_aa} and {@link fill_noaa} depending on the the value of {@link imageSmoothingEnabled}
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fill
         *
         * @returns {void}
         *
         * @memberof Context
         */
        fill() {
          if (!this._closed)
            this.closePath();
          const lines = pathToLines(this.path);
          this.imageSmoothingEnabled ? this.fill_aa(lines) : this.fill_noaa(lines);
        }
        /**
         * Fill Anti-aliased
         *
         * @returns {void}
         *
         * @memberof Context
         */
        fill_aa(lines) {
          const rgb = and(this._fillColor, 4294967040);
          const alpha = and(this._fillColor, 255);
          const bounds = calcMinimumBounds(lines);
          const startY = Math.min(bounds.y2 + 1, this.bitmap.height);
          const endY = Math.max(bounds.y - 1, 0);
          for (let j = startY; j >= endY; j--) {
            const ints = calcSortedIntersections(lines, j);
            for (let i = 0; i < ints.length; i += 2) {
              const fstartf = fract(ints[i]);
              const fendf = fract(ints[i + 1]);
              const start = Math.floor(ints[i]);
              const end = Math.floor(ints[i + 1]);
              for (let ii = start; ii <= end; ii++) {
                let col = this.calculateRGBA(ii, j);
                if (ii === start) {
                  const int = or(rgb, (1 - fstartf) * alpha);
                  this.fillPixelWithColor(ii, j, int);
                  continue;
                }
                if (ii === end) {
                  const int = or(rgb, fendf * alpha);
                  this.fillPixelWithColor(ii, j, int);
                  continue;
                }
                this.fillPixelWithColor(ii, j, col);
              }
            }
          }
        }
        /**
         * Fill No Anti-aliased
         *
         * @returns {void}
         *
         * @memberof Context
         */
        fill_noaa(lines) {
          and(this._fillColor, 4294967040);
          const bounds = calcMinimumBounds(lines);
          const startY = Math.min(bounds.y2 + 1, this.bitmap.height);
          const endY = Math.max(bounds.y - 1, 0);
          for (let j = startY; j >= endY; j--) {
            const ints = calcSortedIntersections(lines, j);
            for (let i = 0; i < ints.length; i += 2) {
              const start = Math.floor(ints[i]);
              const end = Math.floor(ints[i + 1]);
              for (let ii = start; ii <= end; ii++) {
                let col = this.calculateRGBA(ii, j);
                if (ii === start) {
                  this.fillPixelWithColor(ii, j, col);
                  continue;
                }
                if (ii === end) {
                  this.fillPixelWithColor(ii, j, col);
                  continue;
                }
                this.fillPixelWithColor(ii, j, col);
              }
            }
          }
        }
        /**
         * Pixel Inside Clip
         *
         * Even/odd rule. https://en.wikipedia.org/wiki/Point_in_polygon
         * technically this is not correct as the default algorithm for
         * html canvas is supposed to be the non-zero winding rule instead
         *
         * @see https://en.wikipedia.org/wiki/Point_in_polygon
         *
         * @param {number} x
         * @param {number} y
         *
         * @returns {void}
         *
         * @memberof Context
         */
        pixelInsideClip(x, y) {
          if (!this._clip)
            return true;
          const ints = calcSortedIntersections(this._clip, y);
          const left = ints.filter((inter) => inter < x);
          if (left.length % 2 === 0) {
            return false;
          } else {
            return true;
          }
        }
        /**
         *  Draws a text string at the specified coordinates, filling the string's characters with the current foreground color
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillText
         *
         * @param {string} text A string specifying the text string to render into the context. The text is rendered using the settings specified by {@link font}.
         * @param {number} x    The x -coordinate of the point at which to begin drawing the text, in pixels.
         * @param {number} y    The y-coordinate of the point at which to begin drawing the text, in pixels.
         *
         * @returns {void}
         *
         * @memberof Context
         */
        fillText(text, x, y) {
          processTextPath(this, text, x, y, true, this.textAlign, this.textBaseline);
        }
        /**
         * Draws the outlines of the characters of a specified text string at the given (x, y) position.
         *
         * @param {string} text The text to draw using the current {@link font} values.
         * @param {number} x    The x axis of the coordinate for the text starting point.
         * @param {number} y    The y axis of the coordinate for the text starting point.
         *
         * @returns {void}
         *
         * @memberof Context
         */
        strokeText(text, x, y) {
          processTextPath(this, text, x, y, false, this.textAlign, this.textBaseline);
        }
      }
      __name(Context, "Context");
      function fract(v) {
        return v - Math.floor(v);
      }
      __name(fract, "fract");
      function pathToLines(path2) {
        const lines = [];
        let curr = null;
        path2.forEach(function(cmd) {
          if (cmd[0] === PATH_COMMAND.MOVE) {
            curr = cmd[1];
          }
          if (cmd[0] === PATH_COMMAND.LINE) {
            const pt = cmd[1];
            lines.push(new Line(curr, pt));
            curr = pt;
          }
          if (cmd[0] === PATH_COMMAND.QUADRATIC_CURVE) {
            const pts = [curr, cmd[1], cmd[2]];
            for (let t = 0; t < 1; t += 0.1) {
              let pt = calcQuadraticAtT(pts, t);
              lines.push(new Line(curr, pt));
              curr = pt;
            }
          }
          if (cmd[0] === PATH_COMMAND.BEZIER_CURVE) {
            const pts = [curr, cmd[1], cmd[2], cmd[3]];
            bezierToLines(pts, 10).forEach((pt) => {
              lines.push(new Line(curr, pt));
              curr = pt;
            });
          }
        });
        return lines;
      }
      __name(pathToLines, "pathToLines");
      function flatten_path(A) {
        let B = [];
        let curr = null;
        A.forEach((cmd) => {
          if (cmd[0] === PATH_COMMAND.MOVE) {
            curr = cmd[1];
            return B.push([PATH_COMMAND.MOVE, new Point(curr.x, curr.y)]);
          }
          if (cmd[0] === PATH_COMMAND.LINE) {
            curr = cmd[1];
            return B.push([PATH_COMMAND.LINE, new Point(curr.x, curr.y)]);
          }
          if (cmd[0] === PATH_COMMAND.BEZIER_CURVE) {
            const pts = [curr, cmd[1], cmd[2], cmd[3]];
            let pts2 = bezierToLines(pts, 10);
            for (let i = 1; i < pts2.length; i += 2) {
              B.push([PATH_COMMAND.LINE, new Point(pts2[i].x, pts2[i].y)]);
            }
            curr = cmd[3];
          }
        });
        return B;
      }
      __name(flatten_path, "flatten_path");
      function path_to_stroked_path(path2, w) {
        let subs = [];
        let curr_sub = [];
        path2.forEach((pth) => {
          if (pth[0] === PATH_COMMAND.MOVE) {
            if (curr_sub.length > 0)
              subs.push(curr_sub);
            curr_sub = [];
          }
          curr_sub.push(pth);
        });
        if (curr_sub.length > 0)
          subs.push(curr_sub);
        subs.forEach((sub) => {
          if (sub[0][0] !== PATH_COMMAND.MOVE)
            console.warn("missing a starting move command!");
        });
        let fsubs = subs.map((sub) => sub_path_to_stroked_sub_path(sub, w));
        let final_path = [];
        fsubs.forEach((sub) => sub.forEach((cmd) => final_path.push(cmd)));
        return final_path;
      }
      __name(path_to_stroked_path, "path_to_stroked_path");
      function sub_path_to_stroked_sub_path(path2, w) {
        let curr = null;
        let outside = [];
        let inside = [];
        let path_start = 0;
        function project(A, B, scale) {
          if (A.equals(B))
            console.log("same points!", A, B);
          let delta_unit = A.subtract(B).unit();
          let C_unit = delta_unit.rotate(toRad(90));
          let D_unit = delta_unit.rotate(toRad(-90));
          return [
            C_unit.scale(scale).add(B),
            D_unit.scale(scale).add(B)
          ];
        }
        __name(project, "project");
        let prev_cmd = null;
        function normalize_angle(turn) {
          if (turn < -Math.PI)
            return turn + Math.PI * 2;
          if (turn > +Math.PI)
            return turn - Math.PI * 2;
          return turn;
        }
        __name(normalize_angle, "normalize_angle");
        path2.forEach(function(cmd, i) {
          if (cmd[0] === PATH_COMMAND.MOVE) {
            curr = cmd[1];
            prev_cmd = cmd;
            path_start = curr.clone();
            outside.push([PATH_COMMAND.MOVE, path_start.clone()]);
          }
          if (cmd[0] === PATH_COMMAND.LINE) {
            const A = curr;
            const B = cmd[1];
            if (A.equals(B))
              return console.log("can't project the same paths", i, cmd, A, B);
            let next = path2[i + 1];
            if (prev_cmd[0] === PATH_COMMAND.MOVE) {
              let pts12 = project(B, A, w);
              outside.push([PATH_COMMAND.LINE, pts12[1]]);
              inside.push([PATH_COMMAND.LINE, pts12[0]]);
            }
            prev_cmd = cmd;
            if (!next) {
              let pts12 = project(A, B, w);
              outside.push([PATH_COMMAND.LINE, pts12[0]]);
              inside.push([PATH_COMMAND.LINE, pts12[1]]);
              return;
            }
            const C = next[1];
            if (C.equals(B))
              return console.log("can't project the same paths", i, cmd, A, B);
            let BA = A.subtract(B);
            let BC = C.subtract(B);
            let BA_angle = Math.atan2(BA.y, BA.x);
            let BC_angle = Math.atan2(BC.y, BC.x);
            let turn = normalize_angle(BC_angle - BA_angle);
            let pts1 = project(A, B, w);
            let pts2 = project(C, B, w);
            if (turn < 0) {
              outside.push([PATH_COMMAND.LINE, pts1[0]]);
              outside.push([PATH_COMMAND.LINE, pts2[1]]);
              let h = w / Math.cos((Math.PI + turn) / 2);
              let C_unit = A.subtract(B).unit().rotate(turn / 2).scale(h).add(B);
              inside.push([PATH_COMMAND.LINE, C_unit]);
            } else {
              let h = w / Math.cos(-(Math.PI - turn) / 2);
              let C_unit = C.subtract(B).unit().rotate(-turn / 2).scale(h).add(B);
              outside.push([PATH_COMMAND.LINE, C_unit]);
              inside.push([PATH_COMMAND.LINE, pts1[1]]);
              inside.push([PATH_COMMAND.LINE, pts2[0]]);
            }
            curr = B;
          }
        });
        inside.reverse();
        let final = [].concat(outside).concat(inside);
        final.push([PATH_COMMAND.LINE, path_start]);
        return final;
      }
      __name(sub_path_to_stroked_sub_path, "sub_path_to_stroked_sub_path");
      function calcQuadraticAtT(p, t) {
        const x = (1 - t) * (1 - t) * p[0].x + 2 * (1 - t) * t * p[1].x + t * t * p[2].x;
        const y = (1 - t) * (1 - t) * p[0].y + 2 * (1 - t) * t * p[1].y + t * t * p[2].y;
        return new Point(x, y);
      }
      __name(calcQuadraticAtT, "calcQuadraticAtT");
      function bezierToLines(curve, THRESHOLD) {
        function recurse(curve2) {
          if (flatness(curve2) < THRESHOLD)
            return [curve2[0], curve2[3]];
          const split = splitCurveAtT(curve2, 0.5);
          return recurse(split[0]).concat(recurse(split[1]));
        }
        __name(recurse, "recurse");
        return recurse(curve);
      }
      __name(bezierToLines, "bezierToLines");
      function splitCurveAtT(p, t, debug) {
        let p1 = p[0];
        let p2 = p[1];
        let p3 = p[2];
        let p4 = p[3];
        let p12 = midpoint(p1, p2, t);
        let p23 = midpoint(p2, p3, t);
        let p34 = midpoint(p4, p3, t);
        let p123 = midpoint(p12, p23, t);
        let p234 = midpoint(p23, p34, t);
        let p1234 = { x: (p234.x - p123.x) * t + p123.x, y: (p234.y - p123.y) * t + p123.y };
        return [[p1, p12, p123, p1234], [p1234, p234, p34, p4]];
      }
      __name(splitCurveAtT, "splitCurveAtT");
      function flatness(curve) {
        const pointA = curve[0];
        const controlPointA = curve[1];
        const controlPointB = curve[2];
        const pointB = curve[3];
        let ux = Math.pow(3 * controlPointA.x - 2 * pointA.x - pointB.x, 2);
        let uy = Math.pow(3 * controlPointA.y - 2 * pointA.y - pointB.y, 2);
        let vx = Math.pow(3 * controlPointB.x - 2 * pointB.x - pointA.x, 2);
        let vy = Math.pow(3 * controlPointB.y - 2 * pointB.y - pointA.y, 2);
        if (ux < vx)
          ux = vx;
        if (uy < vy)
          uy = vy;
        return ux + uy;
      }
      __name(flatness, "flatness");
      function midpoint(p1, p2, t) {
        return { x: (p2.x - p1.x) * t + p1.x, y: (p2.y - p1.y) * t + p1.y };
      }
      __name(midpoint, "midpoint");
      function calcMinimumBounds(lines) {
        const bounds = {
          x: Number.MAX_VALUE,
          y: Number.MAX_VALUE,
          x2: Number.MIN_VALUE,
          y2: Number.MIN_VALUE
        };
        function checkPoint(pt) {
          bounds.x = Math.min(bounds.x, pt.x);
          bounds.y = Math.min(bounds.y, pt.y);
          bounds.x2 = Math.max(bounds.x2, pt.x);
          bounds.y2 = Math.max(bounds.y2, pt.y);
        }
        __name(checkPoint, "checkPoint");
        lines.forEach(function(line2) {
          checkPoint(line2.start);
          checkPoint(line2.end);
        });
        return bounds;
      }
      __name(calcMinimumBounds, "calcMinimumBounds");
      function calcSortedIntersections(lines, y) {
        const xlist = [];
        for (let i = 0; i < lines.length; i++) {
          const A = lines[i].start;
          const B = lines[i].end;
          if (A.y < y && B.y >= y || B.y < y && A.y >= y) {
            const xval = A.x + (y - A.y) / (B.y - A.y) * (B.x - A.x);
            xlist.push(xval);
          }
        }
        return xlist.sort(function(a, b) {
          return a - b;
        });
      }
      __name(calcSortedIntersections, "calcSortedIntersections");
      class Bitmap {
        /**
         * Creates an instance of Bitmap.
         * @param {number} w      Width
         * @param {number} h      Height
         * @param {any}   options Currently unused
         * @memberof Bitmap
         */
        constructor(w, h, options) {
          this.width = Math.floor(w);
          this.height = Math.floor(h);
          this.data = Buffer.alloc(w * h * 4);
          const fillval = OPAQUE_BLACK;
          for (let j = 0; j < h; j++) {
            for (let i = 0; i < w; i++) {
              this.setPixelRGBA(i, j, fillval);
            }
          }
        }
        /**
         * Calculate Index
         *
         * @param {number} x X position
         * @param {number} y Y position
         *
         * @returns {number}
         *
         * @memberof Bitmap
         */
        calculateIndex(x, y) {
          x = Math.floor(x);
          y = Math.floor(y);
          if (x < 0 || y < 0 || x >= this.width || y >= this.height)
            return 0;
          return (this.width * y + x) * 4;
        }
        /**
         * Set the RGBA(Red, Green, Blue, Alpha) values on an individual pixel level
         *
         * @param {number} x    X axis position
         * @param {number} y    Y axis position
         * @param {number} rgba A hex representation of the RGBA value of the pixel. See {@link NAMED_COLORS} for examples
         *
         * @returns {void}
         *
         * @memberof Bitmap
         */
        setPixelRGBA(x, y, rgba) {
          this.validate_coords(x, y);
          let i = this.calculateIndex(x, y);
          const bytes = getBytesBigEndian(rgba);
          this.data[i + 0] = bytes[0];
          this.data[i + 1] = bytes[1];
          this.data[i + 2] = bytes[2];
          this.data[i + 3] = bytes[3];
        }
        /**
         * Set the individual red, green, blue and alpha levels of an individual pixel
         *
         * @param {number} x X axis position
         * @param {number} y Y axis position
         * @param {number} r Red level
         * @param {number} g Green level
         * @param {number} b Blue level
         * @param {number} a Alpha level
         *
         * @returns {void}
         *
         * @memberof Bitmap
         */
        setPixelRGBA_i(x, y, r, g, b, a) {
          let i = this.calculateIndex(x, y);
          this.data[i + 0] = r;
          this.data[i + 1] = g;
          this.data[i + 2] = b;
          this.data[i + 3] = a;
        }
        /**
         * Get the RGBA value of an individual pixel as a hexadecimal number(See {@link NAMED_COLORS} for examples)
         *
         * @param {number} x X axis potiion
         * @param {number} y Y axis position
         *
         * @returns {number}
         *
         * @memberof Bitmap
         */
        getPixelRGBA(x, y) {
          this.validate_coords(x, y);
          let i = this.calculateIndex(x, y);
          return fromBytesBigEndian(
            this.data[i + 0],
            this.data[i + 1],
            this.data[i + 2],
            this.data[i + 3]
          );
        }
        /**
         * Get Pixel RGBA Seperate
         *
         * @param {number} x X axis position
         * @param {number} y Y axis position
         *
         * @ignore
         *
         * @returns {Array}
         *
         * @memberof Bitmap
         */
        getPixelRGBA_separate(x, y) {
          const i = this.calculateIndex(x, y);
          return this.data.slice(i, i + 4);
        }
        /**
         * {@link Context} factory. Creates a new {@link Context} instance object for the current bitmap object
         *
         * @returns {Context}
         *
         * @memberof Bitmap
         */
        getContext(type) {
          return new Context(this);
        }
        _copySubBitmap(x, y, w, h) {
          let dst = new Bitmap(w, h, {});
          for (let i = 0; i < w; i++) {
            for (let j = 0; j < h; j++) {
              let indexA = this.calculateIndex(x + i, y + j);
              let indexB = dst.calculateIndex(i, j);
              for (let k = 0; k < 4; k++) {
                dst.data[indexB + k] = this.data[indexA + k];
              }
            }
          }
          return dst;
        }
        _pasteSubBitmap(src, x, y) {
          for (let i = 0; i < src.width; i++) {
            for (let j = 0; j < src.height; j++) {
              let indexA = this.calculateIndex(x + i, y + j);
              let indexB = src.calculateIndex(i, j);
              for (let k = 0; k < 4; k++) {
                this.data[indexA + k] = src.data[indexB + k];
              }
            }
          }
        }
        _isValidCoords(x, y) {
          if (x < 0)
            return false;
          if (y < 0)
            return false;
          if (x >= this.width)
            return false;
          if (y >= this.height)
            return false;
          return true;
        }
        validate_coords(x, y) {
          if (x < 0)
            throw new Error(`Invalid Index: x ${x} <0`);
          if (y < 0)
            throw new Error(`Invalid Index: y ${y} <0`);
          if (x >= this.width)
            throw new Error(`Invalid Index: x ${x} >= width ${this.width}`);
          if (y >= this.height)
            throw new Error(`Invalid Index: x ${x} >= width ${this.height}`);
        }
      }
      __name(Bitmap, "Bitmap");
      var chunkstream = createCommonjsModule(function(module3) {
        var ChunkStream = module3.exports = function() {
          Stream__default["default"].call(this);
          this._buffers = [];
          this._buffered = 0;
          this._reads = [];
          this._paused = false;
          this._encoding = "utf8";
          this.writable = true;
        };
        util__default["default"].inherits(ChunkStream, Stream__default["default"]);
        ChunkStream.prototype.read = function(length, callback) {
          this._reads.push({
            length: Math.abs(length),
            // if length < 0 then at most this length
            allowLess: length < 0,
            func: callback
          });
          process.nextTick(function() {
            this._process();
            if (this._paused && this._reads.length > 0) {
              this._paused = false;
              this.emit("drain");
            }
          }.bind(this));
        };
        ChunkStream.prototype.write = function(data, encoding2) {
          if (!this.writable) {
            this.emit("error", new Error("Stream not writable"));
            return false;
          }
          var dataBuffer;
          if (Buffer.isBuffer(data)) {
            dataBuffer = data;
          } else {
            dataBuffer = new Buffer(data, encoding2 || this._encoding);
          }
          this._buffers.push(dataBuffer);
          this._buffered += dataBuffer.length;
          this._process();
          if (this._reads && this._reads.length === 0) {
            this._paused = true;
          }
          return this.writable && !this._paused;
        };
        ChunkStream.prototype.end = function(data, encoding2) {
          if (data) {
            this.write(data, encoding2);
          }
          this.writable = false;
          if (!this._buffers) {
            return;
          }
          if (this._buffers.length === 0) {
            this._end();
          } else {
            this._buffers.push(null);
            this._process();
          }
        };
        ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
        ChunkStream.prototype._end = function() {
          if (this._reads.length > 0) {
            this.emit(
              "error",
              new Error("There are some read requests waiting on finished stream")
            );
          }
          this.destroy();
        };
        ChunkStream.prototype.destroy = function() {
          if (!this._buffers) {
            return;
          }
          this.writable = false;
          this._reads = null;
          this._buffers = null;
          this.emit("close");
        };
        ChunkStream.prototype._processReadAllowingLess = function(read2) {
          this._reads.shift();
          var smallerBuf = this._buffers[0];
          if (smallerBuf.length > read2.length) {
            this._buffered -= read2.length;
            this._buffers[0] = smallerBuf.slice(read2.length);
            read2.func.call(this, smallerBuf.slice(0, read2.length));
          } else {
            this._buffered -= smallerBuf.length;
            this._buffers.shift();
            read2.func.call(this, smallerBuf);
          }
        };
        ChunkStream.prototype._processRead = function(read2) {
          this._reads.shift();
          var pos = 0;
          var count = 0;
          var data = new Buffer(read2.length);
          while (pos < read2.length) {
            var buf = this._buffers[count++];
            var len = Math.min(buf.length, read2.length - pos);
            buf.copy(data, pos, 0, len);
            pos += len;
            if (len !== buf.length) {
              this._buffers[--count] = buf.slice(len);
            }
          }
          if (count > 0) {
            this._buffers.splice(0, count);
          }
          this._buffered -= read2.length;
          read2.func.call(this, data);
        };
        ChunkStream.prototype._process = function() {
          try {
            while (this._buffered > 0 && this._reads && this._reads.length > 0) {
              var read2 = this._reads[0];
              if (read2.allowLess) {
                this._processReadAllowingLess(read2);
              } else if (this._buffered >= read2.length) {
                this._processRead(read2);
              } else {
                break;
              }
            }
            if (this._buffers && this._buffers.length > 0 && this._buffers[0] === null) {
              this._end();
            }
          } catch (ex) {
            this.emit("error", ex);
          }
        };
      });
      var imagePasses = [
        {
          // pass 1 - 1px
          x: [0],
          y: [0]
        },
        {
          // pass 2 - 1px
          x: [4],
          y: [0]
        },
        {
          // pass 3 - 2px
          x: [0, 4],
          y: [4]
        },
        {
          // pass 4 - 4px
          x: [2, 6],
          y: [0, 4]
        },
        {
          // pass 5 - 8px
          x: [0, 2, 4, 6],
          y: [2, 6]
        },
        {
          // pass 6 - 16px
          x: [1, 3, 5, 7],
          y: [0, 2, 4, 6]
        },
        {
          // pass 7 - 32px
          x: [0, 1, 2, 3, 4, 5, 6, 7],
          y: [1, 3, 5, 7]
        }
      ];
      var getImagePasses = /* @__PURE__ */ __name(function(width, height) {
        var images = [];
        var xLeftOver = width % 8;
        var yLeftOver = height % 8;
        var xRepeats = (width - xLeftOver) / 8;
        var yRepeats = (height - yLeftOver) / 8;
        for (var i = 0; i < imagePasses.length; i++) {
          var pass = imagePasses[i];
          var passWidth = xRepeats * pass.x.length;
          var passHeight = yRepeats * pass.y.length;
          for (var j = 0; j < pass.x.length; j++) {
            if (pass.x[j] < xLeftOver) {
              passWidth++;
            } else {
              break;
            }
          }
          for (j = 0; j < pass.y.length; j++) {
            if (pass.y[j] < yLeftOver) {
              passHeight++;
            } else {
              break;
            }
          }
          if (passWidth > 0 && passHeight > 0) {
            images.push({ width: passWidth, height: passHeight, index: i });
          }
        }
        return images;
      }, "getImagePasses");
      var getInterlaceIterator = /* @__PURE__ */ __name(function(width) {
        return function(x, y, pass) {
          var outerXLeftOver = x % imagePasses[pass].x.length;
          var outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
          var outerYLeftOver = y % imagePasses[pass].y.length;
          var outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
          return outerX * 4 + outerY * width * 4;
        };
      }, "getInterlaceIterator");
      var interlace = {
        getImagePasses,
        getInterlaceIterator
      };
      var paethPredictor = /* @__PURE__ */ __name(function paethPredictor2(left, above, upLeft) {
        var paeth = left + above - upLeft;
        var pLeft = Math.abs(paeth - left);
        var pAbove = Math.abs(paeth - above);
        var pUpLeft = Math.abs(paeth - upLeft);
        if (pLeft <= pAbove && pLeft <= pUpLeft) {
          return left;
        }
        if (pAbove <= pUpLeft) {
          return above;
        }
        return upLeft;
      }, "paethPredictor");
      var filterParse = createCommonjsModule(function(module3) {
        function getByteWidth(width, bpp, depth) {
          var byteWidth = width * bpp;
          if (depth !== 8) {
            byteWidth = Math.ceil(byteWidth / (8 / depth));
          }
          return byteWidth;
        }
        __name(getByteWidth, "getByteWidth");
        var Filter = module3.exports = function(bitmapInfo, dependencies) {
          var width = bitmapInfo.width;
          var height = bitmapInfo.height;
          var interlace$1 = bitmapInfo.interlace;
          var bpp = bitmapInfo.bpp;
          var depth = bitmapInfo.depth;
          this.read = dependencies.read;
          this.write = dependencies.write;
          this.complete = dependencies.complete;
          this._imageIndex = 0;
          this._images = [];
          if (interlace$1) {
            var passes = interlace.getImagePasses(width, height);
            for (var i = 0; i < passes.length; i++) {
              this._images.push({
                byteWidth: getByteWidth(passes[i].width, bpp, depth),
                height: passes[i].height,
                lineIndex: 0
              });
            }
          } else {
            this._images.push({
              byteWidth: getByteWidth(width, bpp, depth),
              height,
              lineIndex: 0
            });
          }
          if (depth === 8) {
            this._xComparison = bpp;
          } else if (depth === 16) {
            this._xComparison = bpp * 2;
          } else {
            this._xComparison = 1;
          }
        };
        Filter.prototype.start = function() {
          this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
        };
        Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
          var xComparison = this._xComparison;
          var xBiggerThan = xComparison - 1;
          for (var x = 0; x < byteWidth; x++) {
            var rawByte = rawData[1 + x];
            var f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
            unfilteredLine[x] = rawByte + f1Left;
          }
        };
        Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
          var lastLine = this._lastLine;
          for (var x = 0; x < byteWidth; x++) {
            var rawByte = rawData[1 + x];
            var f2Up = lastLine ? lastLine[x] : 0;
            unfilteredLine[x] = rawByte + f2Up;
          }
        };
        Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
          var xComparison = this._xComparison;
          var xBiggerThan = xComparison - 1;
          var lastLine = this._lastLine;
          for (var x = 0; x < byteWidth; x++) {
            var rawByte = rawData[1 + x];
            var f3Up = lastLine ? lastLine[x] : 0;
            var f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
            var f3Add = Math.floor((f3Left + f3Up) / 2);
            unfilteredLine[x] = rawByte + f3Add;
          }
        };
        Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
          var xComparison = this._xComparison;
          var xBiggerThan = xComparison - 1;
          var lastLine = this._lastLine;
          for (var x = 0; x < byteWidth; x++) {
            var rawByte = rawData[1 + x];
            var f4Up = lastLine ? lastLine[x] : 0;
            var f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
            var f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
            var f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
            unfilteredLine[x] = rawByte + f4Add;
          }
        };
        Filter.prototype._reverseFilterLine = function(rawData) {
          var filter = rawData[0];
          var unfilteredLine;
          var currentImage = this._images[this._imageIndex];
          var byteWidth = currentImage.byteWidth;
          if (filter === 0) {
            unfilteredLine = rawData.slice(1, byteWidth + 1);
          } else {
            unfilteredLine = new Buffer(byteWidth);
            switch (filter) {
              case 1:
                this._unFilterType1(rawData, unfilteredLine, byteWidth);
                break;
              case 2:
                this._unFilterType2(rawData, unfilteredLine, byteWidth);
                break;
              case 3:
                this._unFilterType3(rawData, unfilteredLine, byteWidth);
                break;
              case 4:
                this._unFilterType4(rawData, unfilteredLine, byteWidth);
                break;
              default:
                throw new Error("Unrecognised filter type - " + filter);
            }
          }
          this.write(unfilteredLine);
          currentImage.lineIndex++;
          if (currentImage.lineIndex >= currentImage.height) {
            this._lastLine = null;
            this._imageIndex++;
            currentImage = this._images[this._imageIndex];
          } else {
            this._lastLine = unfilteredLine;
          }
          if (currentImage) {
            this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
          } else {
            this._lastLine = null;
            this.complete();
          }
        };
      });
      var filterParseAsync = createCommonjsModule(function(module3) {
        var FilterAsync = module3.exports = function(bitmapInfo) {
          chunkstream.call(this);
          var buffers = [];
          var that = this;
          this._filter = new filterParse(bitmapInfo, {
            read: this.read.bind(this),
            write: function(buffer) {
              buffers.push(buffer);
            },
            complete: function() {
              that.emit("complete", Buffer.concat(buffers));
            }
          });
          this._filter.start();
        };
        util__default["default"].inherits(FilterAsync, chunkstream);
      });
      var constants = {
        PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
        TYPE_IHDR: 1229472850,
        TYPE_IEND: 1229278788,
        TYPE_IDAT: 1229209940,
        TYPE_PLTE: 1347179589,
        TYPE_tRNS: 1951551059,
        // eslint-disable-line camelcase
        TYPE_gAMA: 1732332865,
        // eslint-disable-line camelcase
        // color-type bits
        COLORTYPE_GRAYSCALE: 0,
        COLORTYPE_PALETTE: 1,
        COLORTYPE_COLOR: 2,
        COLORTYPE_ALPHA: 4,
        // e.g. grayscale and alpha
        // color-type combinations
        COLORTYPE_PALETTE_COLOR: 3,
        COLORTYPE_COLOR_ALPHA: 6,
        COLORTYPE_TO_BPP_MAP: {
          0: 1,
          2: 3,
          3: 1,
          4: 2,
          6: 4
        },
        GAMMA_DIVISION: 1e5
      };
      var crc = createCommonjsModule(function(module3) {
        var crcTable = [];
        (function() {
          for (var i = 0; i < 256; i++) {
            var currentCrc = i;
            for (var j = 0; j < 8; j++) {
              if (currentCrc & 1) {
                currentCrc = 3988292384 ^ currentCrc >>> 1;
              } else {
                currentCrc = currentCrc >>> 1;
              }
            }
            crcTable[i] = currentCrc;
          }
        })();
        var CrcCalculator = module3.exports = function() {
          this._crc = -1;
        };
        CrcCalculator.prototype.write = function(data) {
          for (var i = 0; i < data.length; i++) {
            this._crc = crcTable[(this._crc ^ data[i]) & 255] ^ this._crc >>> 8;
          }
          return true;
        };
        CrcCalculator.prototype.crc32 = function() {
          return this._crc ^ -1;
        };
        CrcCalculator.crc32 = function(buf) {
          var crc2 = -1;
          for (var i = 0; i < buf.length; i++) {
            crc2 = crcTable[(crc2 ^ buf[i]) & 255] ^ crc2 >>> 8;
          }
          return crc2 ^ -1;
        };
      });
      var parser = createCommonjsModule(function(module3) {
        var Parser = module3.exports = function(options, dependencies) {
          this._options = options;
          options.checkCRC = options.checkCRC !== false;
          this._hasIHDR = false;
          this._hasIEND = false;
          this._palette = [];
          this._colorType = 0;
          this._chunks = {};
          this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
          this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
          this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
          this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
          this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
          this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);
          this.read = dependencies.read;
          this.error = dependencies.error;
          this.metadata = dependencies.metadata;
          this.gamma = dependencies.gamma;
          this.transColor = dependencies.transColor;
          this.palette = dependencies.palette;
          this.parsed = dependencies.parsed;
          this.inflateData = dependencies.inflateData;
          this.finished = dependencies.finished;
        };
        Parser.prototype.start = function() {
          this.read(
            constants.PNG_SIGNATURE.length,
            this._parseSignature.bind(this)
          );
        };
        Parser.prototype._parseSignature = function(data) {
          var signature = constants.PNG_SIGNATURE;
          for (var i = 0; i < signature.length; i++) {
            if (data[i] !== signature[i]) {
              this.error(new Error("Invalid file signature"));
              return;
            }
          }
          this.read(8, this._parseChunkBegin.bind(this));
        };
        Parser.prototype._parseChunkBegin = function(data) {
          var length = data.readUInt32BE(0);
          var type = data.readUInt32BE(4);
          var name2 = "";
          for (var i = 4; i < 8; i++) {
            name2 += String.fromCharCode(data[i]);
          }
          var ancillary = Boolean(data[4] & 32);
          if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
            this.error(new Error("Expected IHDR on beggining"));
            return;
          }
          this._crc = new crc();
          this._crc.write(new Buffer(name2));
          if (this._chunks[type]) {
            return this._chunks[type](length);
          }
          if (!ancillary) {
            this.error(new Error("Unsupported critical chunk type " + name2));
            return;
          }
          this.read(length + 4, this._skipChunk.bind(this));
        };
        Parser.prototype._skipChunk = function() {
          this.read(8, this._parseChunkBegin.bind(this));
        };
        Parser.prototype._handleChunkEnd = function() {
          this.read(4, this._parseChunkEnd.bind(this));
        };
        Parser.prototype._parseChunkEnd = function(data) {
          var fileCrc = data.readInt32BE(0);
          var calcCrc = this._crc.crc32();
          if (this._options.checkCRC && calcCrc !== fileCrc) {
            this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
            return;
          }
          if (!this._hasIEND) {
            this.read(8, this._parseChunkBegin.bind(this));
          }
        };
        Parser.prototype._handleIHDR = function(length) {
          this.read(length, this._parseIHDR.bind(this));
        };
        Parser.prototype._parseIHDR = function(data) {
          this._crc.write(data);
          var width = data.readUInt32BE(0);
          var height = data.readUInt32BE(4);
          var depth = data[8];
          var colorType = data[9];
          var compr = data[10];
          var filter = data[11];
          var interlace2 = data[12];
          if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
            this.error(new Error("Unsupported bit depth " + depth));
            return;
          }
          if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
            this.error(new Error("Unsupported color type"));
            return;
          }
          if (compr !== 0) {
            this.error(new Error("Unsupported compression method"));
            return;
          }
          if (filter !== 0) {
            this.error(new Error("Unsupported filter method"));
            return;
          }
          if (interlace2 !== 0 && interlace2 !== 1) {
            this.error(new Error("Unsupported interlace method"));
            return;
          }
          this._colorType = colorType;
          var bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];
          this._hasIHDR = true;
          this.metadata({
            width,
            height,
            depth,
            interlace: Boolean(interlace2),
            palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
            color: Boolean(colorType & constants.COLORTYPE_COLOR),
            alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
            bpp,
            colorType
          });
          this._handleChunkEnd();
        };
        Parser.prototype._handlePLTE = function(length) {
          this.read(length, this._parsePLTE.bind(this));
        };
        Parser.prototype._parsePLTE = function(data) {
          this._crc.write(data);
          var entries = Math.floor(data.length / 3);
          for (var i = 0; i < entries; i++) {
            this._palette.push([
              data[i * 3],
              data[i * 3 + 1],
              data[i * 3 + 2],
              255
            ]);
          }
          this.palette(this._palette);
          this._handleChunkEnd();
        };
        Parser.prototype._handleTRNS = function(length) {
          this.read(length, this._parseTRNS.bind(this));
        };
        Parser.prototype._parseTRNS = function(data) {
          this._crc.write(data);
          if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
            if (this._palette.length === 0) {
              this.error(new Error("Transparency chunk must be after palette"));
              return;
            }
            if (data.length > this._palette.length) {
              this.error(new Error("More transparent colors than palette size"));
              return;
            }
            for (var i = 0; i < data.length; i++) {
              this._palette[i][3] = data[i];
            }
            this.palette(this._palette);
          }
          if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
            this.transColor([data.readUInt16BE(0)]);
          }
          if (this._colorType === constants.COLORTYPE_COLOR) {
            this.transColor([data.readUInt16BE(0), data.readUInt16BE(2), data.readUInt16BE(4)]);
          }
          this._handleChunkEnd();
        };
        Parser.prototype._handleGAMA = function(length) {
          this.read(length, this._parseGAMA.bind(this));
        };
        Parser.prototype._parseGAMA = function(data) {
          this._crc.write(data);
          this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);
          this._handleChunkEnd();
        };
        Parser.prototype._handleIDAT = function(length) {
          this.read(-length, this._parseIDAT.bind(this, length));
        };
        Parser.prototype._parseIDAT = function(length, data) {
          this._crc.write(data);
          if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
            throw new Error("Expected palette not found");
          }
          this.inflateData(data);
          var leftOverLength = length - data.length;
          if (leftOverLength > 0) {
            this._handleIDAT(leftOverLength);
          } else {
            this._handleChunkEnd();
          }
        };
        Parser.prototype._handleIEND = function(length) {
          this.read(length, this._parseIEND.bind(this));
        };
        Parser.prototype._parseIEND = function(data) {
          this._crc.write(data);
          this._hasIEND = true;
          this._handleChunkEnd();
          if (this.finished) {
            this.finished();
          }
        };
      });
      var pixelBppMap = {
        1: {
          // L
          0: 0,
          1: 0,
          2: 0,
          3: 255
        },
        2: {
          // LA
          0: 0,
          1: 0,
          2: 0,
          3: 1
        },
        3: {
          // RGB
          0: 0,
          1: 1,
          2: 2,
          3: 255
        },
        4: {
          // RGBA
          0: 0,
          1: 1,
          2: 2,
          3: 3
        }
      };
      function bitRetriever(data, depth) {
        var leftOver = [];
        var i = 0;
        function split() {
          if (i === data.length) {
            throw new Error("Ran out of data");
          }
          var byte = data[i];
          i++;
          var byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
          switch (depth) {
            default:
              throw new Error("unrecognised depth");
            case 16:
              byte2 = data[i];
              i++;
              leftOver.push((byte << 8) + byte2);
              break;
            case 4:
              byte2 = byte & 15;
              byte1 = byte >> 4;
              leftOver.push(byte1, byte2);
              break;
            case 2:
              byte4 = byte & 3;
              byte3 = byte >> 2 & 3;
              byte2 = byte >> 4 & 3;
              byte1 = byte >> 6 & 3;
              leftOver.push(byte1, byte2, byte3, byte4);
              break;
            case 1:
              byte8 = byte & 1;
              byte7 = byte >> 1 & 1;
              byte6 = byte >> 2 & 1;
              byte5 = byte >> 3 & 1;
              byte4 = byte >> 4 & 1;
              byte3 = byte >> 5 & 1;
              byte2 = byte >> 6 & 1;
              byte1 = byte >> 7 & 1;
              leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
              break;
          }
        }
        __name(split, "split");
        return {
          get: function(count) {
            while (leftOver.length < count) {
              split();
            }
            var returner = leftOver.slice(0, count);
            leftOver = leftOver.slice(count);
            return returner;
          },
          resetAfterLine: function() {
            leftOver.length = 0;
          },
          end: function() {
            if (i !== data.length) {
              throw new Error("extra data found");
            }
          }
        };
      }
      __name(bitRetriever, "bitRetriever");
      function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
        var imageWidth = image.width;
        var imageHeight = image.height;
        var imagePass = image.index;
        for (var y = 0; y < imageHeight; y++) {
          for (var x = 0; x < imageWidth; x++) {
            var pxPos = getPxPos(x, y, imagePass);
            for (var i = 0; i < 4; i++) {
              var idx = pixelBppMap[bpp][i];
              if (idx === 255) {
                pxData[pxPos + i] = 255;
              } else {
                var dataPos = idx + rawPos;
                if (dataPos === data.length) {
                  throw new Error("Ran out of data");
                }
                pxData[pxPos + i] = data[dataPos];
              }
            }
            rawPos += bpp;
          }
        }
        return rawPos;
      }
      __name(mapImage8Bit, "mapImage8Bit");
      function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
        var imageWidth = image.width;
        var imageHeight = image.height;
        var imagePass = image.index;
        for (var y = 0; y < imageHeight; y++) {
          for (var x = 0; x < imageWidth; x++) {
            var pixelData = bits.get(bpp);
            var pxPos = getPxPos(x, y, imagePass);
            for (var i = 0; i < 4; i++) {
              var idx = pixelBppMap[bpp][i];
              pxData[pxPos + i] = idx !== 255 ? pixelData[idx] : maxBit;
            }
          }
          bits.resetAfterLine();
        }
      }
      __name(mapImageCustomBit, "mapImageCustomBit");
      var dataToBitMap = /* @__PURE__ */ __name(function(data, bitmapInfo) {
        var width = bitmapInfo.width;
        var height = bitmapInfo.height;
        var depth = bitmapInfo.depth;
        var bpp = bitmapInfo.bpp;
        var interlace$1 = bitmapInfo.interlace;
        if (depth !== 8) {
          var bits = bitRetriever(data, depth);
        }
        var pxData;
        if (depth <= 8) {
          pxData = new Buffer(width * height * 4);
        } else {
          pxData = new Uint16Array(width * height * 4);
        }
        var maxBit = Math.pow(2, depth) - 1;
        var rawPos = 0;
        var images;
        var getPxPos;
        if (interlace$1) {
          images = interlace.getImagePasses(width, height);
          getPxPos = interlace.getInterlaceIterator(width, height);
        } else {
          var nonInterlacedPxPos = 0;
          getPxPos = /* @__PURE__ */ __name(function() {
            var returner = nonInterlacedPxPos;
            nonInterlacedPxPos += 4;
            return returner;
          }, "getPxPos");
          images = [{ width, height }];
        }
        for (var imageIndex = 0; imageIndex < images.length; imageIndex++) {
          if (depth === 8) {
            rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
          } else {
            mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
          }
        }
        if (depth === 8) {
          if (rawPos !== data.length) {
            throw new Error("extra data found");
          }
        } else {
          bits.end();
        }
        return pxData;
      }, "dataToBitMap");
      var bitmapper = {
        dataToBitMap
      };
      function dePalette(indata, outdata, width, height, palette) {
        var pxPos = 0;
        for (var y = 0; y < height; y++) {
          for (var x = 0; x < width; x++) {
            var color = palette[indata[pxPos]];
            if (!color) {
              throw new Error("index " + indata[pxPos] + " not in palette");
            }
            for (var i = 0; i < 4; i++) {
              outdata[pxPos + i] = color[i];
            }
            pxPos += 4;
          }
        }
      }
      __name(dePalette, "dePalette");
      function replaceTransparentColor(indata, outdata, width, height, transColor) {
        var pxPos = 0;
        for (var y = 0; y < height; y++) {
          for (var x = 0; x < width; x++) {
            var makeTrans = false;
            if (transColor.length === 1) {
              if (transColor[0] === indata[pxPos]) {
                makeTrans = true;
              }
            } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
              makeTrans = true;
            }
            if (makeTrans) {
              for (var i = 0; i < 4; i++) {
                outdata[pxPos + i] = 0;
              }
            }
            pxPos += 4;
          }
        }
      }
      __name(replaceTransparentColor, "replaceTransparentColor");
      function scaleDepth(indata, outdata, width, height, depth) {
        var maxOutSample = 255;
        var maxInSample = Math.pow(2, depth) - 1;
        var pxPos = 0;
        for (var y = 0; y < height; y++) {
          for (var x = 0; x < width; x++) {
            for (var i = 0; i < 4; i++) {
              outdata[pxPos + i] = Math.floor(indata[pxPos + i] * maxOutSample / maxInSample + 0.5);
            }
            pxPos += 4;
          }
        }
      }
      __name(scaleDepth, "scaleDepth");
      var formatNormaliser = /* @__PURE__ */ __name(function(indata, imageData) {
        var depth = imageData.depth;
        var width = imageData.width;
        var height = imageData.height;
        var colorType = imageData.colorType;
        var transColor = imageData.transColor;
        var palette = imageData.palette;
        var outdata = indata;
        if (colorType === 3) {
          dePalette(indata, outdata, width, height, palette);
        } else {
          if (transColor) {
            replaceTransparentColor(indata, outdata, width, height, transColor);
          }
          if (depth !== 8) {
            if (depth === 16) {
              outdata = new Buffer(width * height * 4);
            }
            scaleDepth(indata, outdata, width, height, depth);
          }
        }
        return outdata;
      }, "formatNormaliser");
      var parserAsync = createCommonjsModule(function(module3) {
        var ParserAsync = module3.exports = function(options) {
          chunkstream.call(this);
          this._parser = new parser(options, {
            read: this.read.bind(this),
            error: this._handleError.bind(this),
            metadata: this._handleMetaData.bind(this),
            gamma: this.emit.bind(this, "gamma"),
            palette: this._handlePalette.bind(this),
            transColor: this._handleTransColor.bind(this),
            finished: this._finished.bind(this),
            inflateData: this._inflateData.bind(this)
          });
          this._options = options;
          this.writable = true;
          this._parser.start();
        };
        util__default["default"].inherits(ParserAsync, chunkstream);
        ParserAsync.prototype._handleError = function(err) {
          this.emit("error", err);
          this.writable = false;
          this.destroy();
          if (this._inflate && this._inflate.destroy) {
            this._inflate.destroy();
          }
          this.errord = true;
        };
        ParserAsync.prototype._inflateData = function(data) {
          if (!this._inflate) {
            if (this._bitmapInfo.interlace) {
              this._inflate = zlib__default["default"].createInflate();
              this._inflate.on("error", this.emit.bind(this, "error"));
              this._filter.on("complete", this._complete.bind(this));
              this._inflate.pipe(this._filter);
            } else {
              var rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
              var imageSize = rowSize * this._bitmapInfo.height;
              var chunkSize = Math.max(imageSize, zlib__default["default"].Z_MIN_CHUNK);
              this._inflate = zlib__default["default"].createInflate({ chunkSize });
              var leftToInflate = imageSize;
              var emitError = this.emit.bind(this, "error");
              this._inflate.on("error", function(err) {
                if (!leftToInflate) {
                  return;
                }
                emitError(err);
              });
              this._filter.on("complete", this._complete.bind(this));
              var filterWrite = this._filter.write.bind(this._filter);
              this._inflate.on("data", function(chunk) {
                if (!leftToInflate) {
                  return;
                }
                if (chunk.length > leftToInflate) {
                  chunk = chunk.slice(0, leftToInflate);
                }
                leftToInflate -= chunk.length;
                filterWrite(chunk);
              });
              this._inflate.on("end", this._filter.end.bind(this._filter));
            }
          }
          this._inflate.write(data);
        };
        ParserAsync.prototype._handleMetaData = function(metaData) {
          this.emit("metadata", metaData);
          this._bitmapInfo = Object.create(metaData);
          this._filter = new filterParseAsync(this._bitmapInfo);
        };
        ParserAsync.prototype._handleTransColor = function(transColor) {
          this._bitmapInfo.transColor = transColor;
        };
        ParserAsync.prototype._handlePalette = function(palette) {
          this._bitmapInfo.palette = palette;
        };
        ParserAsync.prototype._finished = function() {
          if (this.errord) {
            return;
          }
          if (!this._inflate) {
            this.emit("error", "No Inflate block");
          } else {
            this._inflate.end();
          }
          this.destroySoon();
        };
        ParserAsync.prototype._complete = function(filteredData) {
          if (this.errord) {
            return;
          }
          try {
            var bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
            var normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
            bitmapData = null;
          } catch (ex) {
            this._handleError(ex);
            return;
          }
          this.emit("parsed", normalisedBitmapData);
        };
      });
      var bitpacker = /* @__PURE__ */ __name(function(dataIn, width, height, options) {
        var outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;
        if (options.colorType === options.inputColorType) {
          var bigEndian = function() {
            var buffer = new ArrayBuffer(2);
            new DataView(buffer).setInt16(
              0,
              256,
              true
              /* littleEndian */
            );
            return new Int16Array(buffer)[0] !== 256;
          }();
          if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {
            return dataIn;
          }
        }
        var data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
        var maxValue = 255;
        var inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];
        if (inBpp == 4 && !options.inputHasAlpha)
          inBpp = 3;
        var outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];
        if (options.bitDepth === 16) {
          maxValue = 65535;
          outBpp *= 2;
        }
        var outData = new Buffer(width * height * outBpp);
        var inIndex = 0;
        var outIndex = 0;
        var bgColor = options.bgColor || {};
        if (bgColor.red === void 0) {
          bgColor.red = maxValue;
        }
        if (bgColor.green === void 0) {
          bgColor.green = maxValue;
        }
        if (bgColor.blue === void 0) {
          bgColor.blue = maxValue;
        }
        function getRGBA(data2, inIndex2) {
          var red, green, blue, alpha = maxValue;
          switch (options.inputColorType) {
            case constants.COLORTYPE_COLOR_ALPHA:
              alpha = data2[inIndex2 + 3];
              red = data2[inIndex2];
              green = data2[inIndex2 + 1];
              blue = data2[inIndex2 + 2];
              break;
            case constants.COLORTYPE_COLOR:
              red = data2[inIndex2];
              green = data2[inIndex2 + 1];
              blue = data2[inIndex2 + 2];
              break;
            case constants.COLORTYPE_ALPHA:
              alpha = data2[inIndex2 + 1];
              red = data2[inIndex2];
              green = red;
              blue = red;
              break;
            case constants.COLORTYPE_GRAYSCALE:
              red = data2[inIndex2];
              green = red;
              blue = red;
              break;
            default:
              throw new Error("input color type:" + options.inputColorType + " is not supported at present");
          }
          if (options.inputHasAlpha) {
            if (!outHasAlpha) {
              alpha /= maxValue;
              red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
              green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
              blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
            }
          }
          return { red, green, blue, alpha };
        }
        __name(getRGBA, "getRGBA");
        for (var y = 0; y < height; y++) {
          for (var x = 0; x < width; x++) {
            var rgba = getRGBA(data, inIndex);
            switch (options.colorType) {
              case constants.COLORTYPE_COLOR_ALPHA:
              case constants.COLORTYPE_COLOR:
                if (options.bitDepth === 8) {
                  outData[outIndex] = rgba.red;
                  outData[outIndex + 1] = rgba.green;
                  outData[outIndex + 2] = rgba.blue;
                  if (outHasAlpha) {
                    outData[outIndex + 3] = rgba.alpha;
                  }
                } else {
                  outData.writeUInt16BE(rgba.red, outIndex);
                  outData.writeUInt16BE(rgba.green, outIndex + 2);
                  outData.writeUInt16BE(rgba.blue, outIndex + 4);
                  if (outHasAlpha) {
                    outData.writeUInt16BE(rgba.alpha, outIndex + 6);
                  }
                }
                break;
              case constants.COLORTYPE_ALPHA:
              case constants.COLORTYPE_GRAYSCALE:
                var grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
                if (options.bitDepth === 8) {
                  outData[outIndex] = grayscale;
                  if (outHasAlpha) {
                    outData[outIndex + 1] = rgba.alpha;
                  }
                } else {
                  outData.writeUInt16BE(grayscale, outIndex);
                  if (outHasAlpha) {
                    outData.writeUInt16BE(rgba.alpha, outIndex + 2);
                  }
                }
                break;
            }
            inIndex += inBpp;
            outIndex += outBpp;
          }
        }
        return outData;
      }, "bitpacker");
      function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
        pxData.copy(rawData, rawPos, pxPos, pxPos + byteWidth);
      }
      __name(filterNone, "filterNone");
      function filterSumNone(pxData, pxPos, byteWidth) {
        var sum = 0;
        var length = pxPos + byteWidth;
        for (var i = pxPos; i < length; i++) {
          sum += Math.abs(pxData[i]);
        }
        return sum;
      }
      __name(filterSumNone, "filterSumNone");
      function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
        for (var x = 0; x < byteWidth; x++) {
          var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
          var val = pxData[pxPos + x] - left;
          rawData[rawPos + x] = val;
        }
      }
      __name(filterSub, "filterSub");
      function filterSumSub(pxData, pxPos, byteWidth, bpp) {
        var sum = 0;
        for (var x = 0; x < byteWidth; x++) {
          var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
          var val = pxData[pxPos + x] - left;
          sum += Math.abs(val);
        }
        return sum;
      }
      __name(filterSumSub, "filterSumSub");
      function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
        for (var x = 0; x < byteWidth; x++) {
          var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
          var val = pxData[pxPos + x] - up;
          rawData[rawPos + x] = val;
        }
      }
      __name(filterUp, "filterUp");
      function filterSumUp(pxData, pxPos, byteWidth) {
        var sum = 0;
        var length = pxPos + byteWidth;
        for (var x = pxPos; x < length; x++) {
          var up = pxPos > 0 ? pxData[x - byteWidth] : 0;
          var val = pxData[x] - up;
          sum += Math.abs(val);
        }
        return sum;
      }
      __name(filterSumUp, "filterSumUp");
      function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
        for (var x = 0; x < byteWidth; x++) {
          var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
          var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
          var val = pxData[pxPos + x] - (left + up >> 1);
          rawData[rawPos + x] = val;
        }
      }
      __name(filterAvg, "filterAvg");
      function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
        var sum = 0;
        for (var x = 0; x < byteWidth; x++) {
          var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
          var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
          var val = pxData[pxPos + x] - (left + up >> 1);
          sum += Math.abs(val);
        }
        return sum;
      }
      __name(filterSumAvg, "filterSumAvg");
      function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
        for (var x = 0; x < byteWidth; x++) {
          var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
          var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
          var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
          var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
          rawData[rawPos + x] = val;
        }
      }
      __name(filterPaeth, "filterPaeth");
      function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
        var sum = 0;
        for (var x = 0; x < byteWidth; x++) {
          var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
          var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
          var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
          var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
          sum += Math.abs(val);
        }
        return sum;
      }
      __name(filterSumPaeth, "filterSumPaeth");
      var filters = {
        0: filterNone,
        1: filterSub,
        2: filterUp,
        3: filterAvg,
        4: filterPaeth
      };
      var filterSums = {
        0: filterSumNone,
        1: filterSumSub,
        2: filterSumUp,
        3: filterSumAvg,
        4: filterSumPaeth
      };
      var filterPack = /* @__PURE__ */ __name(function(pxData, width, height, options, bpp) {
        var filterTypes;
        if (!("filterType" in options) || options.filterType === -1) {
          filterTypes = [0, 1, 2, 3, 4];
        } else if (typeof options.filterType === "number") {
          filterTypes = [options.filterType];
        } else {
          throw new Error("unrecognised filter types");
        }
        if (options.bitDepth === 16)
          bpp *= 2;
        var byteWidth = width * bpp;
        var rawPos = 0;
        var pxPos = 0;
        var rawData = new Buffer((byteWidth + 1) * height);
        var sel = filterTypes[0];
        for (var y = 0; y < height; y++) {
          if (filterTypes.length > 1) {
            var min = Infinity;
            for (var i = 0; i < filterTypes.length; i++) {
              var sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
              if (sum < min) {
                sel = filterTypes[i];
                min = sum;
              }
            }
          }
          rawData[rawPos] = sel;
          rawPos++;
          filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
          rawPos += byteWidth;
          pxPos += byteWidth;
        }
        return rawData;
      }, "filterPack");
      var packer = createCommonjsModule(function(module3) {
        var Packer = module3.exports = function(options) {
          this._options = options;
          options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
          options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
          options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
          options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
          options.deflateFactory = options.deflateFactory || zlib__default["default"].createDeflate;
          options.bitDepth = options.bitDepth || 8;
          options.colorType = typeof options.colorType === "number" ? options.colorType : constants.COLORTYPE_COLOR_ALPHA;
          options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants.COLORTYPE_COLOR_ALPHA;
          if ([
            constants.COLORTYPE_GRAYSCALE,
            constants.COLORTYPE_COLOR,
            constants.COLORTYPE_COLOR_ALPHA,
            constants.COLORTYPE_ALPHA
          ].indexOf(options.colorType) === -1) {
            throw new Error("option color type:" + options.colorType + " is not supported at present");
          }
          if ([
            constants.COLORTYPE_GRAYSCALE,
            constants.COLORTYPE_COLOR,
            constants.COLORTYPE_COLOR_ALPHA,
            constants.COLORTYPE_ALPHA
          ].indexOf(options.inputColorType) === -1) {
            throw new Error("option input color type:" + options.inputColorType + " is not supported at present");
          }
          if (options.bitDepth !== 8 && options.bitDepth !== 16) {
            throw new Error("option bit depth:" + options.bitDepth + " is not supported at present");
          }
        };
        Packer.prototype.getDeflateOptions = function() {
          return {
            chunkSize: this._options.deflateChunkSize,
            level: this._options.deflateLevel,
            strategy: this._options.deflateStrategy
          };
        };
        Packer.prototype.createDeflate = function() {
          return this._options.deflateFactory(this.getDeflateOptions());
        };
        Packer.prototype.filterData = function(data, width, height) {
          var packedData = bitpacker(data, width, height, this._options);
          var bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
          var filteredData = filterPack(packedData, width, height, this._options, bpp);
          return filteredData;
        };
        Packer.prototype._packChunk = function(type, data) {
          var len = data ? data.length : 0;
          var buf = new Buffer(len + 12);
          buf.writeUInt32BE(len, 0);
          buf.writeUInt32BE(type, 4);
          if (data) {
            data.copy(buf, 8);
          }
          buf.writeInt32BE(crc.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
          return buf;
        };
        Packer.prototype.packGAMA = function(gamma) {
          var buf = new Buffer(4);
          buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
          return this._packChunk(constants.TYPE_gAMA, buf);
        };
        Packer.prototype.packIHDR = function(width, height) {
          var buf = new Buffer(13);
          buf.writeUInt32BE(width, 0);
          buf.writeUInt32BE(height, 4);
          buf[8] = this._options.bitDepth;
          buf[9] = this._options.colorType;
          buf[10] = 0;
          buf[11] = 0;
          buf[12] = 0;
          return this._packChunk(constants.TYPE_IHDR, buf);
        };
        Packer.prototype.packIDAT = function(data) {
          return this._packChunk(constants.TYPE_IDAT, data);
        };
        Packer.prototype.packIEND = function() {
          return this._packChunk(constants.TYPE_IEND, null);
        };
      });
      var packerAsync = createCommonjsModule(function(module3) {
        var PackerAsync = module3.exports = function(opt) {
          Stream__default["default"].call(this);
          var options = opt || {};
          this._packer = new packer(options);
          this._deflate = this._packer.createDeflate();
          this.readable = true;
        };
        util__default["default"].inherits(PackerAsync, Stream__default["default"]);
        PackerAsync.prototype.pack = function(data, width, height, gamma) {
          this.emit("data", new Buffer(constants.PNG_SIGNATURE));
          this.emit("data", this._packer.packIHDR(width, height));
          if (gamma) {
            this.emit("data", this._packer.packGAMA(gamma));
          }
          var filteredData = this._packer.filterData(data, width, height);
          this._deflate.on("error", this.emit.bind(this, "error"));
          this._deflate.on("data", function(compressedData) {
            this.emit("data", this._packer.packIDAT(compressedData));
          }.bind(this));
          this._deflate.on("end", function() {
            this.emit("data", this._packer.packIEND());
            this.emit("end");
          }.bind(this));
          this._deflate.end(filteredData);
        };
      });
      var syncInflate = createCommonjsModule(function(module3, exports3) {
        var assert = require$$0__default$1["default"].ok;
        var kMaxLength = require$$1__default["default"].kMaxLength;
        function Inflate(opts) {
          if (!(this instanceof Inflate)) {
            return new Inflate(opts);
          }
          if (opts && opts.chunkSize < zlib__default["default"].Z_MIN_CHUNK) {
            opts.chunkSize = zlib__default["default"].Z_MIN_CHUNK;
          }
          zlib__default["default"].Inflate.call(this, opts);
          if (opts && opts.maxLength != null) {
            this._maxLength = opts.maxLength;
          }
        }
        __name(Inflate, "Inflate");
        function createInflate(opts) {
          return new Inflate(opts);
        }
        __name(createInflate, "createInflate");
        function _close(engine, callback) {
          if (callback) {
            process.nextTick(callback);
          }
          if (!engine._handle) {
            return;
          }
          engine._handle.close();
          engine._handle = null;
        }
        __name(_close, "_close");
        Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
          if (typeof asyncCb === "function") {
            return zlib__default["default"].Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
          }
          var self2 = this;
          var availInBefore = chunk && chunk.length;
          var availOutBefore = this._chunkSize - this._offset;
          var leftToInflate = this._maxLength;
          var inOff = 0;
          var buffers = [];
          var nread = 0;
          var error;
          this.on("error", function(err) {
            error = err;
          });
          function handleChunk(availInAfter, availOutAfter) {
            if (self2._hadError) {
              return;
            }
            var have = availOutBefore - availOutAfter;
            assert(have >= 0, "have should not go down");
            if (have > 0) {
              var out = self2._buffer.slice(self2._offset, self2._offset + have);
              self2._offset += have;
              if (out.length > leftToInflate) {
                out = out.slice(0, leftToInflate);
              }
              buffers.push(out);
              nread += out.length;
              leftToInflate -= out.length;
              if (leftToInflate === 0) {
                return false;
              }
            }
            if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
              availOutBefore = self2._chunkSize;
              self2._offset = 0;
              self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
            }
            if (availOutAfter === 0) {
              inOff += availInBefore - availInAfter;
              availInBefore = availInAfter;
              return true;
            }
            return false;
          }
          __name(handleChunk, "handleChunk");
          assert(this._handle, "zlib binding closed");
          do {
            var res = this._handle.writeSync(
              flushFlag,
              chunk,
              // in
              inOff,
              // in_off
              availInBefore,
              // in_len
              this._buffer,
              // out
              this._offset,
              //out_off
              availOutBefore
            );
          } while (!this._hadError && handleChunk(res[0], res[1]));
          if (this._hadError) {
            throw error;
          }
          if (nread >= kMaxLength) {
            _close(this);
            throw new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
          }
          var buf = Buffer.concat(buffers, nread);
          _close(this);
          return buf;
        };
        util__default["default"].inherits(Inflate, zlib__default["default"].Inflate);
        function zlibBufferSync(engine, buffer) {
          if (typeof buffer === "string") {
            buffer = Buffer.from(buffer);
          }
          if (!(buffer instanceof Buffer)) {
            throw new TypeError("Not a string or buffer");
          }
          var flushFlag = engine._finishFlushFlag;
          if (flushFlag == null) {
            flushFlag = zlib__default["default"].Z_FINISH;
          }
          return engine._processChunk(buffer, flushFlag);
        }
        __name(zlibBufferSync, "zlibBufferSync");
        function inflateSync(buffer, opts) {
          return zlibBufferSync(new Inflate(opts), buffer);
        }
        __name(inflateSync, "inflateSync");
        module3.exports = exports3 = inflateSync;
        exports3.Inflate = Inflate;
        exports3.createInflate = createInflate;
        exports3.inflateSync = inflateSync;
      });
      var syncReader = createCommonjsModule(function(module3) {
        var SyncReader = module3.exports = function(buffer) {
          this._buffer = buffer;
          this._reads = [];
        };
        SyncReader.prototype.read = function(length, callback) {
          this._reads.push({
            length: Math.abs(length),
            // if length < 0 then at most this length
            allowLess: length < 0,
            func: callback
          });
        };
        SyncReader.prototype.process = function() {
          while (this._reads.length > 0 && this._buffer.length) {
            var read2 = this._reads[0];
            if (this._buffer.length && (this._buffer.length >= read2.length || read2.allowLess)) {
              this._reads.shift();
              var buf = this._buffer;
              this._buffer = buf.slice(read2.length);
              read2.func.call(this, buf.slice(0, read2.length));
            } else {
              break;
            }
          }
          if (this._reads.length > 0) {
            return new Error("There are some read requests waitng on finished stream");
          }
          if (this._buffer.length > 0) {
            return new Error("unrecognised content at end of stream");
          }
        };
      });
      var process$1 = /* @__PURE__ */ __name(function(inBuffer, bitmapInfo) {
        var outBuffers = [];
        var reader = new syncReader(inBuffer);
        var filter = new filterParse(bitmapInfo, {
          read: reader.read.bind(reader),
          write: function(bufferPart) {
            outBuffers.push(bufferPart);
          },
          complete: function() {
          }
        });
        filter.start();
        reader.process();
        return Buffer.concat(outBuffers);
      }, "process$1");
      var filterParseSync = {
        process: process$1
      };
      var hasSyncZlib$1 = true;
      if (!zlib__default["default"].deflateSync) {
        hasSyncZlib$1 = false;
      }
      var parserSync = /* @__PURE__ */ __name(function(buffer, options) {
        if (!hasSyncZlib$1) {
          throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
        }
        var err;
        function handleError(_err_) {
          err = _err_;
        }
        __name(handleError, "handleError");
        var metaData;
        function handleMetaData(_metaData_) {
          metaData = _metaData_;
        }
        __name(handleMetaData, "handleMetaData");
        function handleTransColor(transColor) {
          metaData.transColor = transColor;
        }
        __name(handleTransColor, "handleTransColor");
        function handlePalette(palette) {
          metaData.palette = palette;
        }
        __name(handlePalette, "handlePalette");
        var gamma;
        function handleGamma(_gamma_) {
          gamma = _gamma_;
        }
        __name(handleGamma, "handleGamma");
        var inflateDataList = [];
        function handleInflateData(inflatedData2) {
          inflateDataList.push(inflatedData2);
        }
        __name(handleInflateData, "handleInflateData");
        var reader = new syncReader(buffer);
        var parser$1 = new parser(options, {
          read: reader.read.bind(reader),
          error: handleError,
          metadata: handleMetaData,
          gamma: handleGamma,
          palette: handlePalette,
          transColor: handleTransColor,
          inflateData: handleInflateData
        });
        parser$1.start();
        reader.process();
        if (err) {
          throw err;
        }
        var inflateData = Buffer.concat(inflateDataList);
        inflateDataList.length = 0;
        var inflatedData;
        if (metaData.interlace) {
          inflatedData = zlib__default["default"].inflateSync(inflateData);
        } else {
          var rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
          var imageSize = rowSize * metaData.height;
          inflatedData = syncInflate(inflateData, { chunkSize: imageSize, maxLength: imageSize });
        }
        inflateData = null;
        if (!inflatedData || !inflatedData.length) {
          throw new Error("bad png - invalid inflate data response");
        }
        var unfilteredData = filterParseSync.process(inflatedData, metaData);
        inflateData = null;
        var bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
        unfilteredData = null;
        var normalisedBitmapData = formatNormaliser(bitmapData, metaData);
        metaData.data = normalisedBitmapData;
        metaData.gamma = gamma || 0;
        return metaData;
      }, "parserSync");
      var hasSyncZlib = true;
      if (!zlib__default["default"].deflateSync) {
        hasSyncZlib = false;
      }
      var packerSync = /* @__PURE__ */ __name(function(metaData, opt) {
        if (!hasSyncZlib) {
          throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
        }
        var options = opt || {};
        var packer$1 = new packer(options);
        var chunks = [];
        chunks.push(new Buffer(constants.PNG_SIGNATURE));
        chunks.push(packer$1.packIHDR(metaData.width, metaData.height));
        if (metaData.gamma) {
          chunks.push(packer$1.packGAMA(metaData.gamma));
        }
        var filteredData = packer$1.filterData(metaData.data, metaData.width, metaData.height);
        var compressedData = zlib__default["default"].deflateSync(filteredData, packer$1.getDeflateOptions());
        filteredData = null;
        if (!compressedData || !compressedData.length) {
          throw new Error("bad png - invalid compressed data response");
        }
        chunks.push(packer$1.packIDAT(compressedData));
        chunks.push(packer$1.packIEND());
        return Buffer.concat(chunks);
      }, "packerSync");
      var read = /* @__PURE__ */ __name(function(buffer, options) {
        return parserSync(buffer, options || {});
      }, "read");
      var write = /* @__PURE__ */ __name(function(png2, options) {
        return packerSync(png2, options);
      }, "write");
      var pngSync = {
        read,
        write
      };
      var png = createCommonjsModule(function(module3, exports3) {
        var PNG = exports3.PNG = function(options) {
          Stream__default["default"].call(this);
          options = options || {};
          this.width = options.width | 0;
          this.height = options.height | 0;
          this.data = this.width > 0 && this.height > 0 ? new Buffer(4 * this.width * this.height) : null;
          if (options.fill && this.data) {
            this.data.fill(0);
          }
          this.gamma = 0;
          this.readable = this.writable = true;
          this._parser = new parserAsync(options);
          this._parser.on("error", this.emit.bind(this, "error"));
          this._parser.on("close", this._handleClose.bind(this));
          this._parser.on("metadata", this._metadata.bind(this));
          this._parser.on("gamma", this._gamma.bind(this));
          this._parser.on("parsed", function(data) {
            this.data = data;
            this.emit("parsed", data);
          }.bind(this));
          this._packer = new packerAsync(options);
          this._packer.on("data", this.emit.bind(this, "data"));
          this._packer.on("end", this.emit.bind(this, "end"));
          this._parser.on("close", this._handleClose.bind(this));
          this._packer.on("error", this.emit.bind(this, "error"));
        };
        util__default["default"].inherits(PNG, Stream__default["default"]);
        PNG.sync = pngSync;
        PNG.prototype.pack = function() {
          if (!this.data || !this.data.length) {
            this.emit("error", "No data provided");
            return this;
          }
          process.nextTick(function() {
            this._packer.pack(this.data, this.width, this.height, this.gamma);
          }.bind(this));
          return this;
        };
        PNG.prototype.parse = function(data, callback) {
          if (callback) {
            var onParsed, onError;
            onParsed = function(parsedData) {
              this.removeListener("error", onError);
              this.data = parsedData;
              callback(null, this);
            }.bind(this);
            onError = function(err) {
              this.removeListener("parsed", onParsed);
              callback(err, null);
            }.bind(this);
            this.once("parsed", onParsed);
            this.once("error", onError);
          }
          this.end(data);
          return this;
        };
        PNG.prototype.write = function(data) {
          this._parser.write(data);
          return true;
        };
        PNG.prototype.end = function(data) {
          this._parser.end(data);
        };
        PNG.prototype._metadata = function(metadata) {
          this.width = metadata.width;
          this.height = metadata.height;
          this.emit("metadata", metadata);
        };
        PNG.prototype._gamma = function(gamma) {
          this.gamma = gamma;
        };
        PNG.prototype._handleClose = function() {
          if (!this._parser.writable && !this._packer.readable) {
            this.emit("close");
          }
        };
        PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
          srcX |= 0;
          srcY |= 0;
          width |= 0;
          height |= 0;
          deltaX |= 0;
          deltaY |= 0;
          if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
            throw new Error("bitblt reading outside image");
          }
          if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
            throw new Error("bitblt writing outside image");
          }
          for (var y = 0; y < height; y++) {
            src.data.copy(
              dst.data,
              (deltaY + y) * dst.width + deltaX << 2,
              (srcY + y) * src.width + srcX << 2,
              (srcY + y) * src.width + srcX + width << 2
            );
          }
        };
        PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
          PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
          return this;
        };
        PNG.adjustGamma = function(src) {
          if (src.gamma) {
            for (var y = 0; y < src.height; y++) {
              for (var x = 0; x < src.width; x++) {
                var idx = src.width * y + x << 2;
                for (var i = 0; i < 3; i++) {
                  var sample = src.data[idx + i] / 255;
                  sample = Math.pow(sample, 1 / 2.2 / src.gamma);
                  src.data[idx + i] = Math.round(sample * 255);
                }
              }
            }
            src.gamma = 0;
          }
        };
        PNG.prototype.adjustGamma = function() {
          PNG.adjustGamma(this);
        };
      });
      var encoder = createCommonjsModule(function(module3) {
        function JPEGEncoder(quality) {
          var ffloor = Math.floor;
          var YTable = new Array(64);
          var UVTable = new Array(64);
          var fdtbl_Y = new Array(64);
          var fdtbl_UV = new Array(64);
          var YDC_HT;
          var UVDC_HT;
          var YAC_HT;
          var UVAC_HT;
          var bitcode = new Array(65535);
          var category = new Array(65535);
          var outputfDCTQuant = new Array(64);
          var DU = new Array(64);
          var byteout = [];
          var bytenew = 0;
          var bytepos = 7;
          var YDU = new Array(64);
          var UDU = new Array(64);
          var VDU = new Array(64);
          var clt = new Array(256);
          var RGB_YUV_TABLE = new Array(2048);
          var currentQuality;
          var ZigZag = [
            0,
            1,
            5,
            6,
            14,
            15,
            27,
            28,
            2,
            4,
            7,
            13,
            16,
            26,
            29,
            42,
            3,
            8,
            12,
            17,
            25,
            30,
            41,
            43,
            9,
            11,
            18,
            24,
            31,
            40,
            44,
            53,
            10,
            19,
            23,
            32,
            39,
            45,
            52,
            54,
            20,
            22,
            33,
            38,
            46,
            51,
            55,
            60,
            21,
            34,
            37,
            47,
            50,
            56,
            59,
            61,
            35,
            36,
            48,
            49,
            57,
            58,
            62,
            63
          ];
          var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
          var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
          var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
          var std_ac_luminance_values = [
            1,
            2,
            3,
            0,
            4,
            17,
            5,
            18,
            33,
            49,
            65,
            6,
            19,
            81,
            97,
            7,
            34,
            113,
            20,
            50,
            129,
            145,
            161,
            8,
            35,
            66,
            177,
            193,
            21,
            82,
            209,
            240,
            36,
            51,
            98,
            114,
            130,
            9,
            10,
            22,
            23,
            24,
            25,
            26,
            37,
            38,
            39,
            40,
            41,
            42,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            131,
            132,
            133,
            134,
            135,
            136,
            137,
            138,
            146,
            147,
            148,
            149,
            150,
            151,
            152,
            153,
            154,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            178,
            179,
            180,
            181,
            182,
            183,
            184,
            185,
            186,
            194,
            195,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            210,
            211,
            212,
            213,
            214,
            215,
            216,
            217,
            218,
            225,
            226,
            227,
            228,
            229,
            230,
            231,
            232,
            233,
            234,
            241,
            242,
            243,
            244,
            245,
            246,
            247,
            248,
            249,
            250
          ];
          var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
          var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
          var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
          var std_ac_chrominance_values = [
            0,
            1,
            2,
            3,
            17,
            4,
            5,
            33,
            49,
            6,
            18,
            65,
            81,
            7,
            97,
            113,
            19,
            34,
            50,
            129,
            8,
            20,
            66,
            145,
            161,
            177,
            193,
            9,
            35,
            51,
            82,
            240,
            21,
            98,
            114,
            209,
            10,
            22,
            36,
            52,
            225,
            37,
            241,
            23,
            24,
            25,
            26,
            38,
            39,
            40,
            41,
            42,
            53,
            54,
            55,
            56,
            57,
            58,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            130,
            131,
            132,
            133,
            134,
            135,
            136,
            137,
            138,
            146,
            147,
            148,
            149,
            150,
            151,
            152,
            153,
            154,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            178,
            179,
            180,
            181,
            182,
            183,
            184,
            185,
            186,
            194,
            195,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            210,
            211,
            212,
            213,
            214,
            215,
            216,
            217,
            218,
            226,
            227,
            228,
            229,
            230,
            231,
            232,
            233,
            234,
            242,
            243,
            244,
            245,
            246,
            247,
            248,
            249,
            250
          ];
          function initQuantTables(sf) {
            var YQT = [
              16,
              11,
              10,
              16,
              24,
              40,
              51,
              61,
              12,
              12,
              14,
              19,
              26,
              58,
              60,
              55,
              14,
              13,
              16,
              24,
              40,
              57,
              69,
              56,
              14,
              17,
              22,
              29,
              51,
              87,
              80,
              62,
              18,
              22,
              37,
              56,
              68,
              109,
              103,
              77,
              24,
              35,
              55,
              64,
              81,
              104,
              113,
              92,
              49,
              64,
              78,
              87,
              103,
              121,
              120,
              101,
              72,
              92,
              95,
              98,
              112,
              100,
              103,
              99
            ];
            for (var i = 0; i < 64; i++) {
              var t = ffloor((YQT[i] * sf + 50) / 100);
              if (t < 1) {
                t = 1;
              } else if (t > 255) {
                t = 255;
              }
              YTable[ZigZag[i]] = t;
            }
            var UVQT = [
              17,
              18,
              24,
              47,
              99,
              99,
              99,
              99,
              18,
              21,
              26,
              66,
              99,
              99,
              99,
              99,
              24,
              26,
              56,
              99,
              99,
              99,
              99,
              99,
              47,
              66,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99,
              99
            ];
            for (var j = 0; j < 64; j++) {
              var u = ffloor((UVQT[j] * sf + 50) / 100);
              if (u < 1) {
                u = 1;
              } else if (u > 255) {
                u = 255;
              }
              UVTable[ZigZag[j]] = u;
            }
            var aasf = [
              1,
              1.387039845,
              1.306562965,
              1.175875602,
              1,
              0.785694958,
              0.5411961,
              0.275899379
            ];
            var k = 0;
            for (var row = 0; row < 8; row++) {
              for (var col = 0; col < 8; col++) {
                fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
                fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
                k++;
              }
            }
          }
          __name(initQuantTables, "initQuantTables");
          function computeHuffmanTbl(nrcodes, std_table) {
            var codevalue = 0;
            var pos_in_table = 0;
            var HT = new Array();
            for (var k = 1; k <= 16; k++) {
              for (var j = 1; j <= nrcodes[k]; j++) {
                HT[std_table[pos_in_table]] = [];
                HT[std_table[pos_in_table]][0] = codevalue;
                HT[std_table[pos_in_table]][1] = k;
                pos_in_table++;
                codevalue++;
              }
              codevalue *= 2;
            }
            return HT;
          }
          __name(computeHuffmanTbl, "computeHuffmanTbl");
          function initHuffmanTbl() {
            YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
            UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
            YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
            UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
          }
          __name(initHuffmanTbl, "initHuffmanTbl");
          function initCategoryNumber() {
            var nrlower = 1;
            var nrupper = 2;
            for (var cat = 1; cat <= 15; cat++) {
              for (var nr = nrlower; nr < nrupper; nr++) {
                category[32767 + nr] = cat;
                bitcode[32767 + nr] = [];
                bitcode[32767 + nr][1] = cat;
                bitcode[32767 + nr][0] = nr;
              }
              for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
                category[32767 + nrneg] = cat;
                bitcode[32767 + nrneg] = [];
                bitcode[32767 + nrneg][1] = cat;
                bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
              }
              nrlower <<= 1;
              nrupper <<= 1;
            }
          }
          __name(initCategoryNumber, "initCategoryNumber");
          function initRGBYUVTable() {
            for (var i = 0; i < 256; i++) {
              RGB_YUV_TABLE[i] = 19595 * i;
              RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;
              RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 32768;
              RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;
              RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;
              RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 8421375;
              RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;
              RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
            }
          }
          __name(initRGBYUVTable, "initRGBYUVTable");
          function writeBits(bs) {
            var value = bs[0];
            var posval = bs[1] - 1;
            while (posval >= 0) {
              if (value & 1 << posval) {
                bytenew |= 1 << bytepos;
              }
              posval--;
              bytepos--;
              if (bytepos < 0) {
                if (bytenew == 255) {
                  writeByte(255);
                  writeByte(0);
                } else {
                  writeByte(bytenew);
                }
                bytepos = 7;
                bytenew = 0;
              }
            }
          }
          __name(writeBits, "writeBits");
          function writeByte(value) {
            byteout.push(value);
          }
          __name(writeByte, "writeByte");
          function writeWord(value) {
            writeByte(value >> 8 & 255);
            writeByte(value & 255);
          }
          __name(writeWord, "writeWord");
          function fDCTQuant(data, fdtbl) {
            var d0, d1, d2, d3, d4, d5, d6, d7;
            var dataOff = 0;
            var i;
            var I8 = 8;
            var I64 = 64;
            for (i = 0; i < I8; ++i) {
              d0 = data[dataOff];
              d1 = data[dataOff + 1];
              d2 = data[dataOff + 2];
              d3 = data[dataOff + 3];
              d4 = data[dataOff + 4];
              d5 = data[dataOff + 5];
              d6 = data[dataOff + 6];
              d7 = data[dataOff + 7];
              var tmp0 = d0 + d7;
              var tmp7 = d0 - d7;
              var tmp1 = d1 + d6;
              var tmp6 = d1 - d6;
              var tmp2 = d2 + d5;
              var tmp5 = d2 - d5;
              var tmp3 = d3 + d4;
              var tmp4 = d3 - d4;
              var tmp10 = tmp0 + tmp3;
              var tmp13 = tmp0 - tmp3;
              var tmp11 = tmp1 + tmp2;
              var tmp12 = tmp1 - tmp2;
              data[dataOff] = tmp10 + tmp11;
              data[dataOff + 4] = tmp10 - tmp11;
              var z1 = (tmp12 + tmp13) * 0.707106781;
              data[dataOff + 2] = tmp13 + z1;
              data[dataOff + 6] = tmp13 - z1;
              tmp10 = tmp4 + tmp5;
              tmp11 = tmp5 + tmp6;
              tmp12 = tmp6 + tmp7;
              var z5 = (tmp10 - tmp12) * 0.382683433;
              var z2 = 0.5411961 * tmp10 + z5;
              var z4 = 1.306562965 * tmp12 + z5;
              var z3 = tmp11 * 0.707106781;
              var z11 = tmp7 + z3;
              var z13 = tmp7 - z3;
              data[dataOff + 5] = z13 + z2;
              data[dataOff + 3] = z13 - z2;
              data[dataOff + 1] = z11 + z4;
              data[dataOff + 7] = z11 - z4;
              dataOff += 8;
            }
            dataOff = 0;
            for (i = 0; i < I8; ++i) {
              d0 = data[dataOff];
              d1 = data[dataOff + 8];
              d2 = data[dataOff + 16];
              d3 = data[dataOff + 24];
              d4 = data[dataOff + 32];
              d5 = data[dataOff + 40];
              d6 = data[dataOff + 48];
              d7 = data[dataOff + 56];
              var tmp0p2 = d0 + d7;
              var tmp7p2 = d0 - d7;
              var tmp1p2 = d1 + d6;
              var tmp6p2 = d1 - d6;
              var tmp2p2 = d2 + d5;
              var tmp5p2 = d2 - d5;
              var tmp3p2 = d3 + d4;
              var tmp4p2 = d3 - d4;
              var tmp10p2 = tmp0p2 + tmp3p2;
              var tmp13p2 = tmp0p2 - tmp3p2;
              var tmp11p2 = tmp1p2 + tmp2p2;
              var tmp12p2 = tmp1p2 - tmp2p2;
              data[dataOff] = tmp10p2 + tmp11p2;
              data[dataOff + 32] = tmp10p2 - tmp11p2;
              var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
              data[dataOff + 16] = tmp13p2 + z1p2;
              data[dataOff + 48] = tmp13p2 - z1p2;
              tmp10p2 = tmp4p2 + tmp5p2;
              tmp11p2 = tmp5p2 + tmp6p2;
              tmp12p2 = tmp6p2 + tmp7p2;
              var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
              var z2p2 = 0.5411961 * tmp10p2 + z5p2;
              var z4p2 = 1.306562965 * tmp12p2 + z5p2;
              var z3p2 = tmp11p2 * 0.707106781;
              var z11p2 = tmp7p2 + z3p2;
              var z13p2 = tmp7p2 - z3p2;
              data[dataOff + 40] = z13p2 + z2p2;
              data[dataOff + 24] = z13p2 - z2p2;
              data[dataOff + 8] = z11p2 + z4p2;
              data[dataOff + 56] = z11p2 - z4p2;
              dataOff++;
            }
            var fDCTQuant2;
            for (i = 0; i < I64; ++i) {
              fDCTQuant2 = data[i] * fdtbl[i];
              outputfDCTQuant[i] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
            }
            return outputfDCTQuant;
          }
          __name(fDCTQuant, "fDCTQuant");
          function writeAPP0() {
            writeWord(65504);
            writeWord(16);
            writeByte(74);
            writeByte(70);
            writeByte(73);
            writeByte(70);
            writeByte(0);
            writeByte(1);
            writeByte(1);
            writeByte(0);
            writeWord(1);
            writeWord(1);
            writeByte(0);
            writeByte(0);
          }
          __name(writeAPP0, "writeAPP0");
          function writeAPP1(exifBuffer) {
            if (!exifBuffer)
              return;
            writeWord(65505);
            if (exifBuffer[0] === 69 && exifBuffer[1] === 120 && exifBuffer[2] === 105 && exifBuffer[3] === 102) {
              writeWord(exifBuffer.length + 2);
            } else {
              writeWord(exifBuffer.length + 5 + 2);
              writeByte(69);
              writeByte(120);
              writeByte(105);
              writeByte(102);
              writeByte(0);
            }
            for (var i = 0; i < exifBuffer.length; i++) {
              writeByte(exifBuffer[i]);
            }
          }
          __name(writeAPP1, "writeAPP1");
          function writeSOF0(width, height) {
            writeWord(65472);
            writeWord(17);
            writeByte(8);
            writeWord(height);
            writeWord(width);
            writeByte(3);
            writeByte(1);
            writeByte(17);
            writeByte(0);
            writeByte(2);
            writeByte(17);
            writeByte(1);
            writeByte(3);
            writeByte(17);
            writeByte(1);
          }
          __name(writeSOF0, "writeSOF0");
          function writeDQT() {
            writeWord(65499);
            writeWord(132);
            writeByte(0);
            for (var i = 0; i < 64; i++) {
              writeByte(YTable[i]);
            }
            writeByte(1);
            for (var j = 0; j < 64; j++) {
              writeByte(UVTable[j]);
            }
          }
          __name(writeDQT, "writeDQT");
          function writeDHT() {
            writeWord(65476);
            writeWord(418);
            writeByte(0);
            for (var i = 0; i < 16; i++) {
              writeByte(std_dc_luminance_nrcodes[i + 1]);
            }
            for (var j = 0; j <= 11; j++) {
              writeByte(std_dc_luminance_values[j]);
            }
            writeByte(16);
            for (var k = 0; k < 16; k++) {
              writeByte(std_ac_luminance_nrcodes[k + 1]);
            }
            for (var l = 0; l <= 161; l++) {
              writeByte(std_ac_luminance_values[l]);
            }
            writeByte(1);
            for (var m = 0; m < 16; m++) {
              writeByte(std_dc_chrominance_nrcodes[m + 1]);
            }
            for (var n = 0; n <= 11; n++) {
              writeByte(std_dc_chrominance_values[n]);
            }
            writeByte(17);
            for (var o = 0; o < 16; o++) {
              writeByte(std_ac_chrominance_nrcodes[o + 1]);
            }
            for (var p = 0; p <= 161; p++) {
              writeByte(std_ac_chrominance_values[p]);
            }
          }
          __name(writeDHT, "writeDHT");
          function writeSOS() {
            writeWord(65498);
            writeWord(12);
            writeByte(3);
            writeByte(1);
            writeByte(0);
            writeByte(2);
            writeByte(17);
            writeByte(3);
            writeByte(17);
            writeByte(0);
            writeByte(63);
            writeByte(0);
          }
          __name(writeSOS, "writeSOS");
          function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
            var EOB = HTAC[0];
            var M16zeroes = HTAC[240];
            var pos;
            var I16 = 16;
            var I63 = 63;
            var I64 = 64;
            var DU_DCT = fDCTQuant(CDU, fdtbl);
            for (var j = 0; j < I64; ++j) {
              DU[ZigZag[j]] = DU_DCT[j];
            }
            var Diff = DU[0] - DC;
            DC = DU[0];
            if (Diff == 0) {
              writeBits(HTDC[0]);
            } else {
              pos = 32767 + Diff;
              writeBits(HTDC[category[pos]]);
              writeBits(bitcode[pos]);
            }
            var end0pos = 63;
            for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {
            }
            if (end0pos == 0) {
              writeBits(EOB);
              return DC;
            }
            var i = 1;
            var lng;
            while (i <= end0pos) {
              var startpos = i;
              for (; DU[i] == 0 && i <= end0pos; ++i) {
              }
              var nrzeroes = i - startpos;
              if (nrzeroes >= I16) {
                lng = nrzeroes >> 4;
                for (var nrmarker = 1; nrmarker <= lng; ++nrmarker)
                  writeBits(M16zeroes);
                nrzeroes = nrzeroes & 15;
              }
              pos = 32767 + DU[i];
              writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
              writeBits(bitcode[pos]);
              i++;
            }
            if (end0pos != I63) {
              writeBits(EOB);
            }
            return DC;
          }
          __name(processDU, "processDU");
          function initCharLookupTable() {
            var sfcc = String.fromCharCode;
            for (var i = 0; i < 256; i++) {
              clt[i] = sfcc(i);
            }
          }
          __name(initCharLookupTable, "initCharLookupTable");
          this.encode = function(image, quality2) {
            (/* @__PURE__ */ new Date()).getTime();
            if (quality2)
              setQuality(quality2);
            byteout = new Array();
            bytenew = 0;
            bytepos = 7;
            writeWord(65496);
            writeAPP0();
            writeAPP1(image.exifBuffer);
            writeDQT();
            writeSOF0(image.width, image.height);
            writeDHT();
            writeSOS();
            var DCY = 0;
            var DCU = 0;
            var DCV = 0;
            bytenew = 0;
            bytepos = 7;
            this.encode.displayName = "_encode_";
            var imageData = image.data;
            var width = image.width;
            var height = image.height;
            var quadWidth = width * 4;
            var x, y = 0;
            var r, g, b;
            var start, p, col, row, pos;
            while (y < height) {
              x = 0;
              while (x < quadWidth) {
                start = quadWidth * y + x;
                p = start;
                col = -1;
                row = 0;
                for (pos = 0; pos < 64; pos++) {
                  row = pos >> 3;
                  col = (pos & 7) * 4;
                  p = start + row * quadWidth + col;
                  if (y + row >= height) {
                    p -= quadWidth * (y + 1 + row - height);
                  }
                  if (x + col >= quadWidth) {
                    p -= x + col - quadWidth + 4;
                  }
                  r = imageData[p++];
                  g = imageData[p++];
                  b = imageData[p++];
                  YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
                  UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
                  VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
                }
                DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
                DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
                DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
                x += 32;
              }
              y += 8;
            }
            if (bytepos >= 0) {
              var fillbits = [];
              fillbits[1] = bytepos + 1;
              fillbits[0] = (1 << bytepos + 1) - 1;
              writeBits(fillbits);
            }
            writeWord(65497);
            return new Buffer(byteout);
          };
          function setQuality(quality2) {
            if (quality2 <= 0) {
              quality2 = 1;
            }
            if (quality2 > 100) {
              quality2 = 100;
            }
            if (currentQuality == quality2)
              return;
            var sf = 0;
            if (quality2 < 50) {
              sf = Math.floor(5e3 / quality2);
            } else {
              sf = Math.floor(200 - quality2 * 2);
            }
            initQuantTables(sf);
            currentQuality = quality2;
          }
          __name(setQuality, "setQuality");
          function init() {
            var time_start = (/* @__PURE__ */ new Date()).getTime();
            if (!quality)
              quality = 50;
            initCharLookupTable();
            initHuffmanTbl();
            initCategoryNumber();
            initRGBYUVTable();
            setQuality(quality);
            (/* @__PURE__ */ new Date()).getTime() - time_start;
          }
          __name(init, "init");
          init();
        }
        __name(JPEGEncoder, "JPEGEncoder");
        {
          module3.exports = encode3;
        }
        function encode3(imgData, qu) {
          if (typeof qu === "undefined")
            qu = 50;
          var encoder2 = new JPEGEncoder(qu);
          var data = encoder2.encode(imgData, qu);
          return {
            data,
            width: imgData.width,
            height: imgData.height
          };
        }
        __name(encode3, "encode");
      });
      var decoder = createCommonjsModule(function(module3) {
        var JpegImage = (/* @__PURE__ */ __name(function jpegImage() {
          var dctZigZag = new Int32Array([
            0,
            1,
            8,
            16,
            9,
            2,
            3,
            10,
            17,
            24,
            32,
            25,
            18,
            11,
            4,
            5,
            12,
            19,
            26,
            33,
            40,
            48,
            41,
            34,
            27,
            20,
            13,
            6,
            7,
            14,
            21,
            28,
            35,
            42,
            49,
            56,
            57,
            50,
            43,
            36,
            29,
            22,
            15,
            23,
            30,
            37,
            44,
            51,
            58,
            59,
            52,
            45,
            38,
            31,
            39,
            46,
            53,
            60,
            61,
            54,
            47,
            55,
            62,
            63
          ]);
          var dctCos1 = 4017;
          var dctSin1 = 799;
          var dctCos3 = 3406;
          var dctSin3 = 2276;
          var dctCos6 = 1567;
          var dctSin6 = 3784;
          var dctSqrt2 = 5793;
          var dctSqrt1d2 = 2896;
          function constructor() {
          }
          __name(constructor, "constructor");
          function buildHuffmanTable(codeLengths, values) {
            var k = 0, code = [], i, j, length = 16;
            while (length > 0 && !codeLengths[length - 1])
              length--;
            code.push({ children: [], index: 0 });
            var p = code[0], q;
            for (i = 0; i < length; i++) {
              for (j = 0; j < codeLengths[i]; j++) {
                p = code.pop();
                p.children[p.index] = values[k];
                while (p.index > 0) {
                  if (code.length === 0)
                    throw new Error("Could not recreate Huffman Table");
                  p = code.pop();
                }
                p.index++;
                code.push(p);
                while (code.length <= i) {
                  code.push(q = { children: [], index: 0 });
                  p.children[p.index] = q.children;
                  p = q;
                }
                k++;
              }
              if (i + 1 < length) {
                code.push(q = { children: [], index: 0 });
                p.children[p.index] = q.children;
                p = q;
              }
            }
            return code[0].children;
          }
          __name(buildHuffmanTable, "buildHuffmanTable");
          function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
            frame.precision;
            frame.samplesPerLine;
            frame.scanLines;
            var mcusPerLine = frame.mcusPerLine;
            var progressive = frame.progressive;
            frame.maxH;
            frame.maxV;
            var startOffset = offset, bitsData = 0, bitsCount = 0;
            function readBit() {
              if (bitsCount > 0) {
                bitsCount--;
                return bitsData >> bitsCount & 1;
              }
              bitsData = data[offset++];
              if (bitsData == 255) {
                var nextByte = data[offset++];
                if (nextByte) {
                  throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
                }
              }
              bitsCount = 7;
              return bitsData >>> 7;
            }
            __name(readBit, "readBit");
            function decodeHuffman(tree) {
              var node = tree, bit;
              while ((bit = readBit()) !== null) {
                node = node[bit];
                if (typeof node === "number")
                  return node;
                if (typeof node !== "object")
                  throw new Error("invalid huffman sequence");
              }
              return null;
            }
            __name(decodeHuffman, "decodeHuffman");
            function receive(length) {
              var n2 = 0;
              while (length > 0) {
                var bit = readBit();
                if (bit === null)
                  return;
                n2 = n2 << 1 | bit;
                length--;
              }
              return n2;
            }
            __name(receive, "receive");
            function receiveAndExtend(length) {
              var n2 = receive(length);
              if (n2 >= 1 << length - 1)
                return n2;
              return n2 + (-1 << length) + 1;
            }
            __name(receiveAndExtend, "receiveAndExtend");
            function decodeBaseline(component2, zz) {
              var t = decodeHuffman(component2.huffmanTableDC);
              var diff = t === 0 ? 0 : receiveAndExtend(t);
              zz[0] = component2.pred += diff;
              var k2 = 1;
              while (k2 < 64) {
                var rs = decodeHuffman(component2.huffmanTableAC);
                var s = rs & 15, r = rs >> 4;
                if (s === 0) {
                  if (r < 15)
                    break;
                  k2 += 16;
                  continue;
                }
                k2 += r;
                var z = dctZigZag[k2];
                zz[z] = receiveAndExtend(s);
                k2++;
              }
            }
            __name(decodeBaseline, "decodeBaseline");
            function decodeDCFirst(component2, zz) {
              var t = decodeHuffman(component2.huffmanTableDC);
              var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
              zz[0] = component2.pred += diff;
            }
            __name(decodeDCFirst, "decodeDCFirst");
            function decodeDCSuccessive(component2, zz) {
              zz[0] |= readBit() << successive;
            }
            __name(decodeDCSuccessive, "decodeDCSuccessive");
            var eobrun = 0;
            function decodeACFirst(component2, zz) {
              if (eobrun > 0) {
                eobrun--;
                return;
              }
              var k2 = spectralStart, e = spectralEnd;
              while (k2 <= e) {
                var rs = decodeHuffman(component2.huffmanTableAC);
                var s = rs & 15, r = rs >> 4;
                if (s === 0) {
                  if (r < 15) {
                    eobrun = receive(r) + (1 << r) - 1;
                    break;
                  }
                  k2 += 16;
                  continue;
                }
                k2 += r;
                var z = dctZigZag[k2];
                zz[z] = receiveAndExtend(s) * (1 << successive);
                k2++;
              }
            }
            __name(decodeACFirst, "decodeACFirst");
            var successiveACState = 0, successiveACNextValue;
            function decodeACSuccessive(component2, zz) {
              var k2 = spectralStart, e = spectralEnd, r = 0;
              while (k2 <= e) {
                var z = dctZigZag[k2];
                var direction = zz[z] < 0 ? -1 : 1;
                switch (successiveACState) {
                  case 0:
                    var rs = decodeHuffman(component2.huffmanTableAC);
                    var s = rs & 15, r = rs >> 4;
                    if (s === 0) {
                      if (r < 15) {
                        eobrun = receive(r) + (1 << r);
                        successiveACState = 4;
                      } else {
                        r = 16;
                        successiveACState = 1;
                      }
                    } else {
                      if (s !== 1)
                        throw new Error("invalid ACn encoding");
                      successiveACNextValue = receiveAndExtend(s);
                      successiveACState = r ? 2 : 3;
                    }
                    continue;
                  case 1:
                  case 2:
                    if (zz[z])
                      zz[z] += (readBit() << successive) * direction;
                    else {
                      r--;
                      if (r === 0)
                        successiveACState = successiveACState == 2 ? 3 : 0;
                    }
                    break;
                  case 3:
                    if (zz[z])
                      zz[z] += (readBit() << successive) * direction;
                    else {
                      zz[z] = successiveACNextValue << successive;
                      successiveACState = 0;
                    }
                    break;
                  case 4:
                    if (zz[z])
                      zz[z] += (readBit() << successive) * direction;
                    break;
                }
                k2++;
              }
              if (successiveACState === 4) {
                eobrun--;
                if (eobrun === 0)
                  successiveACState = 0;
              }
            }
            __name(decodeACSuccessive, "decodeACSuccessive");
            function decodeMcu(component2, decode4, mcu2, row, col) {
              var mcuRow = mcu2 / mcusPerLine | 0;
              var mcuCol = mcu2 % mcusPerLine;
              var blockRow = mcuRow * component2.v + row;
              var blockCol = mcuCol * component2.h + col;
              if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
                return;
              decode4(component2, component2.blocks[blockRow][blockCol]);
            }
            __name(decodeMcu, "decodeMcu");
            function decodeBlock(component2, decode4, mcu2) {
              var blockRow = mcu2 / component2.blocksPerLine | 0;
              var blockCol = mcu2 % component2.blocksPerLine;
              if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
                return;
              decode4(component2, component2.blocks[blockRow][blockCol]);
            }
            __name(decodeBlock, "decodeBlock");
            var componentsLength = components.length;
            var component, i, j, k, n;
            var decodeFn;
            if (progressive) {
              if (spectralStart === 0)
                decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
              else
                decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
            } else {
              decodeFn = decodeBaseline;
            }
            var mcu = 0, marker;
            var mcuExpected;
            if (componentsLength == 1) {
              mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
            } else {
              mcuExpected = mcusPerLine * frame.mcusPerColumn;
            }
            if (!resetInterval)
              resetInterval = mcuExpected;
            var h, v;
            while (mcu < mcuExpected) {
              for (i = 0; i < componentsLength; i++)
                components[i].pred = 0;
              eobrun = 0;
              if (componentsLength == 1) {
                component = components[0];
                for (n = 0; n < resetInterval; n++) {
                  decodeBlock(component, decodeFn, mcu);
                  mcu++;
                }
              } else {
                for (n = 0; n < resetInterval; n++) {
                  for (i = 0; i < componentsLength; i++) {
                    component = components[i];
                    h = component.h;
                    v = component.v;
                    for (j = 0; j < v; j++) {
                      for (k = 0; k < h; k++) {
                        decodeMcu(component, decodeFn, mcu, j, k);
                      }
                    }
                  }
                  mcu++;
                  if (mcu === mcuExpected)
                    break;
                }
              }
              if (mcu === mcuExpected) {
                do {
                  if (data[offset] === 255) {
                    if (data[offset + 1] !== 0) {
                      break;
                    }
                  }
                  offset += 1;
                } while (offset < data.length - 2);
              }
              bitsCount = 0;
              marker = data[offset] << 8 | data[offset + 1];
              if (marker < 65280) {
                throw new Error("marker was not found");
              }
              if (marker >= 65488 && marker <= 65495) {
                offset += 2;
              } else
                break;
            }
            return offset - startOffset;
          }
          __name(decodeScan, "decodeScan");
          function buildComponentData(frame, component) {
            var lines = [];
            var blocksPerLine = component.blocksPerLine;
            var blocksPerColumn = component.blocksPerColumn;
            var samplesPerLine = blocksPerLine << 3;
            var R2 = new Int32Array(64), r = new Uint8Array(64);
            function quantizeAndInverse(zz, dataOut, dataIn) {
              var qt = component.quantizationTable;
              var v0, v1, v2, v3, v4, v5, v6, v7, t;
              var p = dataIn;
              var i2;
              for (i2 = 0; i2 < 64; i2++)
                p[i2] = zz[i2] * qt[i2];
              for (i2 = 0; i2 < 8; ++i2) {
                var row = 8 * i2;
                if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
                  t = dctSqrt2 * p[0 + row] + 512 >> 10;
                  p[0 + row] = t;
                  p[1 + row] = t;
                  p[2 + row] = t;
                  p[3 + row] = t;
                  p[4 + row] = t;
                  p[5 + row] = t;
                  p[6 + row] = t;
                  p[7 + row] = t;
                  continue;
                }
                v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
                v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
                v2 = p[2 + row];
                v3 = p[6 + row];
                v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
                v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
                v5 = p[3 + row] << 4;
                v6 = p[5 + row] << 4;
                t = v0 - v1 + 1 >> 1;
                v0 = v0 + v1 + 1 >> 1;
                v1 = t;
                t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
                v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
                v3 = t;
                t = v4 - v6 + 1 >> 1;
                v4 = v4 + v6 + 1 >> 1;
                v6 = t;
                t = v7 + v5 + 1 >> 1;
                v5 = v7 - v5 + 1 >> 1;
                v7 = t;
                t = v0 - v3 + 1 >> 1;
                v0 = v0 + v3 + 1 >> 1;
                v3 = t;
                t = v1 - v2 + 1 >> 1;
                v1 = v1 + v2 + 1 >> 1;
                v2 = t;
                t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
                v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
                v7 = t;
                t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
                v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
                v6 = t;
                p[0 + row] = v0 + v7;
                p[7 + row] = v0 - v7;
                p[1 + row] = v1 + v6;
                p[6 + row] = v1 - v6;
                p[2 + row] = v2 + v5;
                p[5 + row] = v2 - v5;
                p[3 + row] = v3 + v4;
                p[4 + row] = v3 - v4;
              }
              for (i2 = 0; i2 < 8; ++i2) {
                var col = i2;
                if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
                  t = dctSqrt2 * dataIn[i2 + 0] + 8192 >> 14;
                  p[0 * 8 + col] = t;
                  p[1 * 8 + col] = t;
                  p[2 * 8 + col] = t;
                  p[3 * 8 + col] = t;
                  p[4 * 8 + col] = t;
                  p[5 * 8 + col] = t;
                  p[6 * 8 + col] = t;
                  p[7 * 8 + col] = t;
                  continue;
                }
                v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
                v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
                v2 = p[2 * 8 + col];
                v3 = p[6 * 8 + col];
                v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
                v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
                v5 = p[3 * 8 + col];
                v6 = p[5 * 8 + col];
                t = v0 - v1 + 1 >> 1;
                v0 = v0 + v1 + 1 >> 1;
                v1 = t;
                t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
                v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
                v3 = t;
                t = v4 - v6 + 1 >> 1;
                v4 = v4 + v6 + 1 >> 1;
                v6 = t;
                t = v7 + v5 + 1 >> 1;
                v5 = v7 - v5 + 1 >> 1;
                v7 = t;
                t = v0 - v3 + 1 >> 1;
                v0 = v0 + v3 + 1 >> 1;
                v3 = t;
                t = v1 - v2 + 1 >> 1;
                v1 = v1 + v2 + 1 >> 1;
                v2 = t;
                t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
                v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
                v7 = t;
                t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
                v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
                v6 = t;
                p[0 * 8 + col] = v0 + v7;
                p[7 * 8 + col] = v0 - v7;
                p[1 * 8 + col] = v1 + v6;
                p[6 * 8 + col] = v1 - v6;
                p[2 * 8 + col] = v2 + v5;
                p[5 * 8 + col] = v2 - v5;
                p[3 * 8 + col] = v3 + v4;
                p[4 * 8 + col] = v3 - v4;
              }
              for (i2 = 0; i2 < 64; ++i2) {
                var sample2 = 128 + (p[i2] + 8 >> 4);
                dataOut[i2] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
              }
            }
            __name(quantizeAndInverse, "quantizeAndInverse");
            requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
            var i, j;
            for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
              var scanLine = blockRow << 3;
              for (i = 0; i < 8; i++)
                lines.push(new Uint8Array(samplesPerLine));
              for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
                quantizeAndInverse(component.blocks[blockRow][blockCol], r, R2);
                var offset = 0, sample = blockCol << 3;
                for (j = 0; j < 8; j++) {
                  var line2 = lines[scanLine + j];
                  for (i = 0; i < 8; i++)
                    line2[sample + i] = r[offset++];
                }
              }
            }
            return lines;
          }
          __name(buildComponentData, "buildComponentData");
          function clampTo8bit(a) {
            return a < 0 ? 0 : a > 255 ? 255 : a;
          }
          __name(clampTo8bit, "clampTo8bit");
          constructor.prototype = {
            load: /* @__PURE__ */ __name(function load2(path2) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", path2, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = function() {
                var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
                this.parse(data);
                if (this.onload)
                  this.onload();
              }.bind(this);
              xhr.send(null);
            }, "load"),
            parse: /* @__PURE__ */ __name(function parse2(data) {
              var maxResolutionInPixels = this.opts.maxResolutionInMP * 1e3 * 1e3;
              var offset = 0;
              data.length;
              function readUint16() {
                var value = data[offset] << 8 | data[offset + 1];
                offset += 2;
                return value;
              }
              __name(readUint16, "readUint16");
              function readDataBlock() {
                var length = readUint16();
                var array = data.subarray(offset, offset + length - 2);
                offset += array.length;
                return array;
              }
              __name(readDataBlock, "readDataBlock");
              function prepareComponents(frame2) {
                var maxH = 0, maxV = 0;
                var component2, componentId2;
                for (componentId2 in frame2.components) {
                  if (frame2.components.hasOwnProperty(componentId2)) {
                    component2 = frame2.components[componentId2];
                    if (maxH < component2.h)
                      maxH = component2.h;
                    if (maxV < component2.v)
                      maxV = component2.v;
                  }
                }
                var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH);
                var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV);
                for (componentId2 in frame2.components) {
                  if (frame2.components.hasOwnProperty(componentId2)) {
                    component2 = frame2.components[componentId2];
                    var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH);
                    var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV);
                    var blocksPerLineForMcu = mcusPerLine * component2.h;
                    var blocksPerColumnForMcu = mcusPerColumn * component2.v;
                    var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
                    var blocks = [];
                    requestMemoryAllocation(blocksToAllocate * 256);
                    for (var i2 = 0; i2 < blocksPerColumnForMcu; i2++) {
                      var row = [];
                      for (var j2 = 0; j2 < blocksPerLineForMcu; j2++)
                        row.push(new Int32Array(64));
                      blocks.push(row);
                    }
                    component2.blocksPerLine = blocksPerLine;
                    component2.blocksPerColumn = blocksPerColumn;
                    component2.blocks = blocks;
                  }
                }
                frame2.maxH = maxH;
                frame2.maxV = maxV;
                frame2.mcusPerLine = mcusPerLine;
                frame2.mcusPerColumn = mcusPerColumn;
              }
              __name(prepareComponents, "prepareComponents");
              var jfif = null;
              var adobe = null;
              var frame, resetInterval;
              var quantizationTables = [], frames = [];
              var huffmanTablesAC = [], huffmanTablesDC = [];
              var fileMarker = readUint16();
              this.comments = [];
              if (fileMarker != 65496) {
                throw new Error("SOI not found");
              }
              fileMarker = readUint16();
              while (fileMarker != 65497) {
                var i, j;
                switch (fileMarker) {
                  case 65280:
                    break;
                  case 65504:
                  case 65505:
                  case 65506:
                  case 65507:
                  case 65508:
                  case 65509:
                  case 65510:
                  case 65511:
                  case 65512:
                  case 65513:
                  case 65514:
                  case 65515:
                  case 65516:
                  case 65517:
                  case 65518:
                  case 65519:
                  case 65534:
                    var appData = readDataBlock();
                    if (fileMarker === 65534) {
                      var comment = String.fromCharCode.apply(null, appData);
                      this.comments.push(comment);
                    }
                    if (fileMarker === 65504) {
                      if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                        jfif = {
                          version: { major: appData[5], minor: appData[6] },
                          densityUnits: appData[7],
                          xDensity: appData[8] << 8 | appData[9],
                          yDensity: appData[10] << 8 | appData[11],
                          thumbWidth: appData[12],
                          thumbHeight: appData[13],
                          thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                        };
                      }
                    }
                    if (fileMarker === 65505) {
                      if (appData[0] === 69 && appData[1] === 120 && appData[2] === 105 && appData[3] === 102 && appData[4] === 0) {
                        this.exifBuffer = appData.subarray(5, appData.length);
                      }
                    }
                    if (fileMarker === 65518) {
                      if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                        adobe = {
                          version: appData[6],
                          flags0: appData[7] << 8 | appData[8],
                          flags1: appData[9] << 8 | appData[10],
                          transformCode: appData[11]
                        };
                      }
                    }
                    break;
                  case 65499:
                    var quantizationTablesLength = readUint16();
                    var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                    while (offset < quantizationTablesEnd) {
                      var quantizationTableSpec = data[offset++];
                      requestMemoryAllocation(64 * 4);
                      var tableData = new Int32Array(64);
                      if (quantizationTableSpec >> 4 === 0) {
                        for (j = 0; j < 64; j++) {
                          var z = dctZigZag[j];
                          tableData[z] = data[offset++];
                        }
                      } else if (quantizationTableSpec >> 4 === 1) {
                        for (j = 0; j < 64; j++) {
                          var z = dctZigZag[j];
                          tableData[z] = readUint16();
                        }
                      } else
                        throw new Error("DQT: invalid table spec");
                      quantizationTables[quantizationTableSpec & 15] = tableData;
                    }
                    break;
                  case 65472:
                  case 65473:
                  case 65474:
                    readUint16();
                    frame = {};
                    frame.extended = fileMarker === 65473;
                    frame.progressive = fileMarker === 65474;
                    frame.precision = data[offset++];
                    frame.scanLines = readUint16();
                    frame.samplesPerLine = readUint16();
                    frame.components = {};
                    frame.componentsOrder = [];
                    var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
                    if (pixelsInFrame > maxResolutionInPixels) {
                      var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                      throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
                    }
                    var componentsCount = data[offset++], componentId;
                    for (i = 0; i < componentsCount; i++) {
                      componentId = data[offset];
                      var h = data[offset + 1] >> 4;
                      var v = data[offset + 1] & 15;
                      var qId = data[offset + 2];
                      frame.componentsOrder.push(componentId);
                      frame.components[componentId] = {
                        h,
                        v,
                        quantizationIdx: qId
                      };
                      offset += 3;
                    }
                    prepareComponents(frame);
                    frames.push(frame);
                    break;
                  case 65476:
                    var huffmanLength = readUint16();
                    for (i = 2; i < huffmanLength; ) {
                      var huffmanTableSpec = data[offset++];
                      var codeLengths = new Uint8Array(16);
                      var codeLengthSum = 0;
                      for (j = 0; j < 16; j++, offset++) {
                        codeLengthSum += codeLengths[j] = data[offset];
                      }
                      requestMemoryAllocation(16 + codeLengthSum);
                      var huffmanValues = new Uint8Array(codeLengthSum);
                      for (j = 0; j < codeLengthSum; j++, offset++)
                        huffmanValues[j] = data[offset];
                      i += 17 + codeLengthSum;
                      (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                    }
                    break;
                  case 65501:
                    readUint16();
                    resetInterval = readUint16();
                    break;
                  case 65498:
                    readUint16();
                    var selectorsCount = data[offset++];
                    var components = [], component;
                    for (i = 0; i < selectorsCount; i++) {
                      component = frame.components[data[offset++]];
                      var tableSpec = data[offset++];
                      component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                      component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                      components.push(component);
                    }
                    var spectralStart = data[offset++];
                    var spectralEnd = data[offset++];
                    var successiveApproximation = data[offset++];
                    var processed = decodeScan(
                      data,
                      offset,
                      frame,
                      components,
                      resetInterval,
                      spectralStart,
                      spectralEnd,
                      successiveApproximation >> 4,
                      successiveApproximation & 15,
                      this.opts
                    );
                    offset += processed;
                    break;
                  case 65535:
                    if (data[offset] !== 255) {
                      offset--;
                    }
                    break;
                  default:
                    if (data[offset - 3] == 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                      offset -= 3;
                      break;
                    }
                    throw new Error("unknown JPEG marker " + fileMarker.toString(16));
                }
                fileMarker = readUint16();
              }
              if (frames.length != 1)
                throw new Error("only single frame JPEGs supported");
              for (var i = 0; i < frames.length; i++) {
                var cp = frames[i].components;
                for (var j in cp) {
                  cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
                  delete cp[j].quantizationIdx;
                }
              }
              this.width = frame.samplesPerLine;
              this.height = frame.scanLines;
              this.jfif = jfif;
              this.adobe = adobe;
              this.components = [];
              for (var i = 0; i < frame.componentsOrder.length; i++) {
                var component = frame.components[frame.componentsOrder[i]];
                this.components.push({
                  lines: buildComponentData(frame, component),
                  scaleX: component.h / frame.maxH,
                  scaleY: component.v / frame.maxV
                });
              }
            }, "parse"),
            getData: /* @__PURE__ */ __name(function getData(width, height) {
              var scaleX = this.width / width, scaleY = this.height / height;
              var component1, component2, component3, component4;
              var component1Line, component2Line, component3Line, component4Line;
              var x, y;
              var offset = 0;
              var Y, Cb, Cr, K, C, M, Ye, R2, G, B;
              var colorTransform;
              var dataLength = width * height * this.components.length;
              requestMemoryAllocation(dataLength);
              var data = new Uint8Array(dataLength);
              switch (this.components.length) {
                case 1:
                  component1 = this.components[0];
                  for (y = 0; y < height; y++) {
                    component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                    for (x = 0; x < width; x++) {
                      Y = component1Line[0 | x * component1.scaleX * scaleX];
                      data[offset++] = Y;
                    }
                  }
                  break;
                case 2:
                  component1 = this.components[0];
                  component2 = this.components[1];
                  for (y = 0; y < height; y++) {
                    component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                    component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                    for (x = 0; x < width; x++) {
                      Y = component1Line[0 | x * component1.scaleX * scaleX];
                      data[offset++] = Y;
                      Y = component2Line[0 | x * component2.scaleX * scaleX];
                      data[offset++] = Y;
                    }
                  }
                  break;
                case 3:
                  colorTransform = true;
                  if (this.adobe && this.adobe.transformCode)
                    colorTransform = true;
                  else if (typeof this.opts.colorTransform !== "undefined")
                    colorTransform = !!this.opts.colorTransform;
                  component1 = this.components[0];
                  component2 = this.components[1];
                  component3 = this.components[2];
                  for (y = 0; y < height; y++) {
                    component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                    component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                    component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                    for (x = 0; x < width; x++) {
                      if (!colorTransform) {
                        R2 = component1Line[0 | x * component1.scaleX * scaleX];
                        G = component2Line[0 | x * component2.scaleX * scaleX];
                        B = component3Line[0 | x * component3.scaleX * scaleX];
                      } else {
                        Y = component1Line[0 | x * component1.scaleX * scaleX];
                        Cb = component2Line[0 | x * component2.scaleX * scaleX];
                        Cr = component3Line[0 | x * component3.scaleX * scaleX];
                        R2 = clampTo8bit(Y + 1.402 * (Cr - 128));
                        G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                        B = clampTo8bit(Y + 1.772 * (Cb - 128));
                      }
                      data[offset++] = R2;
                      data[offset++] = G;
                      data[offset++] = B;
                    }
                  }
                  break;
                case 4:
                  if (!this.adobe)
                    throw new Error("Unsupported color mode (4 components)");
                  colorTransform = false;
                  if (this.adobe && this.adobe.transformCode)
                    colorTransform = true;
                  else if (typeof this.opts.colorTransform !== "undefined")
                    colorTransform = !!this.opts.colorTransform;
                  component1 = this.components[0];
                  component2 = this.components[1];
                  component3 = this.components[2];
                  component4 = this.components[3];
                  for (y = 0; y < height; y++) {
                    component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                    component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                    component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                    component4Line = component4.lines[0 | y * component4.scaleY * scaleY];
                    for (x = 0; x < width; x++) {
                      if (!colorTransform) {
                        C = component1Line[0 | x * component1.scaleX * scaleX];
                        M = component2Line[0 | x * component2.scaleX * scaleX];
                        Ye = component3Line[0 | x * component3.scaleX * scaleX];
                        K = component4Line[0 | x * component4.scaleX * scaleX];
                      } else {
                        Y = component1Line[0 | x * component1.scaleX * scaleX];
                        Cb = component2Line[0 | x * component2.scaleX * scaleX];
                        Cr = component3Line[0 | x * component3.scaleX * scaleX];
                        K = component4Line[0 | x * component4.scaleX * scaleX];
                        C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                        M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                        Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                      }
                      data[offset++] = 255 - C;
                      data[offset++] = 255 - M;
                      data[offset++] = 255 - Ye;
                      data[offset++] = 255 - K;
                    }
                  }
                  break;
                default:
                  throw new Error("Unsupported color mode");
              }
              return data;
            }, "getData"),
            copyToImageData: /* @__PURE__ */ __name(function copyToImageData(imageData, formatAsRGBA) {
              var width = imageData.width, height = imageData.height;
              var imageDataArray = imageData.data;
              var data = this.getData(width, height);
              var i = 0, j = 0, x, y;
              var Y, K, C, M, R2, G, B;
              switch (this.components.length) {
                case 1:
                  for (y = 0; y < height; y++) {
                    for (x = 0; x < width; x++) {
                      Y = data[i++];
                      imageDataArray[j++] = Y;
                      imageDataArray[j++] = Y;
                      imageDataArray[j++] = Y;
                      if (formatAsRGBA) {
                        imageDataArray[j++] = 255;
                      }
                    }
                  }
                  break;
                case 3:
                  for (y = 0; y < height; y++) {
                    for (x = 0; x < width; x++) {
                      R2 = data[i++];
                      G = data[i++];
                      B = data[i++];
                      imageDataArray[j++] = R2;
                      imageDataArray[j++] = G;
                      imageDataArray[j++] = B;
                      if (formatAsRGBA) {
                        imageDataArray[j++] = 255;
                      }
                    }
                  }
                  break;
                case 4:
                  for (y = 0; y < height; y++) {
                    for (x = 0; x < width; x++) {
                      C = data[i++];
                      M = data[i++];
                      Y = data[i++];
                      K = data[i++];
                      R2 = 255 - clampTo8bit(C * (1 - K / 255) + K);
                      G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                      B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
                      imageDataArray[j++] = R2;
                      imageDataArray[j++] = G;
                      imageDataArray[j++] = B;
                      if (formatAsRGBA) {
                        imageDataArray[j++] = 255;
                      }
                    }
                  }
                  break;
                default:
                  throw new Error("Unsupported color mode");
              }
            }, "copyToImageData")
          };
          var totalBytesAllocated = 0;
          var maxMemoryUsageBytes = 0;
          function requestMemoryAllocation(increaseAmount = 0) {
            var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
            if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
              var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
              throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
            }
            totalBytesAllocated = totalMemoryImpactBytes;
          }
          __name(requestMemoryAllocation, "requestMemoryAllocation");
          constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
            totalBytesAllocated = 0;
            maxMemoryUsageBytes = maxMemoryUsageBytes_;
          };
          constructor.getBytesAllocated = function() {
            return totalBytesAllocated;
          };
          constructor.requestMemoryAllocation = requestMemoryAllocation;
          return constructor;
        }, "jpegImage"))();
        {
          module3.exports = decode3;
        }
        function decode3(jpegData, userOpts = {}) {
          var defaultOpts = {
            // "undefined" means "Choose whether to transform colors based on the image’s color model."
            colorTransform: void 0,
            useTArray: false,
            formatAsRGBA: true,
            tolerantDecoding: true,
            maxResolutionInMP: 100,
            // Don't decode more than 100 megapixels
            maxMemoryUsageInMB: 512
            // Don't decode if memory footprint is more than 512MB
          };
          var opts = { ...defaultOpts, ...userOpts };
          var arr = new Uint8Array(jpegData);
          var decoder2 = new JpegImage();
          decoder2.opts = opts;
          JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
          decoder2.parse(arr);
          var channels = opts.formatAsRGBA ? 4 : 3;
          var bytesNeeded = decoder2.width * decoder2.height * channels;
          try {
            JpegImage.requestMemoryAllocation(bytesNeeded);
            var image = {
              width: decoder2.width,
              height: decoder2.height,
              exifBuffer: decoder2.exifBuffer,
              data: opts.useTArray ? new Uint8Array(bytesNeeded) : new Buffer(bytesNeeded)
            };
            if (decoder2.comments.length > 0) {
              image["comments"] = decoder2.comments;
            }
          } catch (err) {
            if (err instanceof RangeError) {
              throw new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded);
            } else {
              throw err;
            }
          }
          decoder2.copyToImageData(image, opts.formatAsRGBA);
          return image;
        }
        __name(decode3, "decode");
      });
      var jpegJs = {
        encode: encoder,
        decode: decoder
      };
      function make2(w, h, options) {
        return new Bitmap(w, h, options);
      }
      __name(make2, "make");
      function encodePNGToStream2(bitmap, outstream) {
        return new Promise((res, rej) => {
          if (!bitmap.hasOwnProperty("data") || !bitmap.hasOwnProperty("width") || !bitmap.hasOwnProperty("height")) {
            return rej(new TypeError("Invalid bitmap image provided"));
          }
          const png$1 = new png.PNG({
            width: bitmap.width,
            height: bitmap.height
          });
          for (let i = 0; i < bitmap.width; i++) {
            for (let j = 0; j < bitmap.height; j++) {
              const rgba = bitmap.getPixelRGBA(i, j);
              const n = (j * bitmap.width + i) * 4;
              const bytes = getBytesBigEndian(rgba);
              for (let k = 0; k < 4; k++) {
                png$1.data[n + k] = bytes[k];
              }
            }
          }
          png$1.on("error", (err) => {
            rej(err);
          }).pack().pipe(outstream).on("finish", () => {
            res();
          }).on("error", (err) => {
            rej(err);
          });
        });
      }
      __name(encodePNGToStream2, "encodePNGToStream");
      function decodePNGFromStream(instream) {
        return new Promise((res, rej) => {
          instream.pipe(new png.PNG()).on("parsed", function() {
            const bitmap = new Bitmap(this.width, this.height, {});
            for (let i = 0; i < bitmap.data.length; i++) {
              bitmap.data[i] = this.data[i];
            }
            res(bitmap);
          }).on("error", function(err) {
            rej(err);
          });
        });
      }
      __name(decodePNGFromStream, "decodePNGFromStream");
      function encodeJPEGToStream(img, outstream, quality) {
        quality = quality || 90;
        return new Promise((res, rej) => {
          if (!img.hasOwnProperty("data") || !img.hasOwnProperty("width") || !img.hasOwnProperty("height")) {
            return rej(new TypeError("Invalid bitmap image provided"));
          }
          const data = {
            data: img.data,
            width: img.width,
            height: img.height
          };
          outstream.on("error", (err) => rej(err));
          outstream.write(jpegJs.encode(data, quality).data, () => {
            outstream.end();
            res();
          });
        });
      }
      __name(encodeJPEGToStream, "encodeJPEGToStream");
      function decodeJPEGFromStream(data, opts) {
        return new Promise((res, rej) => {
          try {
            const chunks = [];
            data.on("data", (chunk) => chunks.push(chunk));
            data.on("end", () => {
              const buf = Buffer.concat(chunks);
              let rawImageData = null;
              try {
                rawImageData = jpegJs.decode(buf, opts);
              } catch (err) {
                rej(err);
                return;
              }
              const bitmap = new Bitmap(rawImageData.width, rawImageData.height, {});
              for (let x_axis = 0; x_axis < rawImageData.width; x_axis++) {
                for (let y_axis = 0; y_axis < rawImageData.height; y_axis++) {
                  const n = (y_axis * rawImageData.width + x_axis) * 4;
                  bitmap.setPixelRGBA_i(
                    x_axis,
                    y_axis,
                    rawImageData.data[n + 0],
                    rawImageData.data[n + 1],
                    rawImageData.data[n + 2],
                    rawImageData.data[n + 3]
                  );
                }
              }
              res(bitmap);
            });
            data.on("error", (err) => {
              rej(err);
            });
          } catch (e) {
            console.log(e);
            rej(e);
          }
        });
      }
      __name(decodeJPEGFromStream, "decodeJPEGFromStream");
      exports2.debug_list_of_fonts = debug_list_of_fonts;
      exports2.decodeJPEGFromStream = decodeJPEGFromStream;
      exports2.decodePNGFromStream = decodePNGFromStream;
      exports2.encodeJPEGToStream = encodeJPEGToStream;
      exports2.encodePNGToStream = encodePNGToStream2;
      exports2.make = make2;
      exports2.measureText = measureText;
      exports2.processTextPath = processTextPath;
      exports2.registerFont = registerFont2;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/base64-stream/lib/encode.js
var require_encode = __commonJS({
  "node_modules/base64-stream/lib/encode.js"(exports, module2) {
    var { Transform } = require("stream");
    module2.exports = /* @__PURE__ */ __name(class Base64Encode extends Transform {
      /**
       * Creates a Base64Encode
       * @param {Object=} options - Options for stream creation. Passed to Transform constructor as-is.
       * @param {string=} options.inputEncoding - The input chunk format. Default is 'utf8'. No effect on Buffer input chunks.
       * @param {string=} options.outputEncoding - The output chunk format. Default is 'utf8'. Pass `null` for Buffer chunks.
       * @param {number=} options.lineLength - The max line-length of the output stream.
       * @param {string=} options.prefix - Prefix for output string.
       */
      constructor(options) {
        super(options);
        this.extra = null;
        this.lineLength = options && options.lineLength;
        this.currLineLength = 0;
        if (options && options.prefix) {
          this.push(options.prefix);
        }
        const encIn = options && options.inputEncoding;
        this.setDefaultEncoding(encIn || "utf8");
        const encOut = options && options.outputEncoding;
        if (encOut !== null) {
          this.setEncoding(encOut || "utf8");
        }
      }
      /**
       * Adds \r\n as needed to the data chunk to ensure that the output Base64 string meets
       * the maximum line length requirement.
       * @param {string} chunk
       * @returns {string}
       * @private
       */
      _fixLineLength(chunk) {
        if (!this.lineLength) {
          return chunk;
        }
        const size = chunk.length;
        const needed = this.lineLength - this.currLineLength;
        let start, end;
        let _chunk = "";
        for (start = 0, end = needed; end < size; start = end, end += this.lineLength) {
          _chunk += chunk.slice(start, end);
          _chunk += "\r\n";
        }
        const left = chunk.slice(start);
        this.currLineLength = left.length;
        _chunk += left;
        return _chunk;
      }
      /**
      * Transforms a Buffer chunk of data to a Base64 string chunk.
      * @param {Buffer} chunk
      * @param {string} encoding - unused since chunk is always a Buffer
      * @param cb
      * @private
      */
      _transform(chunk, encoding, cb) {
        if (this.extra) {
          chunk = Buffer.concat([this.extra, chunk]);
          this.extra = null;
        }
        const remaining = chunk.length % 3;
        if (remaining !== 0) {
          this.extra = chunk.slice(chunk.length - remaining);
          chunk = chunk.slice(0, chunk.length - remaining);
        }
        chunk = chunk.toString("base64");
        this.push(Buffer.from(this._fixLineLength(chunk)));
        cb();
      }
      /**
       * Emits 0 or 4 extra characters of Base64 data.
       * @param cb
       * @private
       */
      _flush(cb) {
        if (this.extra) {
          this.push(Buffer.from(this._fixLineLength(this.extra.toString("base64"))));
        }
        cb();
      }
    }, "Base64Encode");
  }
});

// node_modules/base64-stream/lib/decode.js
var require_decode = __commonJS({
  "node_modules/base64-stream/lib/decode.js"(exports, module2) {
    var { Transform } = require("stream");
    module2.exports = /* @__PURE__ */ __name(class Base64Decode extends Transform {
      /**
       * Create a Base64Decode
       */
      constructor() {
        super({ decodeStrings: false });
        this.extra = "";
      }
      /**
       * Decodes a Base64 data stream, coming in as a string or Buffer of UTF-8 text, into binary Buffers.
       * @param {Buffer|string} chunk
       * @param encoding
       * @param cb
       * @private
       */
      _transform(chunk, encoding, cb) {
        chunk = "" + chunk;
        chunk = this.extra + chunk.replace(/(\r\n|\n|\r)/gm, "");
        const remaining = chunk.length % 4;
        this.extra = chunk.slice(chunk.length - remaining);
        chunk = chunk.slice(0, chunk.length - remaining);
        const buf = Buffer.from(chunk, "base64");
        this.push(buf);
        cb();
      }
      /**
       * Emits 1, 2, or 3 extra characters of base64 data.
       * @param cb
       * @private
       */
      _flush(cb) {
        if (this.extra.length) {
          this.push(Buffer.from(this.extra, "base64"));
        }
        cb();
      }
    }, "Base64Decode");
  }
});

// node_modules/base64-stream/index.js
var require_base64_stream = __commonJS({
  "node_modules/base64-stream/index.js"(exports, module2) {
    var Base64Encode2 = require_encode();
    var Base64Decode = require_decode();
    module2.exports = {
      Base64Encode: Base64Encode2,
      Base64Decode
    };
  }
});

// node_modules/concat-stream/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/concat-stream/node_modules/readable-stream/lib/internal/streams/stream.js"(exports, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/concat-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/concat-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    __name(ownKeys, "ownKeys");
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_objectSpread, "_objectSpread");
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_defineProperty, "_defineProperty");
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    __name(_toPropertyKey, "_toPropertyKey");
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    __name(_toPrimitive, "_toPrimitive");
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    __name(copyBuffer, "copyBuffer");
    module2.exports = /* @__PURE__ */ __name(class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v) {
        const entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v) {
        const entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        const ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next)
          ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        const ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
      first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          const str = p.data;
          const nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n) {
        const ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          const buf = p.data;
          const nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [custom](_, options) {
        return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }, "BufferList");
  }
});

// node_modules/concat-stream/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/concat-stream/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module2) {
    "use strict";
    function destroy(err, cb) {
      const readableDestroyed = this._readableState && this._readableState.destroyed;
      const writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, (err2) => {
        if (!cb && err2) {
          if (!this._writableState) {
            process.nextTick(emitErrorAndCloseNT, this, err2);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, this, err2);
          } else {
            process.nextTick(emitCloseNT, this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, this);
        }
      });
      return this;
    }
    __name(destroy, "destroy");
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    __name(emitErrorAndCloseNT, "emitErrorAndCloseNT");
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    __name(emitCloseNT, "emitCloseNT");
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    __name(undestroy, "undestroy");
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    __name(emitErrorNT, "emitErrorNT");
    function errorOrDestroy(stream, err) {
      const rState = stream._readableState;
      const wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    __name(errorOrDestroy, "errorOrDestroy");
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/concat-stream/node_modules/readable-stream/errors.js
var require_errors = __commonJS({
  "node_modules/concat-stream/node_modules/readable-stream/errors.js"(exports, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      __name(getMessage, "getMessage");
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      __name(NodeError, "NodeError");
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    __name(createErrorType, "createErrorType");
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    __name(oneOf, "oneOf");
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    __name(startsWith, "startsWith");
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    __name(endsWith, "endsWith");
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    __name(includes, "includes");
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/concat-stream/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/concat-stream/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    __name(highWaterMarkFrom, "highWaterMarkFrom");
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          const name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    __name(getHighWaterMark, "getHighWaterMark");
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = /* @__PURE__ */ __name(function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      }, "inherits");
    } else {
      module2.exports = /* @__PURE__ */ __name(function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = /* @__PURE__ */ __name(function() {
          }, "TempCtor");
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      }, "inherits");
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/concat-stream/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/concat-stream/node_modules/readable-stream/lib/_stream_writable.js"(exports, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      this.next = null;
      this.entry = null;
      this.finish = () => {
        onCorkedFinish(this, state);
      };
    }
    __name(CorkedRequest, "CorkedRequest");
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    __name(_uint8ArrayToBuffer, "_uint8ArrayToBuffer");
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    __name(_isUint8Array, "_isUint8Array");
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    __name(nop, "nop");
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    __name(WritableState, "WritableState");
    WritableState.prototype.getBuffer = /* @__PURE__ */ __name(function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    }, "getBuffer");
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(/* @__PURE__ */ __name(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "writableStateBufferGetter"), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: /* @__PURE__ */ __name(function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }, "value")
      });
    } else {
      realHasInstance = /* @__PURE__ */ __name(function realHasInstance2(object) {
        return object instanceof this;
      }, "realHasInstance");
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      const isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    __name(Writable, "Writable");
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    __name(writeAfterEnd, "writeAfterEnd");
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    __name(validChunk, "validChunk");
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = /* @__PURE__ */ __name(function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    }, "setDefaultEncoding");
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get() {
        return this._writableState && this._writableState.getBuffer();
      }, "get")
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    __name(decodeChunk, "decodeChunk");
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get() {
        return this._writableState.highWaterMark;
      }, "get")
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    __name(writeOrBuffer, "writeOrBuffer");
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    __name(doWrite, "doWrite");
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    __name(onwriteError, "onwriteError");
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    __name(onwriteStateUpdate, "onwriteStateUpdate");
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    __name(onwrite, "onwrite");
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    __name(afterWrite, "afterWrite");
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    __name(onwriteDrain, "onwriteDrain");
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    __name(clearBuffer, "clearBuffer");
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    __name(needFinish, "needFinish");
    function callFinal(stream, state) {
      stream._final((err) => {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    __name(callFinal, "callFinal");
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    __name(prefinish, "prefinish");
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            const rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    __name(finishMaybe, "finishMaybe");
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    __name(endWritable, "endWritable");
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    __name(onCorkedFinish, "onCorkedFinish");
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/concat-stream/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/concat-stream/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj)
        keys.push(key);
      return keys;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits()(Duplex, Readable);
    {
      const keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        const method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    __name(Duplex, "Duplex");
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get() {
        return this._writableState && this._writableState.getBuffer();
      }, "get")
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    __name(onend, "onend");
    function onEndNT(self2) {
      self2.end();
    }
    __name(onEndNT, "onEndNT");
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    __name(copyProps, "copyProps");
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    __name(SafeBuffer, "SafeBuffer");
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    __name(_normalizeEncoding, "_normalizeEncoding");
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    __name(normalizeEncoding, "normalizeEncoding");
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    __name(StringDecoder, "StringDecoder");
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    __name(utf8CheckByte, "utf8CheckByte");
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    __name(utf8CheckIncomplete, "utf8CheckIncomplete");
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    __name(utf8CheckExtraBytes, "utf8CheckExtraBytes");
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    __name(utf8FillLast, "utf8FillLast");
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    __name(utf8Text, "utf8Text");
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    __name(utf8End, "utf8End");
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    __name(utf16Text, "utf16Text");
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    __name(utf16End, "utf16End");
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    __name(base64Text, "base64Text");
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    __name(base64End, "base64End");
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    __name(simpleWrite, "simpleWrite");
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
    __name(simpleEnd, "simpleEnd");
  }
});

// node_modules/concat-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/concat-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      let called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    __name(once, "once");
    function noop() {
    }
    __name(noop, "noop");
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    __name(isRequest, "isRequest");
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      let readable = opts.readable || opts.readable !== false && stream.readable;
      let writable = opts.writable || opts.writable !== false && stream.writable;
      const onlegacyfinish = /* @__PURE__ */ __name(() => {
        if (!stream.writable)
          onfinish();
      }, "onlegacyfinish");
      var writableEnded = stream._writableState && stream._writableState.finished;
      const onfinish = /* @__PURE__ */ __name(() => {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      }, "onfinish");
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      const onend = /* @__PURE__ */ __name(() => {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      }, "onend");
      const onerror = /* @__PURE__ */ __name((err) => {
        callback.call(stream, err);
      }, "onerror");
      const onclose = /* @__PURE__ */ __name(() => {
        let err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      }, "onclose");
      const onrequest = /* @__PURE__ */ __name(() => {
        stream.req.on("finish", onfinish);
      }, "onrequest");
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    __name(eos, "eos");
    module2.exports = eos;
  }
});

// node_modules/concat-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/concat-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module2) {
    "use strict";
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    __name(createIterResult, "createIterResult");
    function readAndResolve(iter) {
      const resolve = iter[kLastResolve];
      if (resolve !== null) {
        const data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    __name(readAndResolve, "readAndResolve");
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    __name(onReadable, "onReadable");
    function wrapForNext(lastPromise, iter) {
      return (resolve, reject) => {
        lastPromise.then(() => {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    __name(wrapForNext, "wrapForNext");
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf({
      get stream() {
        return this[kStream];
      },
      next() {
        const error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise((resolve, reject) => {
            process.nextTick(() => {
              if (this[kError]) {
                reject(this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        const lastPromise = this[kLastPromise];
        let promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          const data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      return() {
        return new Promise((resolve, reject) => {
          this[kStream].destroy(null, (err) => {
            if (err) {
              reject(err);
              return;
            }
            resolve(createIterResult(void 0, true));
          });
        });
      }
    }, AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = /* @__PURE__ */ __name((stream) => {
      const iterator = Object.create(ReadableStreamAsyncIteratorPrototype, {
        [kStream]: {
          value: stream,
          writable: true
        },
        [kLastResolve]: {
          value: null,
          writable: true
        },
        [kLastReject]: {
          value: null,
          writable: true
        },
        [kError]: {
          value: null,
          writable: true
        },
        [kEnded]: {
          value: stream._readableState.endEmitted,
          writable: true
        },
        // the function passed to new Promise
        // is cached so we avoid allocating a new
        // closure at every run
        [kHandlePromise]: {
          value: (resolve, reject) => {
            const data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }
      });
      iterator[kLastPromise] = null;
      finished(stream, (err) => {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          const reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        const resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    }, "createReadableStreamAsyncIterator");
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/concat-stream/node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/concat-stream/node_modules/readable-stream/lib/internal/streams/from.js"(exports, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    __name(asyncGeneratorStep, "asyncGeneratorStep");
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          __name(_next, "_next");
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          __name(_throw, "_throw");
          _next(void 0);
        });
      };
    }
    __name(_asyncToGenerator, "_asyncToGenerator");
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    __name(ownKeys, "ownKeys");
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_objectSpread, "_objectSpread");
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_defineProperty, "_defineProperty");
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    __name(_toPropertyKey, "_toPropertyKey");
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    __name(_toPrimitive, "_toPrimitive");
    var ERR_INVALID_ARG_TYPE = require_errors().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      let iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      const readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      __name(next, "next");
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            const _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      __name(_next2, "_next2");
      return readable;
    }
    __name(from, "from");
    module2.exports = from;
  }
});

// node_modules/concat-stream/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/concat-stream/node_modules/readable-stream/lib/_stream_readable.js"(exports, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = /* @__PURE__ */ __name(function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    }, "EElistenerCount");
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    __name(_uint8ArrayToBuffer, "_uint8ArrayToBuffer");
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    __name(_isUint8Array, "_isUint8Array");
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = /* @__PURE__ */ __name(function debug2() {
      }, "debug");
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    __name(prependListener, "prependListener");
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    __name(ReadableState, "ReadableState");
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      const isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    __name(Readable, "Readable");
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    __name(readableAddChunk, "readableAddChunk");
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    __name(addChunk, "addChunk");
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    __name(chunkInvalid, "chunkInvalid");
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      const decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      let p = this._readableState.buffer.head;
      let content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    __name(computeNewHighWaterMark, "computeNewHighWaterMark");
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    __name(howMuchToRead, "howMuchToRead");
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    __name(onEofChunk, "onEofChunk");
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    __name(emitReadable, "emitReadable");
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    __name(emitReadable_, "emitReadable_");
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    __name(maybeReadMore, "maybeReadMore");
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    __name(maybeReadMore_, "maybeReadMore_");
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      __name(onunpipe, "onunpipe");
      function onend() {
        debug("onend");
        dest.end();
      }
      __name(onend, "onend");
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      __name(cleanup, "cleanup");
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      __name(ondata, "ondata");
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      __name(onerror, "onerror");
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      __name(onclose, "onclose");
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      __name(onfinish, "onfinish");
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      __name(unpipe, "unpipe");
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return /* @__PURE__ */ __name(function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      }, "pipeOnDrainFunctionResult");
    }
    __name(pipeOnDrain, "pipeOnDrain");
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      const res = Stream.prototype.on.call(this, ev, fn);
      const state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      const res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      const res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    __name(updateReadableListening, "updateReadableListening");
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    __name(nReadingNextTick, "nReadingNextTick");
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    __name(resume, "resume");
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    __name(resume_, "resume_");
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    __name(flow, "flow");
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      stream.on("end", () => {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            this.push(chunk);
        }
        this.push(null);
      });
      stream.on("data", (chunk) => {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = (/* @__PURE__ */ __name(function methodWrap(method) {
            return /* @__PURE__ */ __name(function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            }, "methodWrapReturnFunction");
          }, "methodWrap"))(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = (n2) => {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get() {
        return this._readableState.highWaterMark;
      }, "get")
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get() {
        return this._readableState && this._readableState.buffer;
      }, "get")
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get() {
        return this._readableState.flowing;
      }, "get"),
      set: /* @__PURE__ */ __name(function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }, "set")
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    __name(fromList, "fromList");
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    __name(endReadable, "endReadable");
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          const wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    __name(endReadableNT, "endReadableNT");
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
    __name(indexOf, "indexOf");
  }
});

// node_modules/concat-stream/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/concat-stream/node_modules/readable-stream/lib/_stream_transform.js"(exports, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    __name(afterTransform, "afterTransform");
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    __name(Transform, "Transform");
    function prefinish() {
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush((er, data) => {
          done(this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    __name(prefinish, "prefinish");
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, (err2) => {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
    __name(done, "done");
  }
});

// node_modules/concat-stream/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/concat-stream/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    __name(PassThrough, "PassThrough");
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/concat-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/concat-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module2) {
    "use strict";
    var eos;
    function once(callback) {
      let called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback(...arguments);
      };
    }
    __name(once, "once");
    var _require$codes = require_errors().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    __name(noop, "noop");
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    __name(isRequest, "isRequest");
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      let closed = false;
      stream.on("close", () => {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, (err) => {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      let destroyed = false;
      return (err) => {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    __name(destroyer, "destroyer");
    function call(fn) {
      fn();
    }
    __name(call, "call");
    function pipe(from, to) {
      return from.pipe(to);
    }
    __name(pipe, "pipe");
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    __name(popCallback, "popCallback");
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      const callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      let error;
      const destroys = streams.map(function(stream, i) {
        const reading = i < streams.length - 1;
        const writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    __name(pipeline, "pipeline");
    module2.exports = pipeline;
  }
});

// node_modules/concat-stream/node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/concat-stream/node_modules/readable-stream/readable.js"(exports, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports = module2.exports = require_stream_readable();
      exports.Stream = Stream || exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable();
      exports.Duplex = require_stream_duplex();
      exports.Transform = require_stream_transform();
      exports.PassThrough = require_stream_passthrough();
      exports.finished = require_end_of_stream();
      exports.pipeline = require_pipeline();
    }
  }
});

// node_modules/buffer-from/index.js
var require_buffer_from = __commonJS({
  "node_modules/buffer-from/index.js"(exports, module2) {
    var toString = Object.prototype.toString;
    var isModern = typeof Buffer !== "undefined" && typeof Buffer.alloc === "function" && typeof Buffer.allocUnsafe === "function" && typeof Buffer.from === "function";
    function isArrayBuffer(input) {
      return toString.call(input).slice(8, -1) === "ArrayBuffer";
    }
    __name(isArrayBuffer, "isArrayBuffer");
    function fromArrayBuffer(obj, byteOffset, length) {
      byteOffset >>>= 0;
      var maxLength = obj.byteLength - byteOffset;
      if (maxLength < 0) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (length === void 0) {
        length = maxLength;
      } else {
        length >>>= 0;
        if (length > maxLength) {
          throw new RangeError("'length' is out of bounds");
        }
      }
      return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
    }
    __name(fromArrayBuffer, "fromArrayBuffer");
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
      }
      return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
    }
    __name(fromString, "fromString");
    function bufferFrom(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (isArrayBuffer(value)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      return isModern ? Buffer.from(value) : new Buffer(value);
    }
    __name(bufferFrom, "bufferFrom");
    module2.exports = bufferFrom;
  }
});

// node_modules/typedarray/index.js
var require_typedarray = __commonJS({
  "node_modules/typedarray/index.js"(exports) {
    var undefined2 = void 0;
    var MAX_ARRAY_LENGTH = 1e5;
    var ECMAScript = function() {
      var opts = Object.prototype.toString, ophop = Object.prototype.hasOwnProperty;
      return {
        // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
        Class: function(v) {
          return opts.call(v).replace(/^\[object *|\]$/g, "");
        },
        HasProperty: function(o, p) {
          return p in o;
        },
        HasOwnProperty: function(o, p) {
          return ophop.call(o, p);
        },
        IsCallable: function(o) {
          return typeof o === "function";
        },
        ToInt32: function(v) {
          return v >> 0;
        },
        ToUint32: function(v) {
          return v >>> 0;
        }
      };
    }();
    var LN2 = Math.LN2;
    var abs = Math.abs;
    var floor = Math.floor;
    var log = Math.log;
    var min = Math.min;
    var pow = Math.pow;
    var round2 = Math.round;
    function configureProperties(obj) {
      if (getOwnPropNames && defineProp) {
        var props = getOwnPropNames(obj), i;
        for (i = 0; i < props.length; i += 1) {
          defineProp(obj, props[i], {
            value: obj[props[i]],
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
      }
    }
    __name(configureProperties, "configureProperties");
    var defineProp;
    if (Object.defineProperty && function() {
      try {
        Object.defineProperty({}, "x", {});
        return true;
      } catch (e) {
        return false;
      }
    }()) {
      defineProp = Object.defineProperty;
    } else {
      defineProp = /* @__PURE__ */ __name(function(o, p, desc) {
        if (!o === Object(o))
          throw new TypeError("Object.defineProperty called on non-object");
        if (ECMAScript.HasProperty(desc, "get") && Object.prototype.__defineGetter__) {
          Object.prototype.__defineGetter__.call(o, p, desc.get);
        }
        if (ECMAScript.HasProperty(desc, "set") && Object.prototype.__defineSetter__) {
          Object.prototype.__defineSetter__.call(o, p, desc.set);
        }
        if (ECMAScript.HasProperty(desc, "value")) {
          o[p] = desc.value;
        }
        return o;
      }, "defineProp");
    }
    var getOwnPropNames = Object.getOwnPropertyNames || function(o) {
      if (o !== Object(o))
        throw new TypeError("Object.getOwnPropertyNames called on non-object");
      var props = [], p;
      for (p in o) {
        if (ECMAScript.HasOwnProperty(o, p)) {
          props.push(p);
        }
      }
      return props;
    };
    function makeArrayAccessors(obj) {
      if (!defineProp) {
        return;
      }
      if (obj.length > MAX_ARRAY_LENGTH)
        throw new RangeError("Array too large for polyfill");
      function makeArrayAccessor(index) {
        defineProp(obj, index, {
          "get": function() {
            return obj._getter(index);
          },
          "set": function(v) {
            obj._setter(index, v);
          },
          enumerable: true,
          configurable: false
        });
      }
      __name(makeArrayAccessor, "makeArrayAccessor");
      var i;
      for (i = 0; i < obj.length; i += 1) {
        makeArrayAccessor(i);
      }
    }
    __name(makeArrayAccessors, "makeArrayAccessors");
    function as_signed(value, bits) {
      var s = 32 - bits;
      return value << s >> s;
    }
    __name(as_signed, "as_signed");
    function as_unsigned(value, bits) {
      var s = 32 - bits;
      return value << s >>> s;
    }
    __name(as_unsigned, "as_unsigned");
    function packI8(n) {
      return [n & 255];
    }
    __name(packI8, "packI8");
    function unpackI8(bytes) {
      return as_signed(bytes[0], 8);
    }
    __name(unpackI8, "unpackI8");
    function packU8(n) {
      return [n & 255];
    }
    __name(packU8, "packU8");
    function unpackU8(bytes) {
      return as_unsigned(bytes[0], 8);
    }
    __name(unpackU8, "unpackU8");
    function packU8Clamped(n) {
      n = round2(Number(n));
      return [n < 0 ? 0 : n > 255 ? 255 : n & 255];
    }
    __name(packU8Clamped, "packU8Clamped");
    function packI16(n) {
      return [n >> 8 & 255, n & 255];
    }
    __name(packI16, "packI16");
    function unpackI16(bytes) {
      return as_signed(bytes[0] << 8 | bytes[1], 16);
    }
    __name(unpackI16, "unpackI16");
    function packU16(n) {
      return [n >> 8 & 255, n & 255];
    }
    __name(packU16, "packU16");
    function unpackU16(bytes) {
      return as_unsigned(bytes[0] << 8 | bytes[1], 16);
    }
    __name(unpackU16, "unpackU16");
    function packI32(n) {
      return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
    }
    __name(packI32, "packI32");
    function unpackI32(bytes) {
      return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
    }
    __name(unpackI32, "unpackI32");
    function packU32(n) {
      return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
    }
    __name(packU32, "packU32");
    function unpackU32(bytes) {
      return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
    }
    __name(unpackU32, "unpackU32");
    function packIEEE754(v, ebits, fbits) {
      var bias = (1 << ebits - 1) - 1, s, e, f, ln, i, bits, str, bytes;
      function roundToEven(n) {
        var w = floor(n), f2 = n - w;
        if (f2 < 0.5)
          return w;
        if (f2 > 0.5)
          return w + 1;
        return w % 2 ? w + 1 : w;
      }
      __name(roundToEven, "roundToEven");
      if (v !== v) {
        e = (1 << ebits) - 1;
        f = pow(2, fbits - 1);
        s = 0;
      } else if (v === Infinity || v === -Infinity) {
        e = (1 << ebits) - 1;
        f = 0;
        s = v < 0 ? 1 : 0;
      } else if (v === 0) {
        e = 0;
        f = 0;
        s = 1 / v === -Infinity ? 1 : 0;
      } else {
        s = v < 0;
        v = abs(v);
        if (v >= pow(2, 1 - bias)) {
          e = min(floor(log(v) / LN2), 1023);
          f = roundToEven(v / pow(2, e) * pow(2, fbits));
          if (f / pow(2, fbits) >= 2) {
            e = e + 1;
            f = 1;
          }
          if (e > bias) {
            e = (1 << ebits) - 1;
            f = 0;
          } else {
            e = e + bias;
            f = f - pow(2, fbits);
          }
        } else {
          e = 0;
          f = roundToEven(v / pow(2, 1 - bias - fbits));
        }
      }
      bits = [];
      for (i = fbits; i; i -= 1) {
        bits.push(f % 2 ? 1 : 0);
        f = floor(f / 2);
      }
      for (i = ebits; i; i -= 1) {
        bits.push(e % 2 ? 1 : 0);
        e = floor(e / 2);
      }
      bits.push(s ? 1 : 0);
      bits.reverse();
      str = bits.join("");
      bytes = [];
      while (str.length) {
        bytes.push(parseInt(str.substring(0, 8), 2));
        str = str.substring(8);
      }
      return bytes;
    }
    __name(packIEEE754, "packIEEE754");
    function unpackIEEE754(bytes, ebits, fbits) {
      var bits = [], i, j, b, str, bias, s, e, f;
      for (i = bytes.length; i; i -= 1) {
        b = bytes[i - 1];
        for (j = 8; j; j -= 1) {
          bits.push(b % 2 ? 1 : 0);
          b = b >> 1;
        }
      }
      bits.reverse();
      str = bits.join("");
      bias = (1 << ebits - 1) - 1;
      s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
      e = parseInt(str.substring(1, 1 + ebits), 2);
      f = parseInt(str.substring(1 + ebits), 2);
      if (e === (1 << ebits) - 1) {
        return f !== 0 ? NaN : s * Infinity;
      } else if (e > 0) {
        return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
      } else if (f !== 0) {
        return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
      } else {
        return s < 0 ? -0 : 0;
      }
    }
    __name(unpackIEEE754, "unpackIEEE754");
    function unpackF64(b) {
      return unpackIEEE754(b, 11, 52);
    }
    __name(unpackF64, "unpackF64");
    function packF64(v) {
      return packIEEE754(v, 11, 52);
    }
    __name(packF64, "packF64");
    function unpackF32(b) {
      return unpackIEEE754(b, 8, 23);
    }
    __name(unpackF32, "unpackF32");
    function packF32(v) {
      return packIEEE754(v, 8, 23);
    }
    __name(packF32, "packF32");
    (function() {
      var ArrayBuffer2 = /* @__PURE__ */ __name(function ArrayBuffer3(length) {
        length = ECMAScript.ToInt32(length);
        if (length < 0)
          throw new RangeError("ArrayBuffer size is not a small enough positive integer");
        this.byteLength = length;
        this._bytes = [];
        this._bytes.length = length;
        var i;
        for (i = 0; i < this.byteLength; i += 1) {
          this._bytes[i] = 0;
        }
        configureProperties(this);
      }, "ArrayBuffer");
      exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer2;
      var ArrayBufferView = /* @__PURE__ */ __name(function ArrayBufferView2() {
      }, "ArrayBufferView");
      function makeConstructor(bytesPerElement, pack, unpack) {
        var ctor;
        ctor = /* @__PURE__ */ __name(function(buffer, byteOffset, length) {
          var array, sequence, i, s;
          if (!arguments.length || typeof arguments[0] === "number") {
            this.length = ECMAScript.ToInt32(arguments[0]);
            if (length < 0)
              throw new RangeError("ArrayBufferView size is not a small enough positive integer");
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
          } else if (typeof arguments[0] === "object" && arguments[0].constructor === ctor) {
            array = arguments[0];
            this.length = array.length;
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
            for (i = 0; i < this.length; i += 1) {
              this._setter(i, array._getter(i));
            }
          } else if (typeof arguments[0] === "object" && !(arguments[0] instanceof ArrayBuffer2 || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
            sequence = arguments[0];
            this.length = ECMAScript.ToUint32(sequence.length);
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
            for (i = 0; i < this.length; i += 1) {
              s = sequence[i];
              this._setter(i, Number(s));
            }
          } else if (typeof arguments[0] === "object" && (arguments[0] instanceof ArrayBuffer2 || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
            this.buffer = buffer;
            this.byteOffset = ECMAScript.ToUint32(byteOffset);
            if (this.byteOffset > this.buffer.byteLength) {
              throw new RangeError("byteOffset out of range");
            }
            if (this.byteOffset % this.BYTES_PER_ELEMENT) {
              throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
            }
            if (arguments.length < 3) {
              this.byteLength = this.buffer.byteLength - this.byteOffset;
              if (this.byteLength % this.BYTES_PER_ELEMENT) {
                throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
              }
              this.length = this.byteLength / this.BYTES_PER_ELEMENT;
            } else {
              this.length = ECMAScript.ToUint32(length);
              this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            }
            if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
              throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
          this.constructor = ctor;
          configureProperties(this);
          makeArrayAccessors(this);
        }, "ctor");
        ctor.prototype = new ArrayBufferView();
        ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
        ctor.prototype._pack = pack;
        ctor.prototype._unpack = unpack;
        ctor.BYTES_PER_ELEMENT = bytesPerElement;
        ctor.prototype._getter = function(index) {
          if (arguments.length < 1)
            throw new SyntaxError("Not enough arguments");
          index = ECMAScript.ToUint32(index);
          if (index >= this.length) {
            return undefined2;
          }
          var bytes = [], i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1) {
            bytes.push(this.buffer._bytes[o]);
          }
          return this._unpack(bytes);
        };
        ctor.prototype.get = ctor.prototype._getter;
        ctor.prototype._setter = function(index, value) {
          if (arguments.length < 2)
            throw new SyntaxError("Not enough arguments");
          index = ECMAScript.ToUint32(index);
          if (index >= this.length) {
            return undefined2;
          }
          var bytes = this._pack(value), i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1) {
            this.buffer._bytes[o] = bytes[i];
          }
        };
        ctor.prototype.set = function(index, value) {
          if (arguments.length < 1)
            throw new SyntaxError("Not enough arguments");
          var array, sequence, offset, len, i, s, d, byteOffset, byteLength, tmp;
          if (typeof arguments[0] === "object" && arguments[0].constructor === this.constructor) {
            array = arguments[0];
            offset = ECMAScript.ToUint32(arguments[1]);
            if (offset + array.length > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
            byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
            byteLength = array.length * this.BYTES_PER_ELEMENT;
            if (array.buffer === this.buffer) {
              tmp = [];
              for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
                tmp[i] = array.buffer._bytes[s];
              }
              for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
                this.buffer._bytes[d] = tmp[i];
              }
            } else {
              for (i = 0, s = array.byteOffset, d = byteOffset; i < byteLength; i += 1, s += 1, d += 1) {
                this.buffer._bytes[d] = array.buffer._bytes[s];
              }
            }
          } else if (typeof arguments[0] === "object" && typeof arguments[0].length !== "undefined") {
            sequence = arguments[0];
            len = ECMAScript.ToUint32(sequence.length);
            offset = ECMAScript.ToUint32(arguments[1]);
            if (offset + len > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
            for (i = 0; i < len; i += 1) {
              s = sequence[i];
              this._setter(offset + i, Number(s));
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
        };
        ctor.prototype.subarray = function(start, end) {
          function clamp(v, min2, max) {
            return v < min2 ? min2 : v > max ? max : v;
          }
          __name(clamp, "clamp");
          start = ECMAScript.ToInt32(start);
          end = ECMAScript.ToInt32(end);
          if (arguments.length < 1) {
            start = 0;
          }
          if (arguments.length < 2) {
            end = this.length;
          }
          if (start < 0) {
            start = this.length + start;
          }
          if (end < 0) {
            end = this.length + end;
          }
          start = clamp(start, 0, this.length);
          end = clamp(end, 0, this.length);
          var len = end - start;
          if (len < 0) {
            len = 0;
          }
          return new this.constructor(
            this.buffer,
            this.byteOffset + start * this.BYTES_PER_ELEMENT,
            len
          );
        };
        return ctor;
      }
      __name(makeConstructor, "makeConstructor");
      var Int8Array2 = makeConstructor(1, packI8, unpackI8);
      var Uint8Array2 = makeConstructor(1, packU8, unpackU8);
      var Uint8ClampedArray2 = makeConstructor(1, packU8Clamped, unpackU8);
      var Int16Array2 = makeConstructor(2, packI16, unpackI16);
      var Uint16Array2 = makeConstructor(2, packU16, unpackU16);
      var Int32Array2 = makeConstructor(4, packI32, unpackI32);
      var Uint32Array2 = makeConstructor(4, packU32, unpackU32);
      var Float32Array2 = makeConstructor(4, packF32, unpackF32);
      var Float64Array2 = makeConstructor(8, packF64, unpackF64);
      exports.Int8Array = exports.Int8Array || Int8Array2;
      exports.Uint8Array = exports.Uint8Array || Uint8Array2;
      exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray2;
      exports.Int16Array = exports.Int16Array || Int16Array2;
      exports.Uint16Array = exports.Uint16Array || Uint16Array2;
      exports.Int32Array = exports.Int32Array || Int32Array2;
      exports.Uint32Array = exports.Uint32Array || Uint32Array2;
      exports.Float32Array = exports.Float32Array || Float32Array2;
      exports.Float64Array = exports.Float64Array || Float64Array2;
    })();
    (function() {
      function r(array, index) {
        return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
      }
      __name(r, "r");
      var IS_BIG_ENDIAN = function() {
        var u16array = new exports.Uint16Array([4660]), u8array = new exports.Uint8Array(u16array.buffer);
        return r(u8array, 0) === 18;
      }();
      var DataView2 = /* @__PURE__ */ __name(function DataView3(buffer, byteOffset, byteLength) {
        if (arguments.length === 0) {
          buffer = new exports.ArrayBuffer(0);
        } else if (!(buffer instanceof exports.ArrayBuffer || ECMAScript.Class(buffer) === "ArrayBuffer")) {
          throw new TypeError("TypeError");
        }
        this.buffer = buffer || new exports.ArrayBuffer(0);
        this.byteOffset = ECMAScript.ToUint32(byteOffset);
        if (this.byteOffset > this.buffer.byteLength) {
          throw new RangeError("byteOffset out of range");
        }
        if (arguments.length < 3) {
          this.byteLength = this.buffer.byteLength - this.byteOffset;
        } else {
          this.byteLength = ECMAScript.ToUint32(byteLength);
        }
        if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
        }
        configureProperties(this);
      }, "DataView");
      function makeGetter(arrayType) {
        return function(byteOffset, littleEndian) {
          byteOffset = ECMAScript.ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
          byteOffset += this.byteOffset;
          var uint8Array = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT), bytes = [], i;
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes.push(r(uint8Array, i));
          }
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes.reverse();
          }
          return r(new arrayType(new exports.Uint8Array(bytes).buffer), 0);
        };
      }
      __name(makeGetter, "makeGetter");
      DataView2.prototype.getUint8 = makeGetter(exports.Uint8Array);
      DataView2.prototype.getInt8 = makeGetter(exports.Int8Array);
      DataView2.prototype.getUint16 = makeGetter(exports.Uint16Array);
      DataView2.prototype.getInt16 = makeGetter(exports.Int16Array);
      DataView2.prototype.getUint32 = makeGetter(exports.Uint32Array);
      DataView2.prototype.getInt32 = makeGetter(exports.Int32Array);
      DataView2.prototype.getFloat32 = makeGetter(exports.Float32Array);
      DataView2.prototype.getFloat64 = makeGetter(exports.Float64Array);
      function makeSetter(arrayType) {
        return function(byteOffset, value, littleEndian) {
          byteOffset = ECMAScript.ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
          var typeArray = new arrayType([value]), byteArray = new exports.Uint8Array(typeArray.buffer), bytes = [], i, byteView;
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes.push(r(byteArray, i));
          }
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes.reverse();
          }
          byteView = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
          byteView.set(bytes);
        };
      }
      __name(makeSetter, "makeSetter");
      DataView2.prototype.setUint8 = makeSetter(exports.Uint8Array);
      DataView2.prototype.setInt8 = makeSetter(exports.Int8Array);
      DataView2.prototype.setUint16 = makeSetter(exports.Uint16Array);
      DataView2.prototype.setInt16 = makeSetter(exports.Int16Array);
      DataView2.prototype.setUint32 = makeSetter(exports.Uint32Array);
      DataView2.prototype.setInt32 = makeSetter(exports.Int32Array);
      DataView2.prototype.setFloat32 = makeSetter(exports.Float32Array);
      DataView2.prototype.setFloat64 = makeSetter(exports.Float64Array);
      exports.DataView = exports.DataView || DataView2;
    })();
  }
});

// node_modules/concat-stream/index.js
var require_concat_stream = __commonJS({
  "node_modules/concat-stream/index.js"(exports, module2) {
    var Writable = require_readable().Writable;
    var inherits = require_inherits();
    var bufferFrom = require_buffer_from();
    if (typeof Uint8Array === "undefined") {
      U8 = require_typedarray().Uint8Array;
    } else {
      U8 = Uint8Array;
    }
    var U8;
    function ConcatStream(opts, cb) {
      if (!(this instanceof ConcatStream))
        return new ConcatStream(opts, cb);
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      if (!opts)
        opts = {};
      var encoding = opts.encoding;
      var shouldInferEncoding = false;
      if (!encoding) {
        shouldInferEncoding = true;
      } else {
        encoding = String(encoding).toLowerCase();
        if (encoding === "u8" || encoding === "uint8") {
          encoding = "uint8array";
        }
      }
      Writable.call(this, { objectMode: true });
      this.encoding = encoding;
      this.shouldInferEncoding = shouldInferEncoding;
      if (cb)
        this.on("finish", function() {
          cb(this.getBody());
        });
      this.body = [];
    }
    __name(ConcatStream, "ConcatStream");
    module2.exports = ConcatStream;
    inherits(ConcatStream, Writable);
    ConcatStream.prototype._write = function(chunk, enc, next) {
      this.body.push(chunk);
      next();
    };
    ConcatStream.prototype.inferEncoding = function(buff) {
      var firstBuffer = buff === void 0 ? this.body[0] : buff;
      if (Buffer.isBuffer(firstBuffer))
        return "buffer";
      if (typeof Uint8Array !== "undefined" && firstBuffer instanceof Uint8Array)
        return "uint8array";
      if (Array.isArray(firstBuffer))
        return "array";
      if (typeof firstBuffer === "string")
        return "string";
      if (Object.prototype.toString.call(firstBuffer) === "[object Object]")
        return "object";
      return "buffer";
    };
    ConcatStream.prototype.getBody = function() {
      if (!this.encoding && this.body.length === 0)
        return [];
      if (this.shouldInferEncoding)
        this.encoding = this.inferEncoding();
      if (this.encoding === "array")
        return arrayConcat(this.body);
      if (this.encoding === "string")
        return stringConcat(this.body);
      if (this.encoding === "buffer")
        return bufferConcat(this.body);
      if (this.encoding === "uint8array")
        return u8Concat(this.body);
      return this.body;
    };
    var isArray = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) == "[object Array]";
    };
    function isArrayish(arr) {
      return /Array\]$/.test(Object.prototype.toString.call(arr));
    }
    __name(isArrayish, "isArrayish");
    function isBufferish(p) {
      return typeof p === "string" || isArrayish(p) || p && typeof p.subarray === "function";
    }
    __name(isBufferish, "isBufferish");
    function stringConcat(parts) {
      var strings = [];
      var needsToString = false;
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i];
        if (typeof p === "string") {
          strings.push(p);
        } else if (Buffer.isBuffer(p)) {
          strings.push(p);
        } else if (isBufferish(p)) {
          strings.push(bufferFrom(p));
        } else {
          strings.push(bufferFrom(String(p)));
        }
      }
      if (Buffer.isBuffer(parts[0])) {
        strings = Buffer.concat(strings);
        strings = strings.toString("utf8");
      } else {
        strings = strings.join("");
      }
      return strings;
    }
    __name(stringConcat, "stringConcat");
    function bufferConcat(parts) {
      var bufs = [];
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i];
        if (Buffer.isBuffer(p)) {
          bufs.push(p);
        } else if (isBufferish(p)) {
          bufs.push(bufferFrom(p));
        } else {
          bufs.push(bufferFrom(String(p)));
        }
      }
      return Buffer.concat(bufs);
    }
    __name(bufferConcat, "bufferConcat");
    function arrayConcat(parts) {
      var res = [];
      for (var i = 0; i < parts.length; i++) {
        res.push.apply(res, parts[i]);
      }
      return res;
    }
    __name(arrayConcat, "arrayConcat");
    function u8Concat(parts) {
      var len = 0;
      for (var i = 0; i < parts.length; i++) {
        if (typeof parts[i] === "string") {
          parts[i] = bufferFrom(parts[i]);
        }
        len += parts[i].length;
      }
      var u8 = new U8(len);
      for (var i = 0, offset = 0; i < parts.length; i++) {
        var part = parts[i];
        for (var j = 0; j < part.length; j++) {
          u8[offset++] = part[j];
        }
      }
      return u8;
    }
    __name(u8Concat, "u8Concat");
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(/* @__PURE__ */ __name(function afterTickOne() {
            fn.call(null, arg1);
          }, "afterTickOne"));
        case 3:
          return process.nextTick(/* @__PURE__ */ __name(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          }, "afterTickTwo"));
        case 4:
          return process.nextTick(/* @__PURE__ */ __name(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          }, "afterTickThree"));
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(/* @__PURE__ */ __name(function afterTick() {
            fn.apply(null, args);
          }, "afterTick"));
      }
    }
    __name(nextTick, "nextTick");
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream2 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    __name(isArray, "isArray");
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    __name(isBoolean, "isBoolean");
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    __name(isNull, "isNull");
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    __name(isNullOrUndefined, "isNullOrUndefined");
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    __name(isNumber, "isNumber");
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    __name(isString, "isString");
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    __name(isSymbol, "isSymbol");
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    __name(isUndefined, "isUndefined");
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    __name(isRegExp, "isRegExp");
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    __name(isObject, "isObject");
    exports.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    __name(isDate, "isDate");
    exports.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    __name(isError, "isError");
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    __name(isFunction, "isFunction");
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    __name(isPrimitive, "isPrimitive");
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require("buffer").Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    __name(objectToString, "objectToString");
  }
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    __name(_classCallCheck, "_classCallCheck");
    var Buffer2 = require_safe_buffer().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    __name(copyBuffer, "copyBuffer");
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      __name(BufferList, "BufferList");
      BufferList.prototype.push = /* @__PURE__ */ __name(function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }, "push");
      BufferList.prototype.unshift = /* @__PURE__ */ __name(function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }, "unshift");
      BufferList.prototype.shift = /* @__PURE__ */ __name(function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }, "shift");
      BufferList.prototype.clear = /* @__PURE__ */ __name(function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }, "clear");
      BufferList.prototype.join = /* @__PURE__ */ __name(function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      }, "join");
      BufferList.prototype.concat = /* @__PURE__ */ __name(function concat2(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }, "concat");
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
          pna.nextTick(emitErrorNT, this, err);
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          pna.nextTick(emitErrorNT, _this, err2);
          if (_this._writableState) {
            _this._writableState.errorEmitted = true;
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    __name(destroy, "destroy");
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    __name(undestroy, "undestroy");
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    __name(emitErrorNT, "emitErrorNT");
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable2 = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    __name(CorkedRequest, "CorkedRequest");
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream2();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    __name(_uint8ArrayToBuffer, "_uint8ArrayToBuffer");
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    __name(_isUint8Array, "_isUint8Array");
    var destroyImpl = require_destroy2();
    util.inherits(Writable, Stream);
    function nop() {
    }
    __name(nop, "nop");
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex2();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    __name(WritableState, "WritableState");
    WritableState.prototype.getBuffer = /* @__PURE__ */ __name(function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    }, "getBuffer");
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = /* @__PURE__ */ __name(function(object) {
        return object instanceof this;
      }, "realHasInstance");
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex2();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    __name(Writable, "Writable");
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    __name(writeAfterEnd, "writeAfterEnd");
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    __name(validChunk, "validChunk");
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = /* @__PURE__ */ __name(function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    }, "setDefaultEncoding");
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    __name(decodeChunk, "decodeChunk");
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    __name(writeOrBuffer, "writeOrBuffer");
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    __name(doWrite, "doWrite");
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    __name(onwriteError, "onwriteError");
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    __name(onwriteStateUpdate, "onwriteStateUpdate");
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    __name(onwrite, "onwrite");
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    __name(afterWrite, "afterWrite");
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    __name(onwriteDrain, "onwriteDrain");
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    __name(clearBuffer, "clearBuffer");
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    __name(needFinish, "needFinish");
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    __name(callFinal, "callFinal");
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    __name(prefinish, "prefinish");
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    __name(finishMaybe, "finishMaybe");
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    __name(endWritable, "endWritable");
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = corkReq;
      } else {
        state.corkedRequestsFree = corkReq;
      }
    }
    __name(onCorkedFinish, "onCorkedFinish");
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex2 = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var Readable = require_stream_readable2();
    var Writable = require_stream_writable2();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    __name(Duplex, "Duplex");
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    __name(onend, "onend");
    function onEndNT(self2) {
      self2.end();
    }
    __name(onEndNT, "onEndNT");
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable2 = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = /* @__PURE__ */ __name(function(emitter, type) {
      return emitter.listeners(type).length;
    }, "EElistenerCount");
    var Stream = require_stream2();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    __name(_uint8ArrayToBuffer, "_uint8ArrayToBuffer");
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    __name(_isUint8Array, "_isUint8Array");
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = /* @__PURE__ */ __name(function() {
      }, "debug");
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy2();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    __name(prependListener, "prependListener");
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex2();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    __name(ReadableState, "ReadableState");
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex2();
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    __name(Readable, "Readable");
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    __name(readableAddChunk, "readableAddChunk");
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    __name(addChunk, "addChunk");
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    __name(chunkInvalid, "chunkInvalid");
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    __name(needMoreData, "needMoreData");
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    __name(computeNewHighWaterMark, "computeNewHighWaterMark");
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    __name(howMuchToRead, "howMuchToRead");
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    __name(onEofChunk, "onEofChunk");
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    __name(emitReadable, "emitReadable");
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    __name(emitReadable_, "emitReadable_");
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    __name(maybeReadMore, "maybeReadMore");
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    __name(maybeReadMore_, "maybeReadMore_");
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      __name(onunpipe, "onunpipe");
      function onend() {
        debug("onend");
        dest.end();
      }
      __name(onend, "onend");
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      __name(cleanup, "cleanup");
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      __name(ondata, "ondata");
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      __name(onerror, "onerror");
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      __name(onclose, "onclose");
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      __name(onfinish, "onfinish");
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      __name(unpipe, "unpipe");
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    __name(pipeOnDrain, "pipeOnDrain");
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, unpipeInfo);
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    __name(nReadingNextTick, "nReadingNextTick");
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    __name(resume, "resume");
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    __name(resume_, "resume_");
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    __name(flow, "flow");
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    __name(fromList, "fromList");
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    __name(fromListPartial, "fromListPartial");
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    __name(copyFromBufferString, "copyFromBufferString");
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    __name(copyFromBuffer, "copyFromBuffer");
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    __name(endReadable, "endReadable");
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    __name(endReadableNT, "endReadableNT");
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
    __name(indexOf, "indexOf");
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform2 = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex2();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    __name(afterTransform, "afterTransform");
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    __name(Transform, "Transform");
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    __name(prefinish, "prefinish");
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
    __name(done, "done");
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough2 = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform2();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    __name(PassThrough, "PassThrough");
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/readable.js
var require_readable2 = __commonJS({
  "node_modules/readable-stream/readable.js"(exports, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports = module2.exports = Stream.Readable;
      exports.Readable = Stream.Readable;
      exports.Writable = Stream.Writable;
      exports.Duplex = Stream.Duplex;
      exports.Transform = Stream.Transform;
      exports.PassThrough = Stream.PassThrough;
      exports.Stream = Stream;
    } else {
      exports = module2.exports = require_stream_readable2();
      exports.Stream = Stream || exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable2();
      exports.Duplex = require_stream_duplex2();
      exports.Transform = require_stream_transform2();
      exports.PassThrough = require_stream_passthrough2();
    }
  }
});

// node_modules/jszip/lib/support.js
var require_support = __commonJS({
  "node_modules/jszip/lib/support.js"(exports) {
    "use strict";
    exports.base64 = true;
    exports.array = true;
    exports.string = true;
    exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
    exports.nodebuffer = typeof Buffer !== "undefined";
    exports.uint8array = typeof Uint8Array !== "undefined";
    if (typeof ArrayBuffer === "undefined") {
      exports.blob = false;
    } else {
      buffer = new ArrayBuffer(0);
      try {
        exports.blob = new Blob([buffer], {
          type: "application/zip"
        }).size === 0;
      } catch (e) {
        try {
          Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
          builder = new Builder();
          builder.append(buffer);
          exports.blob = builder.getBlob("application/zip").size === 0;
        } catch (e2) {
          exports.blob = false;
        }
      }
    }
    var buffer;
    var Builder;
    var builder;
    try {
      exports.nodestream = !!require_readable2().Readable;
    } catch (e) {
      exports.nodestream = false;
    }
  }
});

// node_modules/jszip/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/jszip/lib/base64.js"(exports) {
    "use strict";
    var utils = require_utils();
    var support = require_support();
    var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    exports.encode = function(input) {
      var output = [];
      var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
      var i = 0, len = input.length, remainingBytes = len;
      var isArray = utils.getTypeOf(input) !== "string";
      while (i < input.length) {
        remainingBytes = len - i;
        if (!isArray) {
          chr1 = input.charCodeAt(i++);
          chr2 = i < len ? input.charCodeAt(i++) : 0;
          chr3 = i < len ? input.charCodeAt(i++) : 0;
        } else {
          chr1 = input[i++];
          chr2 = i < len ? input[i++] : 0;
          chr3 = i < len ? input[i++] : 0;
        }
        enc1 = chr1 >> 2;
        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
        enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
      }
      return output.join("");
    };
    exports.decode = function(input) {
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i = 0, resultIndex = 0;
      var dataUrlPrefix = "data:";
      if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
        throw new Error("Invalid base64 input, it looks like a data url.");
      }
      input = input.replace(/[^A-Za-z0-9+/=]/g, "");
      var totalLength = input.length * 3 / 4;
      if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
      }
      if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
      }
      if (totalLength % 1 !== 0) {
        throw new Error("Invalid base64 input, bad content length.");
      }
      var output;
      if (support.uint8array) {
        output = new Uint8Array(totalLength | 0);
      } else {
        output = new Array(totalLength | 0);
      }
      while (i < input.length) {
        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        output[resultIndex++] = chr1;
        if (enc3 !== 64) {
          output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
          output[resultIndex++] = chr3;
        }
      }
      return output;
    };
  }
});

// node_modules/jszip/lib/nodejsUtils.js
var require_nodejsUtils = __commonJS({
  "node_modules/jszip/lib/nodejsUtils.js"(exports, module2) {
    "use strict";
    module2.exports = {
      /**
       * True if this is running in Nodejs, will be undefined in a browser.
       * In a browser, browserify won't include this file and the whole module
       * will be resolved an empty object.
       */
      isNode: typeof Buffer !== "undefined",
      /**
       * Create a new nodejs Buffer from an existing content.
       * @param {Object} data the data to pass to the constructor.
       * @param {String} encoding the encoding to use.
       * @return {Buffer} a new Buffer.
       */
      newBufferFrom: function(data, encoding) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) {
          return Buffer.from(data, encoding);
        } else {
          if (typeof data === "number") {
            throw new Error('The "data" argument must not be a number');
          }
          return new Buffer(data, encoding);
        }
      },
      /**
       * Create a new nodejs Buffer with the specified size.
       * @param {Integer} size the size of the buffer.
       * @return {Buffer} a new Buffer.
       */
      allocBuffer: function(size) {
        if (Buffer.alloc) {
          return Buffer.alloc(size);
        } else {
          var buf = new Buffer(size);
          buf.fill(0);
          return buf;
        }
      },
      /**
       * Find out if an object is a Buffer.
       * @param {Object} b the object to test.
       * @return {Boolean} true if the object is a Buffer, false otherwise.
       */
      isBuffer: function(b) {
        return Buffer.isBuffer(b);
      },
      isStream: function(obj) {
        return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
      }
    };
  }
});

// node_modules/immediate/lib/index.js
var require_lib = __commonJS({
  "node_modules/immediate/lib/index.js"(exports, module2) {
    "use strict";
    var Mutation = global.MutationObserver || global.WebKitMutationObserver;
    var scheduleDrain;
    if (process.browser) {
      if (Mutation) {
        called = 0;
        observer = new Mutation(nextTick);
        element = global.document.createTextNode("");
        observer.observe(element, {
          characterData: true
        });
        scheduleDrain = /* @__PURE__ */ __name(function() {
          element.data = called = ++called % 2;
        }, "scheduleDrain");
      } else if (!global.setImmediate && typeof global.MessageChannel !== "undefined") {
        channel = new global.MessageChannel();
        channel.port1.onmessage = nextTick;
        scheduleDrain = /* @__PURE__ */ __name(function() {
          channel.port2.postMessage(0);
        }, "scheduleDrain");
      } else if ("document" in global && "onreadystatechange" in global.document.createElement("script")) {
        scheduleDrain = /* @__PURE__ */ __name(function() {
          var scriptEl = global.document.createElement("script");
          scriptEl.onreadystatechange = function() {
            nextTick();
            scriptEl.onreadystatechange = null;
            scriptEl.parentNode.removeChild(scriptEl);
            scriptEl = null;
          };
          global.document.documentElement.appendChild(scriptEl);
        }, "scheduleDrain");
      } else {
        scheduleDrain = /* @__PURE__ */ __name(function() {
          setTimeout(nextTick, 0);
        }, "scheduleDrain");
      }
    } else {
      scheduleDrain = /* @__PURE__ */ __name(function() {
        process.nextTick(nextTick);
      }, "scheduleDrain");
    }
    var called;
    var observer;
    var element;
    var channel;
    var draining;
    var queue = [];
    function nextTick() {
      draining = true;
      var i, oldQueue;
      var len = queue.length;
      while (len) {
        oldQueue = queue;
        queue = [];
        i = -1;
        while (++i < len) {
          oldQueue[i]();
        }
        len = queue.length;
      }
      draining = false;
    }
    __name(nextTick, "nextTick");
    module2.exports = immediate;
    function immediate(task) {
      if (queue.push(task) === 1 && !draining) {
        scheduleDrain();
      }
    }
    __name(immediate, "immediate");
  }
});

// node_modules/lie/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/lie/lib/index.js"(exports, module2) {
    "use strict";
    var immediate = require_lib();
    function INTERNAL() {
    }
    __name(INTERNAL, "INTERNAL");
    var handlers = {};
    var REJECTED = ["REJECTED"];
    var FULFILLED = ["FULFILLED"];
    var PENDING = ["PENDING"];
    if (!process.browser) {
      UNHANDLED = ["UNHANDLED"];
    }
    var UNHANDLED;
    module2.exports = Promise2;
    function Promise2(resolver) {
      if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function");
      }
      this.state = PENDING;
      this.queue = [];
      this.outcome = void 0;
      if (!process.browser) {
        this.handled = UNHANDLED;
      }
      if (resolver !== INTERNAL) {
        safelyResolveThenable(this, resolver);
      }
    }
    __name(Promise2, "Promise");
    Promise2.prototype.finally = function(callback) {
      if (typeof callback !== "function") {
        return this;
      }
      var p = this.constructor;
      return this.then(resolve2, reject2);
      function resolve2(value) {
        function yes() {
          return value;
        }
        __name(yes, "yes");
        return p.resolve(callback()).then(yes);
      }
      __name(resolve2, "resolve");
      function reject2(reason) {
        function no() {
          throw reason;
        }
        __name(no, "no");
        return p.resolve(callback()).then(no);
      }
      __name(reject2, "reject");
    };
    Promise2.prototype.catch = function(onRejected) {
      return this.then(null, onRejected);
    };
    Promise2.prototype.then = function(onFulfilled, onRejected) {
      if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
        return this;
      }
      var promise = new this.constructor(INTERNAL);
      if (!process.browser) {
        if (this.handled === UNHANDLED) {
          this.handled = null;
        }
      }
      if (this.state !== PENDING) {
        var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
        unwrap(promise, resolver, this.outcome);
      } else {
        this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
      }
      return promise;
    };
    function QueueItem(promise, onFulfilled, onRejected) {
      this.promise = promise;
      if (typeof onFulfilled === "function") {
        this.onFulfilled = onFulfilled;
        this.callFulfilled = this.otherCallFulfilled;
      }
      if (typeof onRejected === "function") {
        this.onRejected = onRejected;
        this.callRejected = this.otherCallRejected;
      }
    }
    __name(QueueItem, "QueueItem");
    QueueItem.prototype.callFulfilled = function(value) {
      handlers.resolve(this.promise, value);
    };
    QueueItem.prototype.otherCallFulfilled = function(value) {
      unwrap(this.promise, this.onFulfilled, value);
    };
    QueueItem.prototype.callRejected = function(value) {
      handlers.reject(this.promise, value);
    };
    QueueItem.prototype.otherCallRejected = function(value) {
      unwrap(this.promise, this.onRejected, value);
    };
    function unwrap(promise, func, value) {
      immediate(function() {
        var returnValue;
        try {
          returnValue = func(value);
        } catch (e) {
          return handlers.reject(promise, e);
        }
        if (returnValue === promise) {
          handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
        } else {
          handlers.resolve(promise, returnValue);
        }
      });
    }
    __name(unwrap, "unwrap");
    handlers.resolve = function(self2, value) {
      var result = tryCatch(getThen, value);
      if (result.status === "error") {
        return handlers.reject(self2, result.value);
      }
      var thenable = result.value;
      if (thenable) {
        safelyResolveThenable(self2, thenable);
      } else {
        self2.state = FULFILLED;
        self2.outcome = value;
        var i = -1;
        var len = self2.queue.length;
        while (++i < len) {
          self2.queue[i].callFulfilled(value);
        }
      }
      return self2;
    };
    handlers.reject = function(self2, error) {
      self2.state = REJECTED;
      self2.outcome = error;
      if (!process.browser) {
        if (self2.handled === UNHANDLED) {
          immediate(function() {
            if (self2.handled === UNHANDLED) {
              process.emit("unhandledRejection", error, self2);
            }
          });
        }
      }
      var i = -1;
      var len = self2.queue.length;
      while (++i < len) {
        self2.queue[i].callRejected(error);
      }
      return self2;
    };
    function getThen(obj) {
      var then = obj && obj.then;
      if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
        return /* @__PURE__ */ __name(function appyThen() {
          then.apply(obj, arguments);
        }, "appyThen");
      }
    }
    __name(getThen, "getThen");
    function safelyResolveThenable(self2, thenable) {
      var called = false;
      function onError(value) {
        if (called) {
          return;
        }
        called = true;
        handlers.reject(self2, value);
      }
      __name(onError, "onError");
      function onSuccess(value) {
        if (called) {
          return;
        }
        called = true;
        handlers.resolve(self2, value);
      }
      __name(onSuccess, "onSuccess");
      function tryToUnwrap() {
        thenable(onSuccess, onError);
      }
      __name(tryToUnwrap, "tryToUnwrap");
      var result = tryCatch(tryToUnwrap);
      if (result.status === "error") {
        onError(result.value);
      }
    }
    __name(safelyResolveThenable, "safelyResolveThenable");
    function tryCatch(func, value) {
      var out = {};
      try {
        out.value = func(value);
        out.status = "success";
      } catch (e) {
        out.status = "error";
        out.value = e;
      }
      return out;
    }
    __name(tryCatch, "tryCatch");
    Promise2.resolve = resolve;
    function resolve(value) {
      if (value instanceof this) {
        return value;
      }
      return handlers.resolve(new this(INTERNAL), value);
    }
    __name(resolve, "resolve");
    Promise2.reject = reject;
    function reject(reason) {
      var promise = new this(INTERNAL);
      return handlers.reject(promise, reason);
    }
    __name(reject, "reject");
    Promise2.all = all;
    function all(iterable) {
      var self2 = this;
      if (Object.prototype.toString.call(iterable) !== "[object Array]") {
        return this.reject(new TypeError("must be an array"));
      }
      var len = iterable.length;
      var called = false;
      if (!len) {
        return this.resolve([]);
      }
      var values = new Array(len);
      var resolved = 0;
      var i = -1;
      var promise = new this(INTERNAL);
      while (++i < len) {
        allResolver(iterable[i], i);
      }
      return promise;
      function allResolver(value, i2) {
        self2.resolve(value).then(resolveFromAll, function(error) {
          if (!called) {
            called = true;
            handlers.reject(promise, error);
          }
        });
        function resolveFromAll(outValue) {
          values[i2] = outValue;
          if (++resolved === len && !called) {
            called = true;
            handlers.resolve(promise, values);
          }
        }
        __name(resolveFromAll, "resolveFromAll");
      }
      __name(allResolver, "allResolver");
    }
    __name(all, "all");
    Promise2.race = race;
    function race(iterable) {
      var self2 = this;
      if (Object.prototype.toString.call(iterable) !== "[object Array]") {
        return this.reject(new TypeError("must be an array"));
      }
      var len = iterable.length;
      var called = false;
      if (!len) {
        return this.resolve([]);
      }
      var i = -1;
      var promise = new this(INTERNAL);
      while (++i < len) {
        resolver(iterable[i]);
      }
      return promise;
      function resolver(value) {
        self2.resolve(value).then(function(response) {
          if (!called) {
            called = true;
            handlers.resolve(promise, response);
          }
        }, function(error) {
          if (!called) {
            called = true;
            handlers.reject(promise, error);
          }
        });
      }
      __name(resolver, "resolver");
    }
    __name(race, "race");
  }
});

// node_modules/jszip/lib/external.js
var require_external = __commonJS({
  "node_modules/jszip/lib/external.js"(exports, module2) {
    "use strict";
    var ES6Promise = null;
    if (typeof Promise !== "undefined") {
      ES6Promise = Promise;
    } else {
      ES6Promise = require_lib2();
    }
    module2.exports = {
      Promise: ES6Promise
    };
  }
});

// node_modules/setimmediate/setImmediate.js
var require_setImmediate = __commonJS({
  "node_modules/setimmediate/setImmediate.js"(exports) {
    (function(global2, undefined2) {
      "use strict";
      if (global2.setImmediate) {
        return;
      }
      var nextHandle = 1;
      var tasksByHandle = {};
      var currentlyRunningATask = false;
      var doc = global2.document;
      var registerImmediate;
      function setImmediate2(callback) {
        if (typeof callback !== "function") {
          callback = new Function("" + callback);
        }
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
        }
        var task = { callback, args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
      }
      __name(setImmediate2, "setImmediate");
      function clearImmediate(handle) {
        delete tasksByHandle[handle];
      }
      __name(clearImmediate, "clearImmediate");
      function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
          case 0:
            callback();
            break;
          case 1:
            callback(args[0]);
            break;
          case 2:
            callback(args[0], args[1]);
            break;
          case 3:
            callback(args[0], args[1], args[2]);
            break;
          default:
            callback.apply(undefined2, args);
            break;
        }
      }
      __name(run, "run");
      function runIfPresent(handle) {
        if (currentlyRunningATask) {
          setTimeout(runIfPresent, 0, handle);
        } else {
          var task = tasksByHandle[handle];
          if (task) {
            currentlyRunningATask = true;
            try {
              run(task);
            } finally {
              clearImmediate(handle);
              currentlyRunningATask = false;
            }
          }
        }
      }
      __name(runIfPresent, "runIfPresent");
      function installNextTickImplementation() {
        registerImmediate = /* @__PURE__ */ __name(function(handle) {
          process.nextTick(function() {
            runIfPresent(handle);
          });
        }, "registerImmediate");
      }
      __name(installNextTickImplementation, "installNextTickImplementation");
      function canUsePostMessage() {
        if (global2.postMessage && !global2.importScripts) {
          var postMessageIsAsynchronous = true;
          var oldOnMessage = global2.onmessage;
          global2.onmessage = function() {
            postMessageIsAsynchronous = false;
          };
          global2.postMessage("", "*");
          global2.onmessage = oldOnMessage;
          return postMessageIsAsynchronous;
        }
      }
      __name(canUsePostMessage, "canUsePostMessage");
      function installPostMessageImplementation() {
        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = /* @__PURE__ */ __name(function(event) {
          if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
            runIfPresent(+event.data.slice(messagePrefix.length));
          }
        }, "onGlobalMessage");
        if (global2.addEventListener) {
          global2.addEventListener("message", onGlobalMessage, false);
        } else {
          global2.attachEvent("onmessage", onGlobalMessage);
        }
        registerImmediate = /* @__PURE__ */ __name(function(handle) {
          global2.postMessage(messagePrefix + handle, "*");
        }, "registerImmediate");
      }
      __name(installPostMessageImplementation, "installPostMessageImplementation");
      function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
          var handle = event.data;
          runIfPresent(handle);
        };
        registerImmediate = /* @__PURE__ */ __name(function(handle) {
          channel.port2.postMessage(handle);
        }, "registerImmediate");
      }
      __name(installMessageChannelImplementation, "installMessageChannelImplementation");
      function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = /* @__PURE__ */ __name(function(handle) {
          var script = doc.createElement("script");
          script.onreadystatechange = function() {
            runIfPresent(handle);
            script.onreadystatechange = null;
            html.removeChild(script);
            script = null;
          };
          html.appendChild(script);
        }, "registerImmediate");
      }
      __name(installReadyStateChangeImplementation, "installReadyStateChangeImplementation");
      function installSetTimeoutImplementation() {
        registerImmediate = /* @__PURE__ */ __name(function(handle) {
          setTimeout(runIfPresent, 0, handle);
        }, "registerImmediate");
      }
      __name(installSetTimeoutImplementation, "installSetTimeoutImplementation");
      var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
      attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
      if ({}.toString.call(global2.process) === "[object process]") {
        installNextTickImplementation();
      } else if (canUsePostMessage()) {
        installPostMessageImplementation();
      } else if (global2.MessageChannel) {
        installMessageChannelImplementation();
      } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        installReadyStateChangeImplementation();
      } else {
        installSetTimeoutImplementation();
      }
      attachTo.setImmediate = setImmediate2;
      attachTo.clearImmediate = clearImmediate;
    })(typeof self === "undefined" ? typeof global === "undefined" ? exports : global : self);
  }
});

// node_modules/jszip/lib/utils.js
var require_utils = __commonJS({
  "node_modules/jszip/lib/utils.js"(exports) {
    "use strict";
    var support = require_support();
    var base64 = require_base64();
    var nodejsUtils = require_nodejsUtils();
    var external = require_external();
    require_setImmediate();
    function string2binary(str) {
      var result = null;
      if (support.uint8array) {
        result = new Uint8Array(str.length);
      } else {
        result = new Array(str.length);
      }
      return stringToArrayLike(str, result);
    }
    __name(string2binary, "string2binary");
    exports.newBlob = function(part, type) {
      exports.checkSupport("blob");
      try {
        return new Blob([part], {
          type
        });
      } catch (e) {
        try {
          var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
          var builder = new Builder();
          builder.append(part);
          return builder.getBlob(type);
        } catch (e2) {
          throw new Error("Bug : can't construct the Blob.");
        }
      }
    };
    function identity(input) {
      return input;
    }
    __name(identity, "identity");
    function stringToArrayLike(str, array) {
      for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 255;
      }
      return array;
    }
    __name(stringToArrayLike, "stringToArrayLike");
    var arrayToStringHelper = {
      /**
       * Transform an array of int into a string, chunk by chunk.
       * See the performances notes on arrayLikeToString.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @param {String} type the type of the array.
       * @param {Integer} chunk the chunk size.
       * @return {String} the resulting string.
       * @throws Error if the chunk is too big for the stack.
       */
      stringifyByChunk: function(array, type, chunk) {
        var result = [], k = 0, len = array.length;
        if (len <= chunk) {
          return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
          if (type === "array" || type === "nodebuffer") {
            result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
          } else {
            result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
          }
          k += chunk;
        }
        return result.join("");
      },
      /**
       * Call String.fromCharCode on every item in the array.
       * This is the naive implementation, which generate A LOT of intermediate string.
       * This should be used when everything else fail.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @return {String} the result.
       */
      stringifyByChar: function(array) {
        var resultStr = "";
        for (var i = 0; i < array.length; i++) {
          resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
      },
      applyCanBeUsed: {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array: function() {
          try {
            return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
          } catch (e) {
            return false;
          }
        }(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer: function() {
          try {
            return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
          } catch (e) {
            return false;
          }
        }()
      }
    };
    function arrayLikeToString(array) {
      var chunk = 65536, type = exports.getTypeOf(array), canUseApply = true;
      if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
      } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
      }
      if (canUseApply) {
        while (chunk > 1) {
          try {
            return arrayToStringHelper.stringifyByChunk(array, type, chunk);
          } catch (e) {
            chunk = Math.floor(chunk / 2);
          }
        }
      }
      return arrayToStringHelper.stringifyByChar(array);
    }
    __name(arrayLikeToString, "arrayLikeToString");
    exports.applyFromCharCode = arrayLikeToString;
    function arrayLikeToArrayLike(arrayFrom, arrayTo) {
      for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
      }
      return arrayTo;
    }
    __name(arrayLikeToArrayLike, "arrayLikeToArrayLike");
    var transform = {};
    transform["string"] = {
      "string": identity,
      "array": function(input) {
        return stringToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform["string"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": function(input) {
        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
      }
    };
    transform["array"] = {
      "string": arrayLikeToString,
      "array": identity,
      "arraybuffer": function(input) {
        return new Uint8Array(input).buffer;
      },
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
      }
    };
    transform["arraybuffer"] = {
      "string": function(input) {
        return arrayLikeToString(new Uint8Array(input));
      },
      "array": function(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
      },
      "arraybuffer": identity,
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(new Uint8Array(input));
      }
    };
    transform["uint8array"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return input.buffer;
      },
      "uint8array": identity,
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
      }
    };
    transform["nodebuffer"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": identity
    };
    exports.transformTo = function(outputType, input) {
      if (!input) {
        input = "";
      }
      if (!outputType) {
        return input;
      }
      exports.checkSupport(outputType);
      var inputType = exports.getTypeOf(input);
      var result = transform[inputType][outputType](input);
      return result;
    };
    exports.resolve = function(path) {
      var parts = path.split("/");
      var result = [];
      for (var index = 0; index < parts.length; index++) {
        var part = parts[index];
        if (part === "." || part === "" && index !== 0 && index !== parts.length - 1) {
          continue;
        } else if (part === "..") {
          result.pop();
        } else {
          result.push(part);
        }
      }
      return result.join("/");
    };
    exports.getTypeOf = function(input) {
      if (typeof input === "string") {
        return "string";
      }
      if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
      }
      if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
      }
      if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
      }
      if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
      }
    };
    exports.checkSupport = function(type) {
      var supported = support[type.toLowerCase()];
      if (!supported) {
        throw new Error(type + " is not supported by this platform");
      }
    };
    exports.MAX_VALUE_16BITS = 65535;
    exports.MAX_VALUE_32BITS = -1;
    exports.pretty = function(str) {
      var res = "", code, i;
      for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
      }
      return res;
    };
    exports.delay = function(callback, args, self2) {
      setImmediate(function() {
        callback.apply(self2 || null, args || []);
      });
    };
    exports.inherits = function(ctor, superCtor) {
      var Obj = /* @__PURE__ */ __name(function() {
      }, "Obj");
      Obj.prototype = superCtor.prototype;
      ctor.prototype = new Obj();
    };
    exports.extend = function() {
      var result = {}, i, attr;
      for (i = 0; i < arguments.length; i++) {
        for (attr in arguments[i]) {
          if (Object.prototype.hasOwnProperty.call(arguments[i], attr) && typeof result[attr] === "undefined") {
            result[attr] = arguments[i][attr];
          }
        }
      }
      return result;
    };
    exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
      var promise = external.Promise.resolve(inputData).then(function(data) {
        var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
        if (isBlob && typeof FileReader !== "undefined") {
          return new external.Promise(function(resolve, reject) {
            var reader = new FileReader();
            reader.onload = function(e) {
              resolve(e.target.result);
            };
            reader.onerror = function(e) {
              reject(e.target.error);
            };
            reader.readAsArrayBuffer(data);
          });
        } else {
          return data;
        }
      });
      return promise.then(function(data) {
        var dataType = exports.getTypeOf(data);
        if (!dataType) {
          return external.Promise.reject(
            new Error("Can't read the data of '" + name + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
          );
        }
        if (dataType === "arraybuffer") {
          data = exports.transformTo("uint8array", data);
        } else if (dataType === "string") {
          if (isBase64) {
            data = base64.decode(data);
          } else if (isBinary) {
            if (isOptimizedBinaryString !== true) {
              data = string2binary(data);
            }
          }
        }
        return data;
      });
    };
  }
});

// node_modules/jszip/lib/stream/GenericWorker.js
var require_GenericWorker = __commonJS({
  "node_modules/jszip/lib/stream/GenericWorker.js"(exports, module2) {
    "use strict";
    function GenericWorker(name) {
      this.name = name || "default";
      this.streamInfo = {};
      this.generatedError = null;
      this.extraStreamInfo = {};
      this.isPaused = true;
      this.isFinished = false;
      this.isLocked = false;
      this._listeners = {
        "data": [],
        "end": [],
        "error": []
      };
      this.previous = null;
    }
    __name(GenericWorker, "GenericWorker");
    GenericWorker.prototype = {
      /**
       * Push a chunk to the next workers.
       * @param {Object} chunk the chunk to push
       */
      push: function(chunk) {
        this.emit("data", chunk);
      },
      /**
       * End the stream.
       * @return {Boolean} true if this call ended the worker, false otherwise.
       */
      end: function() {
        if (this.isFinished) {
          return false;
        }
        this.flush();
        try {
          this.emit("end");
          this.cleanUp();
          this.isFinished = true;
        } catch (e) {
          this.emit("error", e);
        }
        return true;
      },
      /**
       * End the stream with an error.
       * @param {Error} e the error which caused the premature end.
       * @return {Boolean} true if this call ended the worker with an error, false otherwise.
       */
      error: function(e) {
        if (this.isFinished) {
          return false;
        }
        if (this.isPaused) {
          this.generatedError = e;
        } else {
          this.isFinished = true;
          this.emit("error", e);
          if (this.previous) {
            this.previous.error(e);
          }
          this.cleanUp();
        }
        return true;
      },
      /**
       * Add a callback on an event.
       * @param {String} name the name of the event (data, end, error)
       * @param {Function} listener the function to call when the event is triggered
       * @return {GenericWorker} the current object for chainability
       */
      on: function(name, listener) {
        this._listeners[name].push(listener);
        return this;
      },
      /**
       * Clean any references when a worker is ending.
       */
      cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null;
        this._listeners = [];
      },
      /**
       * Trigger an event. This will call registered callback with the provided arg.
       * @param {String} name the name of the event (data, end, error)
       * @param {Object} arg the argument to call the callback with.
       */
      emit: function(name, arg) {
        if (this._listeners[name]) {
          for (var i = 0; i < this._listeners[name].length; i++) {
            this._listeners[name][i].call(this, arg);
          }
        }
      },
      /**
       * Chain a worker with an other.
       * @param {Worker} next the worker receiving events from the current one.
       * @return {worker} the next worker for chainability
       */
      pipe: function(next) {
        return next.registerPrevious(this);
      },
      /**
       * Same as `pipe` in the other direction.
       * Using an API with `pipe(next)` is very easy.
       * Implementing the API with the point of view of the next one registering
       * a source is easier, see the ZipFileWorker.
       * @param {Worker} previous the previous worker, sending events to this one
       * @return {Worker} the current worker for chainability
       */
      registerPrevious: function(previous) {
        if (this.isLocked) {
          throw new Error("The stream '" + this + "' has already been used.");
        }
        this.streamInfo = previous.streamInfo;
        this.mergeStreamInfo();
        this.previous = previous;
        var self2 = this;
        previous.on("data", function(chunk) {
          self2.processChunk(chunk);
        });
        previous.on("end", function() {
          self2.end();
        });
        previous.on("error", function(e) {
          self2.error(e);
        });
        return this;
      },
      /**
       * Pause the stream so it doesn't send events anymore.
       * @return {Boolean} true if this call paused the worker, false otherwise.
       */
      pause: function() {
        if (this.isPaused || this.isFinished) {
          return false;
        }
        this.isPaused = true;
        if (this.previous) {
          this.previous.pause();
        }
        return true;
      },
      /**
       * Resume a paused stream.
       * @return {Boolean} true if this call resumed the worker, false otherwise.
       */
      resume: function() {
        if (!this.isPaused || this.isFinished) {
          return false;
        }
        this.isPaused = false;
        var withError = false;
        if (this.generatedError) {
          this.error(this.generatedError);
          withError = true;
        }
        if (this.previous) {
          this.previous.resume();
        }
        return !withError;
      },
      /**
       * Flush any remaining bytes as the stream is ending.
       */
      flush: function() {
      },
      /**
       * Process a chunk. This is usually the method overridden.
       * @param {Object} chunk the chunk to process.
       */
      processChunk: function(chunk) {
        this.push(chunk);
      },
      /**
       * Add a key/value to be added in the workers chain streamInfo once activated.
       * @param {String} key the key to use
       * @param {Object} value the associated value
       * @return {Worker} the current worker for chainability
       */
      withStreamInfo: function(key, value) {
        this.extraStreamInfo[key] = value;
        this.mergeStreamInfo();
        return this;
      },
      /**
       * Merge this worker's streamInfo into the chain's streamInfo.
       */
      mergeStreamInfo: function() {
        for (var key in this.extraStreamInfo) {
          if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {
            continue;
          }
          this.streamInfo[key] = this.extraStreamInfo[key];
        }
      },
      /**
       * Lock the stream to prevent further updates on the workers chain.
       * After calling this method, all calls to pipe will fail.
       */
      lock: function() {
        if (this.isLocked) {
          throw new Error("The stream '" + this + "' has already been used.");
        }
        this.isLocked = true;
        if (this.previous) {
          this.previous.lock();
        }
      },
      /**
       *
       * Pretty print the workers chain.
       */
      toString: function() {
        var me = "Worker " + this.name;
        if (this.previous) {
          return this.previous + " -> " + me;
        } else {
          return me;
        }
      }
    };
    module2.exports = GenericWorker;
  }
});

// node_modules/jszip/lib/utf8.js
var require_utf8 = __commonJS({
  "node_modules/jszip/lib/utf8.js"(exports) {
    "use strict";
    var utils = require_utils();
    var support = require_support();
    var nodejsUtils = require_nodejsUtils();
    var GenericWorker = require_GenericWorker();
    var _utf8len = new Array(256);
    for (i = 0; i < 256; i++) {
      _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
    }
    var i;
    _utf8len[254] = _utf8len[254] = 1;
    var string2buf = /* @__PURE__ */ __name(function(str) {
      var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      if (support.uint8array) {
        buf = new Uint8Array(buf_len);
      } else {
        buf = new Array(buf_len);
      }
      for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i2++] = c;
        } else if (c < 2048) {
          buf[i2++] = 192 | c >>> 6;
          buf[i2++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i2++] = 224 | c >>> 12;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        } else {
          buf[i2++] = 240 | c >>> 18;
          buf[i2++] = 128 | c >>> 12 & 63;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        }
      }
      return buf;
    }, "string2buf");
    var utf8border = /* @__PURE__ */ __name(function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    }, "utf8border");
    var buf2string = /* @__PURE__ */ __name(function(buf) {
      var i2, out, c, c_len;
      var len = buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i2 = 0; i2 < len; ) {
        c = buf[i2++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i2 += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i2 < len) {
          c = c << 6 | buf[i2++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      if (utf16buf.length !== out) {
        if (utf16buf.subarray) {
          utf16buf = utf16buf.subarray(0, out);
        } else {
          utf16buf.length = out;
        }
      }
      return utils.applyFromCharCode(utf16buf);
    }, "buf2string");
    exports.utf8encode = /* @__PURE__ */ __name(function utf8encode(str) {
      if (support.nodebuffer) {
        return nodejsUtils.newBufferFrom(str, "utf-8");
      }
      return string2buf(str);
    }, "utf8encode");
    exports.utf8decode = /* @__PURE__ */ __name(function utf8decode(buf) {
      if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
      }
      buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
      return buf2string(buf);
    }, "utf8decode");
    function Utf8DecodeWorker() {
      GenericWorker.call(this, "utf-8 decode");
      this.leftOver = null;
    }
    __name(Utf8DecodeWorker, "Utf8DecodeWorker");
    utils.inherits(Utf8DecodeWorker, GenericWorker);
    Utf8DecodeWorker.prototype.processChunk = function(chunk) {
      var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);
      if (this.leftOver && this.leftOver.length) {
        if (support.uint8array) {
          var previousData = data;
          data = new Uint8Array(previousData.length + this.leftOver.length);
          data.set(this.leftOver, 0);
          data.set(previousData, this.leftOver.length);
        } else {
          data = this.leftOver.concat(data);
        }
        this.leftOver = null;
      }
      var nextBoundary = utf8border(data);
      var usableData = data;
      if (nextBoundary !== data.length) {
        if (support.uint8array) {
          usableData = data.subarray(0, nextBoundary);
          this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
          usableData = data.slice(0, nextBoundary);
          this.leftOver = data.slice(nextBoundary, data.length);
        }
      }
      this.push({
        data: exports.utf8decode(usableData),
        meta: chunk.meta
      });
    };
    Utf8DecodeWorker.prototype.flush = function() {
      if (this.leftOver && this.leftOver.length) {
        this.push({
          data: exports.utf8decode(this.leftOver),
          meta: {}
        });
        this.leftOver = null;
      }
    };
    exports.Utf8DecodeWorker = Utf8DecodeWorker;
    function Utf8EncodeWorker() {
      GenericWorker.call(this, "utf-8 encode");
    }
    __name(Utf8EncodeWorker, "Utf8EncodeWorker");
    utils.inherits(Utf8EncodeWorker, GenericWorker);
    Utf8EncodeWorker.prototype.processChunk = function(chunk) {
      this.push({
        data: exports.utf8encode(chunk.data),
        meta: chunk.meta
      });
    };
    exports.Utf8EncodeWorker = Utf8EncodeWorker;
  }
});

// node_modules/jszip/lib/stream/ConvertWorker.js
var require_ConvertWorker = __commonJS({
  "node_modules/jszip/lib/stream/ConvertWorker.js"(exports, module2) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    var utils = require_utils();
    function ConvertWorker(destType) {
      GenericWorker.call(this, "ConvertWorker to " + destType);
      this.destType = destType;
    }
    __name(ConvertWorker, "ConvertWorker");
    utils.inherits(ConvertWorker, GenericWorker);
    ConvertWorker.prototype.processChunk = function(chunk) {
      this.push({
        data: utils.transformTo(this.destType, chunk.data),
        meta: chunk.meta
      });
    };
    module2.exports = ConvertWorker;
  }
});

// node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js
var require_NodejsStreamOutputAdapter = __commonJS({
  "node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js"(exports, module2) {
    "use strict";
    var Readable = require_readable2().Readable;
    var utils = require_utils();
    utils.inherits(NodejsStreamOutputAdapter, Readable);
    function NodejsStreamOutputAdapter(helper, options, updateCb) {
      Readable.call(this, options);
      this._helper = helper;
      var self2 = this;
      helper.on("data", function(data, meta) {
        if (!self2.push(data)) {
          self2._helper.pause();
        }
        if (updateCb) {
          updateCb(meta);
        }
      }).on("error", function(e) {
        self2.emit("error", e);
      }).on("end", function() {
        self2.push(null);
      });
    }
    __name(NodejsStreamOutputAdapter, "NodejsStreamOutputAdapter");
    NodejsStreamOutputAdapter.prototype._read = function() {
      this._helper.resume();
    };
    module2.exports = NodejsStreamOutputAdapter;
  }
});

// node_modules/jszip/lib/stream/StreamHelper.js
var require_StreamHelper = __commonJS({
  "node_modules/jszip/lib/stream/StreamHelper.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var ConvertWorker = require_ConvertWorker();
    var GenericWorker = require_GenericWorker();
    var base64 = require_base64();
    var support = require_support();
    var external = require_external();
    var NodejsStreamOutputAdapter = null;
    if (support.nodestream) {
      try {
        NodejsStreamOutputAdapter = require_NodejsStreamOutputAdapter();
      } catch (e) {
      }
    }
    function transformZipOutput(type, content, mimeType) {
      switch (type) {
        case "blob":
          return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
        case "base64":
          return base64.encode(content);
        default:
          return utils.transformTo(type, content);
      }
    }
    __name(transformZipOutput, "transformZipOutput");
    function concat2(type, dataArray) {
      var i, index = 0, res = null, totalLength = 0;
      for (i = 0; i < dataArray.length; i++) {
        totalLength += dataArray[i].length;
      }
      switch (type) {
        case "string":
          return dataArray.join("");
        case "array":
          return Array.prototype.concat.apply([], dataArray);
        case "uint8array":
          res = new Uint8Array(totalLength);
          for (i = 0; i < dataArray.length; i++) {
            res.set(dataArray[i], index);
            index += dataArray[i].length;
          }
          return res;
        case "nodebuffer":
          return Buffer.concat(dataArray);
        default:
          throw new Error("concat : unsupported type '" + type + "'");
      }
    }
    __name(concat2, "concat");
    function accumulate(helper, updateCallback) {
      return new external.Promise(function(resolve, reject) {
        var dataArray = [];
        var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;
        helper.on("data", function(data, meta) {
          dataArray.push(data);
          if (updateCallback) {
            updateCallback(meta);
          }
        }).on("error", function(err) {
          dataArray = [];
          reject(err);
        }).on("end", function() {
          try {
            var result = transformZipOutput(resultType, concat2(chunkType, dataArray), mimeType);
            resolve(result);
          } catch (e) {
            reject(e);
          }
          dataArray = [];
        }).resume();
      });
    }
    __name(accumulate, "accumulate");
    function StreamHelper(worker, outputType, mimeType) {
      var internalType = outputType;
      switch (outputType) {
        case "blob":
        case "arraybuffer":
          internalType = "uint8array";
          break;
        case "base64":
          internalType = "string";
          break;
      }
      try {
        this._internalType = internalType;
        this._outputType = outputType;
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        worker.lock();
      } catch (e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
      }
    }
    __name(StreamHelper, "StreamHelper");
    StreamHelper.prototype = {
      /**
       * Listen a StreamHelper, accumulate its content and concatenate it into a
       * complete block.
       * @param {Function} updateCb the update callback.
       * @return Promise the promise for the accumulation.
       */
      accumulate: function(updateCb) {
        return accumulate(this, updateCb);
      },
      /**
       * Add a listener on an event triggered on a stream.
       * @param {String} evt the name of the event
       * @param {Function} fn the listener
       * @return {StreamHelper} the current helper.
       */
      on: function(evt, fn) {
        var self2 = this;
        if (evt === "data") {
          this._worker.on(evt, function(chunk) {
            fn.call(self2, chunk.data, chunk.meta);
          });
        } else {
          this._worker.on(evt, function() {
            utils.delay(fn, arguments, self2);
          });
        }
        return this;
      },
      /**
       * Resume the flow of chunks.
       * @return {StreamHelper} the current helper.
       */
      resume: function() {
        utils.delay(this._worker.resume, [], this._worker);
        return this;
      },
      /**
       * Pause the flow of chunks.
       * @return {StreamHelper} the current helper.
       */
      pause: function() {
        this._worker.pause();
        return this;
      },
      /**
       * Return a nodejs stream for this helper.
       * @param {Function} updateCb the update callback.
       * @return {NodejsStreamOutputAdapter} the nodejs stream.
       */
      toNodejsStream: function(updateCb) {
        utils.checkSupport("nodestream");
        if (this._outputType !== "nodebuffer") {
          throw new Error(this._outputType + " is not supported by this method");
        }
        return new NodejsStreamOutputAdapter(this, {
          objectMode: this._outputType !== "nodebuffer"
        }, updateCb);
      }
    };
    module2.exports = StreamHelper;
  }
});

// node_modules/jszip/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/jszip/lib/defaults.js"(exports) {
    "use strict";
    exports.base64 = false;
    exports.binary = false;
    exports.dir = false;
    exports.createFolders = true;
    exports.date = null;
    exports.compression = null;
    exports.compressionOptions = null;
    exports.comment = null;
    exports.unixPermissions = null;
    exports.dosPermissions = null;
  }
});

// node_modules/jszip/lib/stream/DataWorker.js
var require_DataWorker = __commonJS({
  "node_modules/jszip/lib/stream/DataWorker.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var DEFAULT_BLOCK_SIZE = 16 * 1024;
    function DataWorker(dataP) {
      GenericWorker.call(this, "DataWorker");
      var self2 = this;
      this.dataIsReady = false;
      this.index = 0;
      this.max = 0;
      this.data = null;
      this.type = "";
      this._tickScheduled = false;
      dataP.then(function(data) {
        self2.dataIsReady = true;
        self2.data = data;
        self2.max = data && data.length || 0;
        self2.type = utils.getTypeOf(data);
        if (!self2.isPaused) {
          self2._tickAndRepeat();
        }
      }, function(e) {
        self2.error(e);
      });
    }
    __name(DataWorker, "DataWorker");
    utils.inherits(DataWorker, GenericWorker);
    DataWorker.prototype.cleanUp = function() {
      GenericWorker.prototype.cleanUp.call(this);
      this.data = null;
    };
    DataWorker.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (!this._tickScheduled && this.dataIsReady) {
        this._tickScheduled = true;
        utils.delay(this._tickAndRepeat, [], this);
      }
      return true;
    };
    DataWorker.prototype._tickAndRepeat = function() {
      this._tickScheduled = false;
      if (this.isPaused || this.isFinished) {
        return;
      }
      this._tick();
      if (!this.isFinished) {
        utils.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
      }
    };
    DataWorker.prototype._tick = function() {
      if (this.isPaused || this.isFinished) {
        return false;
      }
      var size = DEFAULT_BLOCK_SIZE;
      var data = null, nextIndex = Math.min(this.max, this.index + size);
      if (this.index >= this.max) {
        return this.end();
      } else {
        switch (this.type) {
          case "string":
            data = this.data.substring(this.index, nextIndex);
            break;
          case "uint8array":
            data = this.data.subarray(this.index, nextIndex);
            break;
          case "array":
          case "nodebuffer":
            data = this.data.slice(this.index, nextIndex);
            break;
        }
        this.index = nextIndex;
        return this.push({
          data,
          meta: {
            percent: this.max ? this.index / this.max * 100 : 0
          }
        });
      }
    };
    module2.exports = DataWorker;
  }
});

// node_modules/jszip/lib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/jszip/lib/crc32.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    __name(makeTable, "makeTable");
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc = crc ^ -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    __name(crc32, "crc32");
    function crc32str(crc, str, len, pos) {
      var t = crcTable, end = pos + len;
      crc = crc ^ -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 255];
      }
      return crc ^ -1;
    }
    __name(crc32str, "crc32str");
    module2.exports = /* @__PURE__ */ __name(function crc32wrapper(input, crc) {
      if (typeof input === "undefined" || !input.length) {
        return 0;
      }
      var isArray = utils.getTypeOf(input) !== "string";
      if (isArray) {
        return crc32(crc | 0, input, input.length, 0);
      } else {
        return crc32str(crc | 0, input, input.length, 0);
      }
    }, "crc32wrapper");
  }
});

// node_modules/jszip/lib/stream/Crc32Probe.js
var require_Crc32Probe = __commonJS({
  "node_modules/jszip/lib/stream/Crc32Probe.js"(exports, module2) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    var crc32 = require_crc32();
    var utils = require_utils();
    function Crc32Probe() {
      GenericWorker.call(this, "Crc32Probe");
      this.withStreamInfo("crc32", 0);
    }
    __name(Crc32Probe, "Crc32Probe");
    utils.inherits(Crc32Probe, GenericWorker);
    Crc32Probe.prototype.processChunk = function(chunk) {
      this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
      this.push(chunk);
    };
    module2.exports = Crc32Probe;
  }
});

// node_modules/jszip/lib/stream/DataLengthProbe.js
var require_DataLengthProbe = __commonJS({
  "node_modules/jszip/lib/stream/DataLengthProbe.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    function DataLengthProbe(propName) {
      GenericWorker.call(this, "DataLengthProbe for " + propName);
      this.propName = propName;
      this.withStreamInfo(propName, 0);
    }
    __name(DataLengthProbe, "DataLengthProbe");
    utils.inherits(DataLengthProbe, GenericWorker);
    DataLengthProbe.prototype.processChunk = function(chunk) {
      if (chunk) {
        var length = this.streamInfo[this.propName] || 0;
        this.streamInfo[this.propName] = length + chunk.data.length;
      }
      GenericWorker.prototype.processChunk.call(this, chunk);
    };
    module2.exports = DataLengthProbe;
  }
});

// node_modules/jszip/lib/compressedObject.js
var require_compressedObject = __commonJS({
  "node_modules/jszip/lib/compressedObject.js"(exports, module2) {
    "use strict";
    var external = require_external();
    var DataWorker = require_DataWorker();
    var Crc32Probe = require_Crc32Probe();
    var DataLengthProbe = require_DataLengthProbe();
    function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
      this.compressedSize = compressedSize;
      this.uncompressedSize = uncompressedSize;
      this.crc32 = crc32;
      this.compression = compression;
      this.compressedContent = data;
    }
    __name(CompressedObject, "CompressedObject");
    CompressedObject.prototype = {
      /**
       * Create a worker to get the uncompressed content.
       * @return {GenericWorker} the worker.
       */
      getContentWorker: function() {
        var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
        var that = this;
        worker.on("end", function() {
          if (this.streamInfo["data_length"] !== that.uncompressedSize) {
            throw new Error("Bug : uncompressed data size mismatch");
          }
        });
        return worker;
      },
      /**
       * Create a worker to get the compressed content.
       * @return {GenericWorker} the worker.
       */
      getCompressedWorker: function() {
        return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      }
    };
    CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
      return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
    };
    module2.exports = CompressedObject;
  }
});

// node_modules/jszip/lib/zipObject.js
var require_zipObject = __commonJS({
  "node_modules/jszip/lib/zipObject.js"(exports, module2) {
    "use strict";
    var StreamHelper = require_StreamHelper();
    var DataWorker = require_DataWorker();
    var utf8 = require_utf8();
    var CompressedObject = require_compressedObject();
    var GenericWorker = require_GenericWorker();
    var ZipObject = /* @__PURE__ */ __name(function(name, data, options) {
      this.name = name;
      this.dir = options.dir;
      this.date = options.date;
      this.comment = options.comment;
      this.unixPermissions = options.unixPermissions;
      this.dosPermissions = options.dosPermissions;
      this._data = data;
      this._dataBinary = options.binary;
      this.options = {
        compression: options.compression,
        compressionOptions: options.compressionOptions
      };
    }, "ZipObject");
    ZipObject.prototype = {
      /**
       * Create an internal stream for the content of this object.
       * @param {String} type the type of each chunk.
       * @return StreamHelper the stream.
       */
      internalStream: function(type) {
        var result = null, outputType = "string";
        try {
          if (!type) {
            throw new Error("No output type specified.");
          }
          outputType = type.toLowerCase();
          var askUnicodeString = outputType === "string" || outputType === "text";
          if (outputType === "binarystring" || outputType === "text") {
            outputType = "string";
          }
          result = this._decompressWorker();
          var isUnicodeString = !this._dataBinary;
          if (isUnicodeString && !askUnicodeString) {
            result = result.pipe(new utf8.Utf8EncodeWorker());
          }
          if (!isUnicodeString && askUnicodeString) {
            result = result.pipe(new utf8.Utf8DecodeWorker());
          }
        } catch (e) {
          result = new GenericWorker("error");
          result.error(e);
        }
        return new StreamHelper(result, outputType, "");
      },
      /**
       * Prepare the content in the asked type.
       * @param {String} type the type of the result.
       * @param {Function} onUpdate a function to call on each internal update.
       * @return Promise the promise of the result.
       */
      async: function(type, onUpdate) {
        return this.internalStream(type).accumulate(onUpdate);
      },
      /**
       * Prepare the content as a nodejs stream.
       * @param {String} type the type of each chunk.
       * @param {Function} onUpdate a function to call on each internal update.
       * @return Stream the stream.
       */
      nodeStream: function(type, onUpdate) {
        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
      },
      /**
       * Return a worker for the compressed content.
       * @private
       * @param {Object} compression the compression object to use.
       * @param {Object} compressionOptions the options to use when compressing.
       * @return Worker the worker.
       */
      _compressWorker: function(compression, compressionOptions) {
        if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
          return this._data.getCompressedWorker();
        } else {
          var result = this._decompressWorker();
          if (!this._dataBinary) {
            result = result.pipe(new utf8.Utf8EncodeWorker());
          }
          return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
        }
      },
      /**
       * Return a worker for the decompressed content.
       * @private
       * @return Worker the worker.
       */
      _decompressWorker: function() {
        if (this._data instanceof CompressedObject) {
          return this._data.getContentWorker();
        } else if (this._data instanceof GenericWorker) {
          return this._data;
        } else {
          return new DataWorker(this._data);
        }
      }
    };
    var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
    var removedFn = /* @__PURE__ */ __name(function() {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    }, "removedFn");
    for (i = 0; i < removedMethods.length; i++) {
      ZipObject.prototype[removedMethods[i]] = removedFn;
    }
    var i;
    module2.exports = ZipObject;
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    __name(_has, "_has");
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    __name(zero, "zero");
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    __name(StaticTreeDesc, "StaticTreeDesc");
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    __name(TreeDesc, "TreeDesc");
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    __name(d_code, "d_code");
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    }
    __name(put_short, "put_short");
    function send_bits(s, value, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    }
    __name(send_bits, "send_bits");
    function send_code(s, c, tree) {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    }
    __name(send_code, "send_code");
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    __name(bi_reverse, "bi_reverse");
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    __name(bi_flush, "bi_flush");
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    __name(gen_bitlen, "gen_bitlen");
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    __name(gen_codes, "gen_codes");
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    __name(tr_static_init, "tr_static_init");
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    __name(init_block, "init_block");
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    __name(bi_windup, "bi_windup");
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    __name(copy_block, "copy_block");
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    __name(smaller, "smaller");
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    __name(pqdownheap, "pqdownheap");
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    __name(compress_block, "compress_block");
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    __name(build_tree, "build_tree");
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    __name(scan_tree, "scan_tree");
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    __name(send_tree, "send_tree");
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    __name(build_bl_tree, "build_bl_tree");
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    __name(send_all_trees, "send_all_trees");
    function detect_data_type(s) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    __name(detect_data_type, "detect_data_type");
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    __name(_tr_init, "_tr_init");
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    __name(_tr_stored_block, "_tr_stored_block");
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    __name(_tr_align, "_tr_align");
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    __name(_tr_flush_block, "_tr_flush_block");
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    __name(_tr_tally, "_tr_tally");
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports, module2) {
    "use strict";
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    __name(adler32, "adler32");
    module2.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc322 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports, module2) {
    "use strict";
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    __name(makeTable, "makeTable");
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    __name(crc32, "crc32");
    module2.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports, module2) {
    "use strict";
    module2.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    __name(err, "err");
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    __name(rank, "rank");
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    __name(zero, "zero");
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    __name(flush_pending, "flush_pending");
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    __name(flush_block_only, "flush_block_only");
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    __name(put_byte, "put_byte");
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    }
    __name(putShortMSB, "putShortMSB");
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    __name(read_buf, "read_buf");
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    __name(longest_match, "longest_match");
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    __name(fill_window, "fill_window");
    function deflate_stored(s, flush) {
      var max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    __name(deflate_stored, "deflate_stored");
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    __name(deflate_fast, "deflate_fast");
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    __name(deflate_slow, "deflate_slow");
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    __name(deflate_rle, "deflate_rle");
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    __name(deflate_huff, "deflate_huff");
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    __name(Config, "Config");
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    __name(lm_init, "lm_init");
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    __name(DeflateState, "DeflateState");
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    __name(deflateResetKeep, "deflateResetKeep");
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    __name(deflateReset, "deflateReset");
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    __name(deflateSetHeader, "deflateSetHeader");
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    __name(deflateInit2, "deflateInit2");
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    __name(deflateInit, "deflateInit");
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    __name(deflate, "deflate");
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    __name(deflateEnd, "deflateEnd");
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    __name(deflateSetDictionary, "deflateSetDictionary");
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports) {
    "use strict";
    var utils = require_common();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function(str) {
      var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    }
    __name(buf2binstring, "buf2binstring");
    exports.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i = 0, len = buf.length; i < len; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    };
    exports.buf2string = function(buf, max) {
      var i, out, c, c_len;
      var len = max || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports.utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports, module2) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    __name(ZStream, "ZStream");
    module2.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate))
        return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    __name(Deflate, "Deflate");
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    __name(deflate, "deflate");
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    __name(deflateRaw, "deflateRaw");
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    __name(gzip, "gzip");
    exports.Deflate = Deflate;
    exports.deflate = deflate;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports, module2) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module2.exports = /* @__PURE__ */ __name(function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    }, "inflate_fast");
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports, module2) {
    "use strict";
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module2.exports = /* @__PURE__ */ __name(function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    }, "inflate_table");
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    __name(zswap32, "zswap32");
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    __name(InflateState, "InflateState");
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    __name(inflateResetKeep, "inflateResetKeep");
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    __name(inflateReset, "inflateReset");
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    __name(inflateReset2, "inflateReset2");
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    __name(inflateInit2, "inflateInit2");
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    __name(inflateInit, "inflateInit");
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    __name(fixedtables, "fixedtables");
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    __name(updatewindow, "updatewindow");
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    __name(inflate, "inflate");
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    __name(inflateEnd, "inflateEnd");
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    __name(inflateGetHeader, "inflateGetHeader");
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    __name(inflateSetDictionary, "inflateSetDictionary");
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports, module2) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    __name(GZheader, "GZheader");
    module2.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var c = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate))
        return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    __name(Inflate, "Inflate");
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    __name(inflate, "inflate");
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    __name(inflateRaw, "inflateRaw");
    exports.Inflate = Inflate;
    exports.inflate = inflate;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate;
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports, module2) {
    "use strict";
    var assign = require_common().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants = require_constants();
    var pako = {};
    assign(pako, deflate, inflate, constants);
    module2.exports = pako;
  }
});

// node_modules/jszip/lib/flate.js
var require_flate = __commonJS({
  "node_modules/jszip/lib/flate.js"(exports) {
    "use strict";
    var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
    var pako = require_pako();
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
    exports.magic = "\b\0";
    function FlateWorker(action, options) {
      GenericWorker.call(this, "FlateWorker/" + action);
      this._pako = null;
      this._pakoAction = action;
      this._pakoOptions = options;
      this.meta = {};
    }
    __name(FlateWorker, "FlateWorker");
    utils.inherits(FlateWorker, GenericWorker);
    FlateWorker.prototype.processChunk = function(chunk) {
      this.meta = chunk.meta;
      if (this._pako === null) {
        this._createPako();
      }
      this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
    };
    FlateWorker.prototype.flush = function() {
      GenericWorker.prototype.flush.call(this);
      if (this._pako === null) {
        this._createPako();
      }
      this._pako.push([], true);
    };
    FlateWorker.prototype.cleanUp = function() {
      GenericWorker.prototype.cleanUp.call(this);
      this._pako = null;
    };
    FlateWorker.prototype._createPako = function() {
      this._pako = new pako[this._pakoAction]({
        raw: true,
        level: this._pakoOptions.level || -1
        // default compression
      });
      var self2 = this;
      this._pako.onData = function(data) {
        self2.push({
          data,
          meta: self2.meta
        });
      };
    };
    exports.compressWorker = function(compressionOptions) {
      return new FlateWorker("Deflate", compressionOptions);
    };
    exports.uncompressWorker = function() {
      return new FlateWorker("Inflate", {});
    };
  }
});

// node_modules/jszip/lib/compressions.js
var require_compressions = __commonJS({
  "node_modules/jszip/lib/compressions.js"(exports) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    exports.STORE = {
      magic: "\0\0",
      compressWorker: function() {
        return new GenericWorker("STORE compression");
      },
      uncompressWorker: function() {
        return new GenericWorker("STORE decompression");
      }
    };
    exports.DEFLATE = require_flate();
  }
});

// node_modules/jszip/lib/signature.js
var require_signature = __commonJS({
  "node_modules/jszip/lib/signature.js"(exports) {
    "use strict";
    exports.LOCAL_FILE_HEADER = "PK";
    exports.CENTRAL_FILE_HEADER = "PK";
    exports.CENTRAL_DIRECTORY_END = "PK";
    exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
    exports.ZIP64_CENTRAL_DIRECTORY_END = "PK";
    exports.DATA_DESCRIPTOR = "PK\x07\b";
  }
});

// node_modules/jszip/lib/generate/ZipFileWorker.js
var require_ZipFileWorker = __commonJS({
  "node_modules/jszip/lib/generate/ZipFileWorker.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var utf8 = require_utf8();
    var crc32 = require_crc32();
    var signature = require_signature();
    var decToHex = /* @__PURE__ */ __name(function(dec, bytes) {
      var hex = "", i;
      for (i = 0; i < bytes; i++) {
        hex += String.fromCharCode(dec & 255);
        dec = dec >>> 8;
      }
      return hex;
    }, "decToHex");
    var generateUnixExternalFileAttr = /* @__PURE__ */ __name(function(unixPermissions, isDir) {
      var result = unixPermissions;
      if (!unixPermissions) {
        result = isDir ? 16893 : 33204;
      }
      return (result & 65535) << 16;
    }, "generateUnixExternalFileAttr");
    var generateDosExternalFileAttr = /* @__PURE__ */ __name(function(dosPermissions) {
      return (dosPermissions || 0) & 63;
    }, "generateDosExternalFileAttr");
    var generateZipParts = /* @__PURE__ */ __name(function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
      var file = streamInfo["file"], compression = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo("string", encodeFileName(file.name)), utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils.transformTo("string", encodeFileName(comment)), utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir = file.dir, date = file.date;
      var dataInfo = {
        crc32: 0,
        compressedSize: 0,
        uncompressedSize: 0
      };
      if (!streamedContent || streamingEnded) {
        dataInfo.crc32 = streamInfo["crc32"];
        dataInfo.compressedSize = streamInfo["compressedSize"];
        dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
      }
      var bitflag = 0;
      if (streamedContent) {
        bitflag |= 8;
      }
      if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
        bitflag |= 2048;
      }
      var extFileAttr = 0;
      var versionMadeBy = 0;
      if (dir) {
        extFileAttr |= 16;
      }
      if (platform === "UNIX") {
        versionMadeBy = 798;
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
      } else {
        versionMadeBy = 20;
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
      }
      dosTime = date.getUTCHours();
      dosTime = dosTime << 6;
      dosTime = dosTime | date.getUTCMinutes();
      dosTime = dosTime << 5;
      dosTime = dosTime | date.getUTCSeconds() / 2;
      dosDate = date.getUTCFullYear() - 1980;
      dosDate = dosDate << 4;
      dosDate = dosDate | date.getUTCMonth() + 1;
      dosDate = dosDate << 5;
      dosDate = dosDate | date.getUTCDate();
      if (useUTF8ForFileName) {
        unicodePathExtraField = // Version
        decToHex(1, 1) + // NameCRC32
        decToHex(crc32(encodedFileName), 4) + // UnicodeName
        utfEncodedFileName;
        extraFields += // Info-ZIP Unicode Path Extra Field
        "up" + // size
        decToHex(unicodePathExtraField.length, 2) + // content
        unicodePathExtraField;
      }
      if (useUTF8ForComment) {
        unicodeCommentExtraField = // Version
        decToHex(1, 1) + // CommentCRC32
        decToHex(crc32(encodedComment), 4) + // UnicodeName
        utfEncodedComment;
        extraFields += // Info-ZIP Unicode Path Extra Field
        "uc" + // size
        decToHex(unicodeCommentExtraField.length, 2) + // content
        unicodeCommentExtraField;
      }
      var header = "";
      header += "\n\0";
      header += decToHex(bitflag, 2);
      header += compression.magic;
      header += decToHex(dosTime, 2);
      header += decToHex(dosDate, 2);
      header += decToHex(dataInfo.crc32, 4);
      header += decToHex(dataInfo.compressedSize, 4);
      header += decToHex(dataInfo.uncompressedSize, 4);
      header += decToHex(encodedFileName.length, 2);
      header += decToHex(extraFields.length, 2);
      var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
      var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)
      decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
      header + // file comment length
      decToHex(encodedComment.length, 2) + // disk number start
      "\0\0\0\0" + // external file attributes
      decToHex(extFileAttr, 4) + // relative offset of local header
      decToHex(offset, 4) + // file name
      encodedFileName + // extra field
      extraFields + // file comment
      encodedComment;
      return {
        fileRecord,
        dirRecord
      };
    }, "generateZipParts");
    var generateCentralDirectoryEnd = /* @__PURE__ */ __name(function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
      var dirEnd = "";
      var encodedComment = utils.transformTo("string", encodeFileName(comment));
      dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk
      "\0\0\0\0" + // total number of entries in the central directory on this disk
      decToHex(entriesCount, 2) + // total number of entries in the central directory
      decToHex(entriesCount, 2) + // size of the central directory   4 bytes
      decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
      decToHex(localDirLength, 4) + // .ZIP file comment length
      decToHex(encodedComment.length, 2) + // .ZIP file comment
      encodedComment;
      return dirEnd;
    }, "generateCentralDirectoryEnd");
    var generateDataDescriptors = /* @__PURE__ */ __name(function(streamInfo) {
      var descriptor = "";
      descriptor = signature.DATA_DESCRIPTOR + // crc-32                          4 bytes
      decToHex(streamInfo["crc32"], 4) + // compressed size                 4 bytes
      decToHex(streamInfo["compressedSize"], 4) + // uncompressed size               4 bytes
      decToHex(streamInfo["uncompressedSize"], 4);
      return descriptor;
    }, "generateDataDescriptors");
    function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
      GenericWorker.call(this, "ZipFileWorker");
      this.bytesWritten = 0;
      this.zipComment = comment;
      this.zipPlatform = platform;
      this.encodeFileName = encodeFileName;
      this.streamFiles = streamFiles;
      this.accumulate = false;
      this.contentBuffer = [];
      this.dirRecords = [];
      this.currentSourceOffset = 0;
      this.entriesCount = 0;
      this.currentFile = null;
      this._sources = [];
    }
    __name(ZipFileWorker, "ZipFileWorker");
    utils.inherits(ZipFileWorker, GenericWorker);
    ZipFileWorker.prototype.push = function(chunk) {
      var currentFilePercent = chunk.meta.percent || 0;
      var entriesCount = this.entriesCount;
      var remainingFiles = this._sources.length;
      if (this.accumulate) {
        this.contentBuffer.push(chunk);
      } else {
        this.bytesWritten += chunk.data.length;
        GenericWorker.prototype.push.call(this, {
          data: chunk.data,
          meta: {
            currentFile: this.currentFile,
            percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
          }
        });
      }
    };
    ZipFileWorker.prototype.openedSource = function(streamInfo) {
      this.currentSourceOffset = this.bytesWritten;
      this.currentFile = streamInfo["file"].name;
      var streamedContent = this.streamFiles && !streamInfo["file"].dir;
      if (streamedContent) {
        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.push({
          data: record.fileRecord,
          meta: { percent: 0 }
        });
      } else {
        this.accumulate = true;
      }
    };
    ZipFileWorker.prototype.closedSource = function(streamInfo) {
      this.accumulate = false;
      var streamedContent = this.streamFiles && !streamInfo["file"].dir;
      var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
      this.dirRecords.push(record.dirRecord);
      if (streamedContent) {
        this.push({
          data: generateDataDescriptors(streamInfo),
          meta: { percent: 100 }
        });
      } else {
        this.push({
          data: record.fileRecord,
          meta: { percent: 0 }
        });
        while (this.contentBuffer.length) {
          this.push(this.contentBuffer.shift());
        }
      }
      this.currentFile = null;
    };
    ZipFileWorker.prototype.flush = function() {
      var localDirLength = this.bytesWritten;
      for (var i = 0; i < this.dirRecords.length; i++) {
        this.push({
          data: this.dirRecords[i],
          meta: { percent: 100 }
        });
      }
      var centralDirLength = this.bytesWritten - localDirLength;
      var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
      this.push({
        data: dirEnd,
        meta: { percent: 100 }
      });
    };
    ZipFileWorker.prototype.prepareNextSource = function() {
      this.previous = this._sources.shift();
      this.openedSource(this.previous.streamInfo);
      if (this.isPaused) {
        this.previous.pause();
      } else {
        this.previous.resume();
      }
    };
    ZipFileWorker.prototype.registerPrevious = function(previous) {
      this._sources.push(previous);
      var self2 = this;
      previous.on("data", function(chunk) {
        self2.processChunk(chunk);
      });
      previous.on("end", function() {
        self2.closedSource(self2.previous.streamInfo);
        if (self2._sources.length) {
          self2.prepareNextSource();
        } else {
          self2.end();
        }
      });
      previous.on("error", function(e) {
        self2.error(e);
      });
      return this;
    };
    ZipFileWorker.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (!this.previous && this._sources.length) {
        this.prepareNextSource();
        return true;
      }
      if (!this.previous && !this._sources.length && !this.generatedError) {
        this.end();
        return true;
      }
    };
    ZipFileWorker.prototype.error = function(e) {
      var sources = this._sources;
      if (!GenericWorker.prototype.error.call(this, e)) {
        return false;
      }
      for (var i = 0; i < sources.length; i++) {
        try {
          sources[i].error(e);
        } catch (e2) {
        }
      }
      return true;
    };
    ZipFileWorker.prototype.lock = function() {
      GenericWorker.prototype.lock.call(this);
      var sources = this._sources;
      for (var i = 0; i < sources.length; i++) {
        sources[i].lock();
      }
    };
    module2.exports = ZipFileWorker;
  }
});

// node_modules/jszip/lib/generate/index.js
var require_generate = __commonJS({
  "node_modules/jszip/lib/generate/index.js"(exports) {
    "use strict";
    var compressions = require_compressions();
    var ZipFileWorker = require_ZipFileWorker();
    var getCompression = /* @__PURE__ */ __name(function(fileCompression, zipCompression) {
      var compressionName = fileCompression || zipCompression;
      var compression = compressions[compressionName];
      if (!compression) {
        throw new Error(compressionName + " is not a valid compression method !");
      }
      return compression;
    }, "getCompression");
    exports.generateWorker = function(zip, options, comment) {
      var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
      var entriesCount = 0;
      try {
        zip.forEach(function(relativePath, file) {
          entriesCount++;
          var compression = getCompression(file.options.compression, options.compression);
          var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
          var dir = file.dir, date = file.date;
          file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
            name: relativePath,
            dir,
            date,
            comment: file.comment || "",
            unixPermissions: file.unixPermissions,
            dosPermissions: file.dosPermissions
          }).pipe(zipFileWorker);
        });
        zipFileWorker.entriesCount = entriesCount;
      } catch (e) {
        zipFileWorker.error(e);
      }
      return zipFileWorker;
    };
  }
});

// node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js
var require_NodejsStreamInputAdapter = __commonJS({
  "node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    function NodejsStreamInputAdapter(filename, stream) {
      GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
      this._upstreamEnded = false;
      this._bindStream(stream);
    }
    __name(NodejsStreamInputAdapter, "NodejsStreamInputAdapter");
    utils.inherits(NodejsStreamInputAdapter, GenericWorker);
    NodejsStreamInputAdapter.prototype._bindStream = function(stream) {
      var self2 = this;
      this._stream = stream;
      stream.pause();
      stream.on("data", function(chunk) {
        self2.push({
          data: chunk,
          meta: {
            percent: 0
          }
        });
      }).on("error", function(e) {
        if (self2.isPaused) {
          this.generatedError = e;
        } else {
          self2.error(e);
        }
      }).on("end", function() {
        if (self2.isPaused) {
          self2._upstreamEnded = true;
        } else {
          self2.end();
        }
      });
    };
    NodejsStreamInputAdapter.prototype.pause = function() {
      if (!GenericWorker.prototype.pause.call(this)) {
        return false;
      }
      this._stream.pause();
      return true;
    };
    NodejsStreamInputAdapter.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (this._upstreamEnded) {
        this.end();
      } else {
        this._stream.resume();
      }
      return true;
    };
    module2.exports = NodejsStreamInputAdapter;
  }
});

// node_modules/jszip/lib/object.js
var require_object = __commonJS({
  "node_modules/jszip/lib/object.js"(exports, module2) {
    "use strict";
    var utf8 = require_utf8();
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var StreamHelper = require_StreamHelper();
    var defaults = require_defaults();
    var CompressedObject = require_compressedObject();
    var ZipObject = require_zipObject();
    var generate = require_generate();
    var nodejsUtils = require_nodejsUtils();
    var NodejsStreamInputAdapter = require_NodejsStreamInputAdapter();
    var fileAdd = /* @__PURE__ */ __name(function(name, data, originalOptions) {
      var dataType = utils.getTypeOf(data), parent;
      var o = utils.extend(originalOptions || {}, defaults);
      o.date = o.date || /* @__PURE__ */ new Date();
      if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
      }
      if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
      }
      if (o.unixPermissions && o.unixPermissions & 16384) {
        o.dir = true;
      }
      if (o.dosPermissions && o.dosPermissions & 16) {
        o.dir = true;
      }
      if (o.dir) {
        name = forceTrailingSlash(name);
      }
      if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
      }
      var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
      if (!originalOptions || typeof originalOptions.binary === "undefined") {
        o.binary = !isUnicodeString;
      }
      var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
      if (isCompressedEmpty || o.dir || !data || data.length === 0) {
        o.base64 = false;
        o.binary = true;
        data = "";
        o.compression = "STORE";
        dataType = "string";
      }
      var zipObjectContent = null;
      if (data instanceof CompressedObject || data instanceof GenericWorker) {
        zipObjectContent = data;
      } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        zipObjectContent = new NodejsStreamInputAdapter(name, data);
      } else {
        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
      }
      var object = new ZipObject(name, zipObjectContent, o);
      this.files[name] = object;
    }, "fileAdd");
    var parentFolder = /* @__PURE__ */ __name(function(path) {
      if (path.slice(-1) === "/") {
        path = path.substring(0, path.length - 1);
      }
      var lastSlash = path.lastIndexOf("/");
      return lastSlash > 0 ? path.substring(0, lastSlash) : "";
    }, "parentFolder");
    var forceTrailingSlash = /* @__PURE__ */ __name(function(path) {
      if (path.slice(-1) !== "/") {
        path += "/";
      }
      return path;
    }, "forceTrailingSlash");
    var folderAdd = /* @__PURE__ */ __name(function(name, createFolders) {
      createFolders = typeof createFolders !== "undefined" ? createFolders : defaults.createFolders;
      name = forceTrailingSlash(name);
      if (!this.files[name]) {
        fileAdd.call(this, name, null, {
          dir: true,
          createFolders
        });
      }
      return this.files[name];
    }, "folderAdd");
    function isRegExp(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    }
    __name(isRegExp, "isRegExp");
    var out = {
      /**
       * @see loadAsync
       */
      load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      },
      /**
       * Call a callback function for each entry at this folder level.
       * @param {Function} cb the callback function:
       * function (relativePath, file) {...}
       * It takes 2 arguments : the relative path and the file.
       */
      forEach: function(cb) {
        var filename, relativePath, file;
        for (filename in this.files) {
          file = this.files[filename];
          relativePath = filename.slice(this.root.length, filename.length);
          if (relativePath && filename.slice(0, this.root.length) === this.root) {
            cb(relativePath, file);
          }
        }
      },
      /**
       * Filter nested files/folders with the specified function.
       * @param {Function} search the predicate to use :
       * function (relativePath, file) {...}
       * It takes 2 arguments : the relative path and the file.
       * @return {Array} An array of matching elements.
       */
      filter: function(search) {
        var result = [];
        this.forEach(function(relativePath, entry) {
          if (search(relativePath, entry)) {
            result.push(entry);
          }
        });
        return result;
      },
      /**
       * Add a file to the zip file, or search a file.
       * @param   {string|RegExp} name The name of the file to add (if data is defined),
       * the name of the file to find (if no data) or a regex to match files.
       * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
       * @param   {Object} o     File options
       * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
       * a file (when searching by string) or an array of files (when searching by regex).
       */
      file: function(name, data, o) {
        if (arguments.length === 1) {
          if (isRegExp(name)) {
            var regexp = name;
            return this.filter(function(relativePath, file) {
              return !file.dir && regexp.test(relativePath);
            });
          } else {
            var obj = this.files[this.root + name];
            if (obj && !obj.dir) {
              return obj;
            } else {
              return null;
            }
          }
        } else {
          name = this.root + name;
          fileAdd.call(this, name, data, o);
        }
        return this;
      },
      /**
       * Add a directory to the zip file, or search.
       * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
       * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
       */
      folder: function(arg) {
        if (!arg) {
          return this;
        }
        if (isRegExp(arg)) {
          return this.filter(function(relativePath, file) {
            return file.dir && arg.test(relativePath);
          });
        }
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);
        var ret = this.clone();
        ret.root = newFolder.name;
        return ret;
      },
      /**
       * Delete a file, or a directory and all sub-files, from the zip
       * @param {string} name the name of the file to delete
       * @return {JSZip} this JSZip object
       */
      remove: function(name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
          if (name.slice(-1) !== "/") {
            name += "/";
          }
          file = this.files[name];
        }
        if (file && !file.dir) {
          delete this.files[name];
        } else {
          var kids = this.filter(function(relativePath, file2) {
            return file2.name.slice(0, name.length) === name;
          });
          for (var i = 0; i < kids.length; i++) {
            delete this.files[kids[i].name];
          }
        }
        return this;
      },
      /**
       * @deprecated This method has been removed in JSZip 3.0, please check the upgrade guide.
       */
      generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      },
      /**
       * Generate the complete zip file as an internal stream.
       * @param {Object} options the options to generate the zip file :
       * - compression, "STORE" by default.
       * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
       * @return {StreamHelper} the streamed zip file.
       */
      generateInternalStream: function(options) {
        var worker, opts = {};
        try {
          opts = utils.extend(options || {}, {
            streamFiles: false,
            compression: "STORE",
            compressionOptions: null,
            type: "",
            platform: "DOS",
            comment: null,
            mimeType: "application/zip",
            encodeFileName: utf8.utf8encode
          });
          opts.type = opts.type.toLowerCase();
          opts.compression = opts.compression.toUpperCase();
          if (opts.type === "binarystring") {
            opts.type = "string";
          }
          if (!opts.type) {
            throw new Error("No output type specified.");
          }
          utils.checkSupport(opts.type);
          if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
            opts.platform = "UNIX";
          }
          if (opts.platform === "win32") {
            opts.platform = "DOS";
          }
          var comment = opts.comment || this.comment || "";
          worker = generate.generateWorker(this, opts, comment);
        } catch (e) {
          worker = new GenericWorker("error");
          worker.error(e);
        }
        return new StreamHelper(worker, opts.type || "string", opts.mimeType);
      },
      /**
       * Generate the complete zip file asynchronously.
       * @see generateInternalStream
       */
      generateAsync: function(options, onUpdate) {
        return this.generateInternalStream(options).accumulate(onUpdate);
      },
      /**
       * Generate the complete zip file asynchronously.
       * @see generateInternalStream
       */
      generateNodeStream: function(options, onUpdate) {
        options = options || {};
        if (!options.type) {
          options.type = "nodebuffer";
        }
        return this.generateInternalStream(options).toNodejsStream(onUpdate);
      }
    };
    module2.exports = out;
  }
});

// node_modules/jszip/lib/reader/DataReader.js
var require_DataReader = __commonJS({
  "node_modules/jszip/lib/reader/DataReader.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    function DataReader(data) {
      this.data = data;
      this.length = data.length;
      this.index = 0;
      this.zero = 0;
    }
    __name(DataReader, "DataReader");
    DataReader.prototype = {
      /**
       * Check that the offset will not go too far.
       * @param {string} offset the additional offset to check.
       * @throws {Error} an Error if the offset is out of bounds.
       */
      checkOffset: function(offset) {
        this.checkIndex(this.index + offset);
      },
      /**
       * Check that the specified index will not be too far.
       * @param {string} newIndex the index to check.
       * @throws {Error} an Error if the index is out of bounds.
       */
      checkIndex: function(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
        }
      },
      /**
       * Change the index.
       * @param {number} newIndex The new index.
       * @throws {Error} if the new index is out of the data.
       */
      setIndex: function(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
      },
      /**
       * Skip the next n bytes.
       * @param {number} n the number of bytes to skip.
       * @throws {Error} if the new index is out of the data.
       */
      skip: function(n) {
        this.setIndex(this.index + n);
      },
      /**
       * Get the byte at the specified index.
       * @param {number} i the index to use.
       * @return {number} a byte.
       */
      byteAt: function() {
      },
      /**
       * Get the next number with a given byte size.
       * @param {number} size the number of bytes to read.
       * @return {number} the corresponding number.
       */
      readInt: function(size) {
        var result = 0, i;
        this.checkOffset(size);
        for (i = this.index + size - 1; i >= this.index; i--) {
          result = (result << 8) + this.byteAt(i);
        }
        this.index += size;
        return result;
      },
      /**
       * Get the next string with a given byte size.
       * @param {number} size the number of bytes to read.
       * @return {string} the corresponding string.
       */
      readString: function(size) {
        return utils.transformTo("string", this.readData(size));
      },
      /**
       * Get raw data without conversion, <size> bytes.
       * @param {number} size the number of bytes to read.
       * @return {Object} the raw data, implementation specific.
       */
      readData: function() {
      },
      /**
       * Find the last occurrence of a zip signature (4 bytes).
       * @param {string} sig the signature to find.
       * @return {number} the index of the last occurrence, -1 if not found.
       */
      lastIndexOfSignature: function() {
      },
      /**
       * Read the signature (4 bytes) at the current position and compare it with sig.
       * @param {string} sig the expected signature
       * @return {boolean} true if the signature matches, false otherwise.
       */
      readAndCheckSignature: function() {
      },
      /**
       * Get the next date.
       * @return {Date} the date.
       */
      readDate: function() {
        var dostime = this.readInt(4);
        return new Date(Date.UTC(
          (dostime >> 25 & 127) + 1980,
          // year
          (dostime >> 21 & 15) - 1,
          // month
          dostime >> 16 & 31,
          // day
          dostime >> 11 & 31,
          // hour
          dostime >> 5 & 63,
          // minute
          (dostime & 31) << 1
        ));
      }
    };
    module2.exports = DataReader;
  }
});

// node_modules/jszip/lib/reader/ArrayReader.js
var require_ArrayReader = __commonJS({
  "node_modules/jszip/lib/reader/ArrayReader.js"(exports, module2) {
    "use strict";
    var DataReader = require_DataReader();
    var utils = require_utils();
    function ArrayReader(data) {
      DataReader.call(this, data);
      for (var i = 0; i < this.data.length; i++) {
        data[i] = data[i] & 255;
      }
    }
    __name(ArrayReader, "ArrayReader");
    utils.inherits(ArrayReader, DataReader);
    ArrayReader.prototype.byteAt = function(i) {
      return this.data[this.zero + i];
    };
    ArrayReader.prototype.lastIndexOfSignature = function(sig) {
      var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
      for (var i = this.length - 4; i >= 0; --i) {
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
          return i - this.zero;
        }
      }
      return -1;
    };
    ArrayReader.prototype.readAndCheckSignature = function(sig) {
      var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
      return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
    };
    ArrayReader.prototype.readData = function(size) {
      this.checkOffset(size);
      if (size === 0) {
        return [];
      }
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = ArrayReader;
  }
});

// node_modules/jszip/lib/reader/StringReader.js
var require_StringReader = __commonJS({
  "node_modules/jszip/lib/reader/StringReader.js"(exports, module2) {
    "use strict";
    var DataReader = require_DataReader();
    var utils = require_utils();
    function StringReader(data) {
      DataReader.call(this, data);
    }
    __name(StringReader, "StringReader");
    utils.inherits(StringReader, DataReader);
    StringReader.prototype.byteAt = function(i) {
      return this.data.charCodeAt(this.zero + i);
    };
    StringReader.prototype.lastIndexOfSignature = function(sig) {
      return this.data.lastIndexOf(sig) - this.zero;
    };
    StringReader.prototype.readAndCheckSignature = function(sig) {
      var data = this.readData(4);
      return sig === data;
    };
    StringReader.prototype.readData = function(size) {
      this.checkOffset(size);
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = StringReader;
  }
});

// node_modules/jszip/lib/reader/Uint8ArrayReader.js
var require_Uint8ArrayReader = __commonJS({
  "node_modules/jszip/lib/reader/Uint8ArrayReader.js"(exports, module2) {
    "use strict";
    var ArrayReader = require_ArrayReader();
    var utils = require_utils();
    function Uint8ArrayReader(data) {
      ArrayReader.call(this, data);
    }
    __name(Uint8ArrayReader, "Uint8ArrayReader");
    utils.inherits(Uint8ArrayReader, ArrayReader);
    Uint8ArrayReader.prototype.readData = function(size) {
      this.checkOffset(size);
      if (size === 0) {
        return new Uint8Array(0);
      }
      var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = Uint8ArrayReader;
  }
});

// node_modules/jszip/lib/reader/NodeBufferReader.js
var require_NodeBufferReader = __commonJS({
  "node_modules/jszip/lib/reader/NodeBufferReader.js"(exports, module2) {
    "use strict";
    var Uint8ArrayReader = require_Uint8ArrayReader();
    var utils = require_utils();
    function NodeBufferReader(data) {
      Uint8ArrayReader.call(this, data);
    }
    __name(NodeBufferReader, "NodeBufferReader");
    utils.inherits(NodeBufferReader, Uint8ArrayReader);
    NodeBufferReader.prototype.readData = function(size) {
      this.checkOffset(size);
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = NodeBufferReader;
  }
});

// node_modules/jszip/lib/reader/readerFor.js
var require_readerFor = __commonJS({
  "node_modules/jszip/lib/reader/readerFor.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var support = require_support();
    var ArrayReader = require_ArrayReader();
    var StringReader = require_StringReader();
    var NodeBufferReader = require_NodeBufferReader();
    var Uint8ArrayReader = require_Uint8ArrayReader();
    module2.exports = function(data) {
      var type = utils.getTypeOf(data);
      utils.checkSupport(type);
      if (type === "string" && !support.uint8array) {
        return new StringReader(data);
      }
      if (type === "nodebuffer") {
        return new NodeBufferReader(data);
      }
      if (support.uint8array) {
        return new Uint8ArrayReader(utils.transformTo("uint8array", data));
      }
      return new ArrayReader(utils.transformTo("array", data));
    };
  }
});

// node_modules/jszip/lib/zipEntry.js
var require_zipEntry = __commonJS({
  "node_modules/jszip/lib/zipEntry.js"(exports, module2) {
    "use strict";
    var readerFor = require_readerFor();
    var utils = require_utils();
    var CompressedObject = require_compressedObject();
    var crc32fn = require_crc32();
    var utf8 = require_utf8();
    var compressions = require_compressions();
    var support = require_support();
    var MADE_BY_DOS = 0;
    var MADE_BY_UNIX = 3;
    var findCompression = /* @__PURE__ */ __name(function(compressionMethod) {
      for (var method in compressions) {
        if (!Object.prototype.hasOwnProperty.call(compressions, method)) {
          continue;
        }
        if (compressions[method].magic === compressionMethod) {
          return compressions[method];
        }
      }
      return null;
    }, "findCompression");
    function ZipEntry(options, loadOptions) {
      this.options = options;
      this.loadOptions = loadOptions;
    }
    __name(ZipEntry, "ZipEntry");
    ZipEntry.prototype = {
      /**
       * say if the file is encrypted.
       * @return {boolean} true if the file is encrypted, false otherwise.
       */
      isEncrypted: function() {
        return (this.bitFlag & 1) === 1;
      },
      /**
       * say if the file has utf-8 filename/comment.
       * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
       */
      useUTF8: function() {
        return (this.bitFlag & 2048) === 2048;
      },
      /**
       * Read the local part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readLocalPart: function(reader) {
        var compression, localExtraFieldsLength;
        reader.skip(22);
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2);
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);
        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        }
        compression = findCompression(this.compressionMethod);
        if (compression === null) {
          throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
      },
      /**
       * Read the central part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readCentralPart: function(reader) {
        this.versionMadeBy = reader.readInt(2);
        reader.skip(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        var fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);
        if (this.isEncrypted()) {
          throw new Error("Encrypted zip are not supported");
        }
        reader.skip(fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
      },
      /**
       * Parse the external file attributes and get the unix/dos permissions.
       */
      processAttributes: function() {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;
        this.dir = this.externalFileAttributes & 16 ? true : false;
        if (madeBy === MADE_BY_DOS) {
          this.dosPermissions = this.externalFileAttributes & 63;
        }
        if (madeBy === MADE_BY_UNIX) {
          this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
        }
        if (!this.dir && this.fileNameStr.slice(-1) === "/") {
          this.dir = true;
        }
      },
      /**
       * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
       * @param {DataReader} reader the reader to use.
       */
      parseZIP64ExtraField: function() {
        if (!this.extraFields[1]) {
          return;
        }
        var extraReader = readerFor(this.extraFields[1].value);
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
          this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {
          this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
          this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
          this.diskNumberStart = extraReader.readInt(4);
        }
      },
      /**
       * Read the central part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readExtraFields: function(reader) {
        var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
        if (!this.extraFields) {
          this.extraFields = {};
        }
        while (reader.index + 4 < end) {
          extraFieldId = reader.readInt(2);
          extraFieldLength = reader.readInt(2);
          extraFieldValue = reader.readData(extraFieldLength);
          this.extraFields[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
        reader.setIndex(end);
      },
      /**
       * Apply an UTF8 transformation if needed.
       */
      handleUTF8: function() {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
          this.fileNameStr = utf8.utf8decode(this.fileName);
          this.fileCommentStr = utf8.utf8decode(this.fileComment);
        } else {
          var upath = this.findExtraFieldUnicodePath();
          if (upath !== null) {
            this.fileNameStr = upath;
          } else {
            var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
          }
          var ucomment = this.findExtraFieldUnicodeComment();
          if (ucomment !== null) {
            this.fileCommentStr = ucomment;
          } else {
            var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
          }
        }
      },
      /**
       * Find the unicode path declared in the extra field, if any.
       * @return {String} the unicode path, null otherwise.
       */
      findExtraFieldUnicodePath: function() {
        var upathField = this.extraFields[28789];
        if (upathField) {
          var extraReader = readerFor(upathField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
            return null;
          }
          return utf8.utf8decode(extraReader.readData(upathField.length - 5));
        }
        return null;
      },
      /**
       * Find the unicode comment declared in the extra field, if any.
       * @return {String} the unicode comment, null otherwise.
       */
      findExtraFieldUnicodeComment: function() {
        var ucommentField = this.extraFields[25461];
        if (ucommentField) {
          var extraReader = readerFor(ucommentField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
            return null;
          }
          return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
        }
        return null;
      }
    };
    module2.exports = ZipEntry;
  }
});

// node_modules/jszip/lib/zipEntries.js
var require_zipEntries = __commonJS({
  "node_modules/jszip/lib/zipEntries.js"(exports, module2) {
    "use strict";
    var readerFor = require_readerFor();
    var utils = require_utils();
    var sig = require_signature();
    var ZipEntry = require_zipEntry();
    var support = require_support();
    function ZipEntries(loadOptions) {
      this.files = [];
      this.loadOptions = loadOptions;
    }
    __name(ZipEntries, "ZipEntries");
    ZipEntries.prototype = {
      /**
       * Check that the reader is on the specified signature.
       * @param {string} expectedSignature the expected signature.
       * @throws {Error} if it is an other signature.
       */
      checkSignature: function(expectedSignature) {
        if (!this.reader.readAndCheckSignature(expectedSignature)) {
          this.reader.index -= 4;
          var signature = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }
      },
      /**
       * Check if the given signature is at the given index.
       * @param {number} askedIndex the index to check.
       * @param {string} expectedSignature the signature to expect.
       * @return {boolean} true if the signature is here, false otherwise.
       */
      isSignature: function(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
      },
      /**
       * Read the end of the central directory.
       */
      readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);
        this.zipCommentLength = this.reader.readInt(2);
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        var decodeContent = utils.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
      },
      /**
       * Read the end of the Zip 64 central directory.
       * Not merged with the method readEndOfCentral :
       * The end of central can coexist with its Zip64 brother,
       * I don't want to read the wrong number of bytes !
       */
      readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.reader.skip(4);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);
        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
        while (index < extraDataSize) {
          extraFieldId = this.reader.readInt(2);
          extraFieldLength = this.reader.readInt(4);
          extraFieldValue = this.reader.readData(extraFieldLength);
          this.zip64ExtensibleData[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
      },
      /**
       * Read the end of the Zip 64 central directory locator.
       */
      readBlockZip64EndOfCentralLocator: function() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
          throw new Error("Multi-volumes zip are not supported");
        }
      },
      /**
       * Read the local files, based on the offset read in the central part.
       */
      readLocalFiles: function() {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
          file = this.files[i];
          this.reader.setIndex(file.localHeaderOffset);
          this.checkSignature(sig.LOCAL_FILE_HEADER);
          file.readLocalPart(this.reader);
          file.handleUTF8();
          file.processAttributes();
        }
      },
      /**
       * Read the central directory.
       */
      readCentralDir: function() {
        var file;
        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
          file = new ZipEntry({
            zip64: this.zip64
          }, this.loadOptions);
          file.readCentralPart(this.reader);
          this.files.push(file);
        }
        if (this.centralDirRecords !== this.files.length) {
          if (this.centralDirRecords !== 0 && this.files.length === 0) {
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
          } else {
          }
        }
      },
      /**
       * Read the end of central directory.
       */
      readEndOfCentral: function() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
          var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
          if (isGarbage) {
            throw new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
          } else {
            throw new Error("Corrupted zip: can't find end of central directory");
          }
        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
          this.zip64 = true;
          offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          if (offset < 0) {
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          }
          this.reader.setIndex(offset);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          this.readBlockZip64EndOfCentralLocator();
          if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
            this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            if (this.relativeOffsetEndOfZip64CentralDir < 0) {
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            }
          }
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
          this.readBlockZip64EndOfCentral();
        }
        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
          expectedEndOfCentralDirOffset += 20;
          expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
        }
        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
        if (extraBytes > 0) {
          if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
          } else {
            this.reader.zero = extraBytes;
          }
        } else if (extraBytes < 0) {
          throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
      },
      prepareReader: function(data) {
        this.reader = readerFor(data);
      },
      /**
       * Read a zip file and create ZipEntries.
       * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
       */
      load: function(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
      }
    };
    module2.exports = ZipEntries;
  }
});

// node_modules/jszip/lib/load.js
var require_load = __commonJS({
  "node_modules/jszip/lib/load.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var external = require_external();
    var utf8 = require_utf8();
    var ZipEntries = require_zipEntries();
    var Crc32Probe = require_Crc32Probe();
    var nodejsUtils = require_nodejsUtils();
    function checkEntryCRC32(zipEntry) {
      return new external.Promise(function(resolve, reject) {
        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
        worker.on("error", function(e) {
          reject(e);
        }).on("end", function() {
          if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
            reject(new Error("Corrupted zip : CRC32 mismatch"));
          } else {
            resolve();
          }
        }).resume();
      });
    }
    __name(checkEntryCRC32, "checkEntryCRC32");
    module2.exports = function(data, options) {
      var zip = this;
      options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
      });
      if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
      }
      return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data2);
        return zipEntries;
      }).then(/* @__PURE__ */ __name(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
          for (var i = 0; i < files.length; i++) {
            promises.push(checkEntryCRC32(files[i]));
          }
        }
        return external.Promise.all(promises);
      }, "checkCRC32")).then(/* @__PURE__ */ __name(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i < files.length; i++) {
          var input = files[i];
          var unsafeName = input.fileNameStr;
          var safeName = utils.resolve(input.fileNameStr);
          zip.file(safeName, input.decompressed, {
            binary: true,
            optimizedBinaryString: true,
            date: input.date,
            dir: input.dir,
            comment: input.fileCommentStr.length ? input.fileCommentStr : null,
            unixPermissions: input.unixPermissions,
            dosPermissions: input.dosPermissions,
            createFolders: options.createFolders
          });
          if (!input.dir) {
            zip.file(safeName).unsafeOriginalName = unsafeName;
          }
        }
        if (zipEntries.zipComment.length) {
          zip.comment = zipEntries.zipComment;
        }
        return zip;
      }, "addFiles"));
    };
  }
});

// node_modules/jszip/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/jszip/lib/index.js"(exports, module2) {
    "use strict";
    function JSZip2() {
      if (!(this instanceof JSZip2)) {
        return new JSZip2();
      }
      if (arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
      }
      this.files = /* @__PURE__ */ Object.create(null);
      this.comment = null;
      this.root = "";
      this.clone = function() {
        var newObj = new JSZip2();
        for (var i in this) {
          if (typeof this[i] !== "function") {
            newObj[i] = this[i];
          }
        }
        return newObj;
      };
    }
    __name(JSZip2, "JSZip");
    JSZip2.prototype = require_object();
    JSZip2.prototype.loadAsync = require_load();
    JSZip2.support = require_support();
    JSZip2.defaults = require_defaults();
    JSZip2.version = "3.10.1";
    JSZip2.loadAsync = function(content, options) {
      return new JSZip2().loadAsync(content, options);
    };
    JSZip2.external = require_external();
    module2.exports = JSZip2;
  }
});

// node_modules/google-polyline/lib/encode.js
var require_encode2 = __commonJS({
  "node_modules/google-polyline/lib/encode.js"(exports, module2) {
    var CHARMAP = {};
    for (i = 32; i < 127; i++) {
      CHARMAP[i] = String.fromCharCode(i);
    }
    var i;
    function encode2(points) {
      var px = 0, py = 0;
      return reduce(points, function(str, lat, lon) {
        var x = Math.round(lat * 1e5);
        var y = Math.round(lon * 1e5);
        str += chars(sign(x - px)) + chars(sign(y - py));
        px = x;
        py = y;
        return str;
      });
    }
    __name(encode2, "encode");
    function reduce(points, callback) {
      var point = null;
      var lat = 0;
      var lon = 0;
      var str = "";
      for (var i2 = 0; i2 < points.length; i2++) {
        point = points[i2];
        lat = point.lat || point.x || point[0];
        lon = point.lng || point.y || point[1];
        str = callback(str, lat, lon);
      }
      return str;
    }
    __name(reduce, "reduce");
    function sign(value) {
      return value < 0 ? ~(value << 1) : value << 1;
    }
    __name(sign, "sign");
    function charCode(value) {
      return (value & 31 | 32) + 63;
    }
    __name(charCode, "charCode");
    function chars(value) {
      var str = "";
      while (value >= 32) {
        str += CHARMAP[charCode(value)];
        value = value >> 5;
      }
      str += CHARMAP[value + 63];
      return str;
    }
    __name(chars, "chars");
    module2.exports = encode2;
  }
});

// node_modules/google-polyline/lib/decode.js
var require_decode2 = __commonJS({
  "node_modules/google-polyline/lib/decode.js"(exports, module2) {
    var PRECISION = 1e5;
    function decode2(value) {
      var points = [];
      var lat = 0;
      var lon = 0;
      var values = decode2.integers(value, function(x, y) {
        lat += x;
        lon += y;
        points.push([lat / PRECISION, lon / PRECISION]);
      });
      return points;
    }
    __name(decode2, "decode");
    decode2.sign = function(value) {
      return value & 1 ? ~(value >>> 1) : value >>> 1;
    };
    decode2.integers = function(value, callback) {
      var values = 0;
      var x = 0;
      var y = 0;
      var byte = 0;
      var current = 0;
      var bits = 0;
      for (var i = 0; i < value.length; i++) {
        byte = value.charCodeAt(i) - 63;
        current = current | (byte & 31) << bits;
        bits = bits + 5;
        if (byte < 32) {
          if (++values & 1) {
            x = decode2.sign(current);
          } else {
            y = decode2.sign(current);
            callback(x, y);
          }
          current = 0;
          bits = 0;
        }
      }
      return values;
    };
    module2.exports = decode2;
  }
});

// node_modules/google-polyline/lib/polyline.js
var require_polyline = __commonJS({
  "node_modules/google-polyline/lib/polyline.js"(exports, module2) {
    module2.exports = {
      encode: require_encode2(),
      decode: require_decode2()
    };
  }
});

// node_modules/igc-xc-score/dist/index.cjs
var require_dist = __commonJS({
  "node_modules/igc-xc-score/dist/index.cjs"(exports) {
    "use strict";
    var [_version, _year] = ["1.7.0", "2022"];
    Object.defineProperty(exports, "__esModule", { value: true });
    var genericCollection;
    var hasRequiredGenericCollection;
    var commonjsGlobal = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
    function requireGenericCollection() {
      if (hasRequiredGenericCollection)
        return genericCollection;
      function GenericCollection2() {
        throw new Error("Can't construct. GenericCollection is a mixin.");
      }
      __name(GenericCollection2, "GenericCollection");
      hasRequiredGenericCollection = 1, genericCollection = GenericCollection2;
      var DOMTokenList = commonjsGlobal.DOMTokenList || function() {
      };
      return GenericCollection2.EmptyArray = Object.freeze([]), GenericCollection2.prototype.addEach = function(values, mapFn, thisp) {
        if (values && (values instanceof Array || values instanceof DOMTokenList || values instanceof String))
          if (mapFn)
            for (var i = 0; i < values.length; i++)
              this.add(mapFn.call(thisp, values[i]), i);
          else
            for (i = 0; i < values.length; i++)
              this.add(values[i], i);
        else if (values && Object(values) === values)
          if ("function" == typeof values.forEach)
            mapFn ? values.map(mapFn, thisp).forEach(this.add, this) : values.forEach(this.add, this);
          else if ("function" == typeof values.next) {
            var value;
            i = 0;
            if (mapFn)
              for (; value = values.next().value; )
                this.add(mapFn.call(thisp, value), i++);
            else
              for (; value = values.next().value; )
                this.add(value, i++);
          } else if ("number" == typeof values.length)
            if (mapFn)
              for (i = 0; i < values.length; i++)
                this.add(mapFn.call(thisp, values[i]), i);
            else
              for (i = 0; i < values.length; i++)
                this.add(values[i], i);
          else
            mapFn ? Object.keys(values).forEach(function(key) {
              this.add(mapFn.call(thisp, values[key]), key);
            }, this) : Object.keys(values).forEach(function(key) {
              this.add(values[key], key);
            }, this);
        return this;
      }, GenericCollection2.prototype.deleteEach = function(values, equals) {
        return values.forEach(function(value) {
          this.delete(value, equals);
        }, this), this;
      }, GenericCollection2.prototype.forEach = function(callback) {
        var thisp = arguments[1];
        return this.reduce(function(undefined$1, value, key, object, depth) {
          callback.call(thisp, value, key, object, depth);
        }, void 0);
      }, GenericCollection2.prototype.map = function(callback) {
        var thisp = arguments[1], result = [];
        return this.reduce(function(undefined$1, value, key, object, depth) {
          result.push(callback.call(thisp, value, key, object, depth));
        }, void 0), result;
      }, GenericCollection2.prototype.enumerate = function(start) {
        null == start && (start = 0);
        var result = [];
        return this.reduce(function(undefined$1, value) {
          result.push([start++, value]);
        }, void 0), result;
      }, GenericCollection2.prototype.group = function(callback, thisp, equals) {
        equals = equals || Object.equals;
        var groups = [], keys = [];
        return this.forEach(function(value, key, object) {
          key = callback.call(thisp, value, key, object);
          var group, index = keys.indexOf(key, equals);
          -1 === index ? (group = [], groups.push([key, group]), keys.push(key)) : group = groups[index][1], group.push(value);
        }), groups;
      }, GenericCollection2.prototype.toArray = function() {
        return this.map(Function.identity);
      }, GenericCollection2.prototype.toObject = function() {
        var object = {};
        return this.reduce(function(undefined$1, value, key) {
          object[key] = value;
        }, void 0), object;
      }, GenericCollection2.from = function() {
        return this.apply(this, arguments);
      }, GenericCollection2.prototype.filter = function(callback) {
        var thisp = arguments[1], result = this.constructClone();
        return this.reduce(function(undefined$1, value, key, object, depth) {
          callback.call(thisp, value, key, object, depth) && result.add(value, key);
        }, void 0), result;
      }, GenericCollection2.prototype.every = function(callback) {
        var thisp = arguments[1];
        return this.reduce(function(result, value, key, object, depth) {
          return result && callback.call(thisp, value, key, object, depth);
        }, true);
      }, GenericCollection2.prototype.some = function(callback) {
        var thisp = arguments[1];
        return this.reduce(function(result, value, key, object, depth) {
          return result || callback.call(thisp, value, key, object, depth);
        }, false);
      }, GenericCollection2.prototype.all = function() {
        return this.every(Boolean);
      }, GenericCollection2.prototype.any = function() {
        return this.some(Boolean);
      }, GenericCollection2.prototype.min = function(compare) {
        compare = compare || this.contentCompare || Object.compare;
        var first = true;
        return this.reduce(function(result, value) {
          return first ? (first = false, value) : compare(value, result) < 0 ? value : result;
        }, void 0);
      }, GenericCollection2.prototype.max = function(compare) {
        compare = compare || this.contentCompare || Object.compare;
        var first = true;
        return this.reduce(function(result, value) {
          return first ? (first = false, value) : compare(value, result) > 0 ? value : result;
        }, void 0);
      }, GenericCollection2.prototype.sum = function(zero) {
        return zero = void 0 === zero ? 0 : zero, this.reduce(function(a, b) {
          return a + b;
        }, zero);
      }, GenericCollection2.prototype.average = function(zero) {
        var sum = void 0 === zero ? 0 : zero, count = void 0 === zero ? 0 : zero;
        return this.reduce(function(undefined$1, value) {
          sum += value, count += 1;
        }, void 0), sum / count;
      }, GenericCollection2.prototype.concat = function() {
        for (var result = this.constructClone(this), i = 0; i < arguments.length; i++)
          result.addEach(arguments[i]);
        return result;
      }, GenericCollection2.prototype.flatten = function() {
        var self2 = this;
        return this.reduce(function(result, array) {
          return array.forEach(function(value) {
            this.push(value);
          }, result, self2), result;
        }, []);
      }, GenericCollection2.prototype.zip = function() {
        var table = Array.prototype.slice.call(arguments);
        return table.unshift(this), Array.unzip(table);
      }, GenericCollection2.prototype.join = function(delimiter) {
        return this.reduce(function(result, string) {
          return void 0 === result ? string : result + delimiter + string;
        }, void 0);
      }, GenericCollection2.prototype.sorted = function(compare, by, order) {
        return (compare = compare || this.contentCompare || Object.compare).by ? (by = compare.by, compare = compare.compare || this.contentCompare || Object.compare) : by = by || Function.identity, void 0 === order && (order = 1), this.map(function(item) {
          return { by: by(item), value: item };
        }).sort(function(a, b) {
          return compare(a.by, b.by) * order;
        }).map(function(pair) {
          return pair.value;
        });
      }, GenericCollection2.prototype.reversed = function() {
        return this.constructClone(this).reverse();
      }, GenericCollection2.prototype.clone = function(depth, memo) {
        if (void 0 === depth)
          depth = 1 / 0;
        else if (0 === depth)
          return this;
        var clone = this.constructClone();
        return this.forEach(function(value, key) {
          clone.add(Object.clone(value, depth - 1, memo), key);
        }, this), clone;
      }, GenericCollection2.prototype.only = function() {
        if (1 === this.length)
          return this.one();
      }, GenericCollection2.prototype.iterator = function() {
        return this.iterate.apply(this, arguments);
      }, GenericCollection2._sizePropertyDescriptor = { get: function() {
        return this.length;
      }, enumerable: false, configurable: true }, Object.defineProperty(GenericCollection2.prototype, "size", GenericCollection2._sizePropertyDescriptor), requireShimArray(), genericCollection;
    }
    __name(requireGenericCollection, "requireGenericCollection");
    Function.noop = function() {
    }, Function.identity = function(value) {
      return value;
    }, Function.by = function(by, compare) {
      compare = compare || Object.compare, by = by || Function.identity;
      var compareBy = /* @__PURE__ */ __name(function(a, b) {
        return compare(by(a), by(b));
      }, "compareBy");
      return compareBy.compare = compare, compareBy.by = by, compareBy;
    }, Function.get = function(key) {
      return function(object) {
        return Object.get(object, key);
      };
    };
    var hasRequiredWeakMap;
    var weakMap$1 = { exports: {} };
    var weakMap = "undefined" != typeof WeakMap ? WeakMap : (hasRequiredWeakMap || (hasRequiredWeakMap = 1, function() {
      if ("undefined" == typeof ses || !ses.ok || ses.ok()) {
        "undefined" != typeof ses && (ses.weakMapPermitHostObjects = weakMapPermitHostObjects);
        var doubleWeakMapCheckSilentFailure = false;
        if ("function" == typeof WeakMap) {
          var HostWeakMap = WeakMap;
          if ("undefined" != typeof navigator && /Firefox/.test(navigator.userAgent))
            ;
          else {
            var testMap = new HostWeakMap(), testObject = Object.freeze({});
            if (testMap.set(testObject, 1), 1 === testMap.get(testObject))
              return void (weakMap$1.exports = WeakMap);
            doubleWeakMapCheckSilentFailure = true;
          }
        }
        var gopn = Object.getOwnPropertyNames, defProp = Object.defineProperty, isExtensible = Object.isExtensible, HIDDEN_NAME = "weakmap:ident:" + Math.random() + "___";
        if ("undefined" != typeof crypto && "function" == typeof crypto.getRandomValues && "function" == typeof ArrayBuffer && "function" == typeof Uint8Array) {
          var ab = new ArrayBuffer(25), u8s = new Uint8Array(ab);
          crypto.getRandomValues(u8s), HIDDEN_NAME = "weakmap:rand:" + Array.prototype.map.call(u8s, function(u8) {
            return (u8 % 36).toString(36);
          }).join("") + "___";
        }
        if (defProp(Object, "getOwnPropertyNames", { value: function(obj) {
          return gopn(obj).filter(isNotHiddenName);
        } }), "getPropertyNames" in Object) {
          var originalGetPropertyNames = Object.getPropertyNames;
          defProp(Object, "getPropertyNames", { value: function(obj) {
            return originalGetPropertyNames(obj).filter(isNotHiddenName);
          } });
        }
        !function() {
          var oldFreeze = Object.freeze;
          defProp(Object, "freeze", { value: function(obj) {
            return getHiddenRecord(obj), oldFreeze(obj);
          } });
          var oldSeal = Object.seal;
          defProp(Object, "seal", { value: function(obj) {
            return getHiddenRecord(obj), oldSeal(obj);
          } });
          var oldPreventExtensions = Object.preventExtensions;
          defProp(Object, "preventExtensions", { value: function(obj) {
            return getHiddenRecord(obj), oldPreventExtensions(obj);
          } });
        }();
        var calledAsFunctionWarningDone = false, nextId = 0, OurWeakMap = /* @__PURE__ */ __name(function() {
          this instanceof OurWeakMap || calledAsFunctionWarning();
          var keys = [], values = [], id2 = nextId++;
          return Object.create(OurWeakMap.prototype, { get___: { value: constFunc(function(key, opt_default) {
            var index, hiddenRecord = getHiddenRecord(key);
            return hiddenRecord ? id2 in hiddenRecord ? hiddenRecord[id2] : opt_default : (index = keys.indexOf(key)) >= 0 ? values[index] : opt_default;
          }) }, has___: { value: constFunc(function(key) {
            var hiddenRecord = getHiddenRecord(key);
            return hiddenRecord ? id2 in hiddenRecord : keys.indexOf(key) >= 0;
          }) }, set___: { value: constFunc(function(key, value) {
            var index, hiddenRecord = getHiddenRecord(key);
            return hiddenRecord ? hiddenRecord[id2] = value : (index = keys.indexOf(key)) >= 0 ? values[index] = value : (index = keys.length, values[index] = value, keys[index] = key), this;
          }) }, delete___: { value: constFunc(function(key) {
            var index, lastIndex, hiddenRecord = getHiddenRecord(key);
            return hiddenRecord ? id2 in hiddenRecord && delete hiddenRecord[id2] : !((index = keys.indexOf(key)) < 0 || (lastIndex = keys.length - 1, keys[index] = void 0, values[index] = values[lastIndex], keys[index] = keys[lastIndex], keys.length = lastIndex, values.length = lastIndex, 0));
          }) } });
        }, "OurWeakMap");
        OurWeakMap.prototype = Object.create(Object.prototype, { get: { value: function(key, opt_default) {
          return this.get___(key, opt_default);
        }, writable: true, configurable: true }, has: { value: function(key) {
          return this.has___(key);
        }, writable: true, configurable: true }, set: { value: function(key, value) {
          return this.set___(key, value);
        }, writable: true, configurable: true }, delete: { value: function(key) {
          return this.delete___(key);
        }, writable: true, configurable: true } }), "function" == typeof HostWeakMap ? function() {
          function DoubleWeakMap() {
            this instanceof OurWeakMap || calledAsFunctionWarning();
            var dset, hmap = new HostWeakMap(), omap = void 0, enableSwitching = false;
            return dset = doubleWeakMapCheckSilentFailure ? function(key, value) {
              return hmap.set(key, value), hmap.has(key) || (omap || (omap = new OurWeakMap()), omap.set(key, value)), this;
            } : function(key, value) {
              if (enableSwitching)
                try {
                  hmap.set(key, value);
                } catch (e) {
                  omap || (omap = new OurWeakMap()), omap.set___(key, value);
                }
              else
                hmap.set(key, value);
              return this;
            }, Object.create(OurWeakMap.prototype, { get___: { value: constFunc(function(key, opt_default) {
              return omap ? hmap.has(key) ? hmap.get(key) : omap.get___(key, opt_default) : hmap.get(key, opt_default);
            }) }, has___: { value: constFunc(function(key) {
              return hmap.has(key) || !!omap && omap.has___(key);
            }) }, set___: { value: constFunc(dset) }, delete___: { value: constFunc(function(key) {
              var result = !!hmap.delete(key);
              return omap && omap.delete___(key) || result;
            }) }, permitHostObjects___: { value: constFunc(function(token) {
              if (token !== weakMapPermitHostObjects)
                throw new Error("bogus call to permitHostObjects___");
              enableSwitching = true;
            }) } });
          }
          __name(DoubleWeakMap, "DoubleWeakMap");
          doubleWeakMapCheckSilentFailure && "undefined" != typeof Proxy && (Proxy = void 0), DoubleWeakMap.prototype = OurWeakMap.prototype, weakMap$1.exports = DoubleWeakMap, Object.defineProperty(WeakMap.prototype, "constructor", { value: WeakMap, enumerable: false, configurable: true, writable: true });
        }() : ("undefined" != typeof Proxy && (Proxy = void 0), weakMap$1.exports = OurWeakMap);
      }
      function weakMapPermitHostObjects(map2) {
        map2.permitHostObjects___ && map2.permitHostObjects___(weakMapPermitHostObjects);
      }
      __name(weakMapPermitHostObjects, "weakMapPermitHostObjects");
      function isNotHiddenName(name) {
        return !("weakmap:" == name.substr(0, "weakmap:".length) && "___" === name.substr(name.length - 3));
      }
      __name(isNotHiddenName, "isNotHiddenName");
      function getHiddenRecord(key) {
        if (key !== Object(key))
          throw new TypeError("Not an object: " + key);
        var hiddenRecord = key[HIDDEN_NAME];
        if (hiddenRecord && hiddenRecord.key === key)
          return hiddenRecord;
        if (isExtensible(key)) {
          hiddenRecord = { key };
          try {
            return defProp(key, HIDDEN_NAME, { value: hiddenRecord, writable: false, enumerable: false, configurable: false }), hiddenRecord;
          } catch (error) {
            return;
          }
        }
      }
      __name(getHiddenRecord, "getHiddenRecord");
      function constFunc(func) {
        return func.prototype = null, Object.freeze(func);
      }
      __name(constFunc, "constFunc");
      function calledAsFunctionWarning() {
        calledAsFunctionWarningDone || "undefined" == typeof console || (calledAsFunctionWarningDone = true, console.warn("WeakMap should be invoked as new WeakMap(), not WeakMap(). This will be an error in the future."));
      }
      __name(calledAsFunctionWarning, "calledAsFunctionWarning");
    }()), weakMap$1.exports);
    var WeakMap$4 = weakMap;
    var shimObject = Object;
    Object.empty = Object.freeze(/* @__PURE__ */ Object.create(null)), Object.isObject = function(object) {
      return Object(object) === object;
    }, Object.getValueOf = function(value) {
      return value && "function" == typeof value.valueOf && (value = value.valueOf()), value;
    };
    var hashMap = new WeakMap$4();
    Object.hash = function(object) {
      return object && "function" == typeof object.hash ? "" + object.hash() : Object(object) === object ? (hashMap.has(object) || hashMap.set(object, Math.random().toString(36).slice(2)), hashMap.get(object)) : "" + object;
    };
    var owns = Object.prototype.hasOwnProperty;
    Object.owns = function(object, key) {
      return owns.call(object, key);
    }, Object.has = function(object, key) {
      if ("object" != typeof object)
        throw new Error("Object.has can't accept non-object: " + typeof object);
      if (object && "function" == typeof object.has)
        return object.has(key);
      if ("string" == typeof key)
        return key in object && object[key] !== Object.prototype[key];
      throw new Error("Key must be a string for Object.has on plain objects");
    }, Object.get = function(object, key, value) {
      if ("object" != typeof object)
        throw new Error("Object.get can't accept non-object: " + typeof object);
      return object && "function" == typeof object.get ? object.get(key, value) : Object.has(object, key) ? object[key] : value;
    }, Object.set = function(object, key, value) {
      object && "function" == typeof object.set ? object.set(key, value) : object[key] = value;
    }, Object.addEach = function(target, source, overrides) {
      var overridesExistingProperty = 3 !== arguments.length || overrides;
      if (source)
        if ("function" != typeof source.forEach || source.hasOwnProperty("forEach"))
          if ("number" == typeof source.length)
            for (var index = 0; index < source.length; index++)
              target[index] = source[index];
          else
            for (var key, keys = Object.keys(source), i = 0; key = keys[i]; i++)
              !overridesExistingProperty && Object.owns(target, key) || (target[key] = source[key]);
        else
          true === source.isMap ? source.forEach(function(value, key2) {
            target[key2] = value;
          }) : source.forEach(function(pair) {
            target[pair[0]] = pair[1];
          });
      else
        ;
      return target;
    }, Object.defineEach = function(target, source, overrides, configurable, enumerable, writable) {
      var overridesExistingProperty = 3 !== arguments.length || overrides;
      if (source)
        if ("function" != typeof source.forEach || source.hasOwnProperty("forEach"))
          if ("number" == typeof source.length)
            for (var index = 0; index < source.length; index++)
              Object.defineProperty(target, index, { value: source[index], writable, configurable, enumerable });
          else
            for (var key, keys = Object.keys(source), i = 0; key = keys[i]; i++)
              !overridesExistingProperty && Object.owns(target, key) || Object.defineProperty(target, key, { value: source[key], writable, configurable, enumerable });
        else
          true === source.isMap ? source.forEach(function(value, key2) {
            Object.defineProperty(target, key2, { value, writable, configurable, enumerable });
          }) : source.forEach(function(pair) {
            Object.defineProperty(target, pair[0], { value: pair[1], writable, configurable, enumerable });
          });
      else
        ;
      return target;
    }, Object.forEach = function(object, callback, thisp) {
      for (var iKey, keys = Object.keys(object), i = 0; iKey = keys[i]; i++)
        callback.call(thisp, object[iKey], iKey, object);
    }, Object.map = function(object, callback, thisp) {
      for (var iKey, keys = Object.keys(object), i = 0, result = []; iKey = keys[i]; i++)
        result.push(callback.call(thisp, object[iKey], iKey, object));
      return result;
    }, Object.values = function(object) {
      return Object.map(object, Function.identity);
    }, Object.concat = function() {
      for (var object = {}, i = 0; i < arguments.length; i++)
        Object.addEach(object, arguments[i]);
      return object;
    }, Object.from = Object.concat, Object.is = function(x, y) {
      return x === y ? 0 !== x || 1 / x == 1 / y : x != x && y != y;
    }, Object.equals = function(a, b, equals, memo) {
      if (equals = equals || Object.equals, (a = Object.getValueOf(a)) === (b = Object.getValueOf(b)))
        return true;
      if (Object.isObject(a)) {
        if ((memo = memo || new WeakMap$4()).has(a))
          return true;
        memo.set(a, true);
      }
      if (Object.isObject(a) && "function" == typeof a.equals)
        return a.equals(b, equals, memo);
      if (Object.isObject(b) && "function" == typeof b.equals)
        return b.equals(a, equals, memo);
      if (Object.isObject(a) && Object.isObject(b) && Object.getPrototypeOf(a) === Object.prototype && Object.getPrototypeOf(b) === Object.prototype) {
        for (var name in a)
          if (!equals(a[name], b[name], equals, memo))
            return false;
        for (var name in b)
          if (!(name in a) || !equals(b[name], a[name], equals, memo))
            return false;
        return true;
      }
      return a != a && b != b || (!a || !b) && a === b;
    }, Object.compare = function(a, b) {
      if ((a = Object.getValueOf(a)) === (b = Object.getValueOf(b)))
        return 0;
      var aType = typeof a, bType = typeof b;
      return "number" === aType && "number" === bType ? a - b : "string" === aType && "string" === bType ? a < b ? -1 / 0 : 1 / 0 : a && "function" == typeof a.compare ? a.compare(b) : b && "function" == typeof b.compare ? -b.compare(a) : 0;
    }, Object.clone = function(value, depth, memo) {
      if (value = Object.getValueOf(value), memo = memo || new WeakMap$4(), void 0 === depth)
        depth = 1 / 0;
      else if (0 === depth)
        return value;
      if (Object.isObject(value)) {
        if (!memo.has(value))
          if (value && "function" == typeof value.clone)
            memo.set(value, value.clone(depth, memo));
          else {
            var prototype = Object.getPrototypeOf(value);
            if (null !== prototype && prototype !== Object.prototype)
              throw new Error("Can't clone " + value);
            var clone = Object.create(prototype);
            for (var key in memo.set(value, clone), value)
              clone[key] = Object.clone(value[key], depth - 1, memo);
          }
        return memo.get(value);
      }
      return value;
    }, Object.clear = function(object) {
      if (object && "function" == typeof object.clear)
        object.clear();
      else
        for (var keys = Object.keys(object), i = keys.length; i; )
          delete object[keys[--i]];
      return object;
    };
    var shimArray;
    var hasRequiredShimArray;
    var Object$3 = shimObject;
    var genericOrder = GenericOrder$1;
    function GenericOrder$1() {
      throw new Error("Can't construct. GenericOrder is a mixin.");
    }
    __name(GenericOrder$1, "GenericOrder$1");
    function requireShimArray() {
      if (hasRequiredShimArray)
        return shimArray;
      hasRequiredShimArray = 1;
      var GenericCollection2 = requireGenericCollection(), GenericOrder2 = genericOrder, WeakMap2 = weakMap;
      shimArray = Array;
      var array_splice = Array.prototype.splice, array_slice = Array.prototype.slice;
      Array.empty || (Array.empty = [], Object.freeze && Object.freeze(Array.empty)), Array.nativeFrom || (Array.nativeFrom = Array.from);
      var isSymbolDefined = "undefined" != typeof Symbol;
      function define2(key, value) {
        Object.defineProperty(Array.prototype, key, { value, writable: true, configurable: true, enumerable: false });
      }
      __name(define2, "define");
      Array.from = function(values, mapFn, thisArg) {
        if (isSymbolDefined && values && ("function" == typeof values[Symbol.iterator] || "function" == typeof mapFn))
          return Array.nativeFrom(values, mapFn, thisArg);
        var array = [];
        return array.addEach(values), array;
      }, Array.unzip = function(table) {
        for (var transpose = [], length = 1 / 0, i = 0; i < table.length; i++) {
          var row = table[i];
          table[i] = row.toArray(), row.length < length && (length = row.length);
        }
        for (i = 0; i < table.length; i++) {
          row = table[i];
          for (var j = 0; j < row.length; j++)
            j < length && j in row && (transpose[j] = transpose[j] || [], transpose[j][i] = row[j]);
        }
        return transpose;
      }, define2("addEach", GenericCollection2.prototype.addEach), define2("deleteEach", GenericCollection2.prototype.deleteEach), define2("toArray", GenericCollection2.prototype.toArray), define2("toObject", GenericCollection2.prototype.toObject), define2("all", GenericCollection2.prototype.all), define2("any", GenericCollection2.prototype.any), define2("min", GenericCollection2.prototype.min), define2("max", GenericCollection2.prototype.max), define2("sum", GenericCollection2.prototype.sum), define2("average", GenericCollection2.prototype.average), define2("only", GenericCollection2.prototype.only), define2("flatten", GenericCollection2.prototype.flatten), define2("zip", GenericCollection2.prototype.zip), define2("enumerate", GenericCollection2.prototype.enumerate), define2("group", GenericCollection2.prototype.group), define2("sorted", GenericCollection2.prototype.sorted), define2("reversed", GenericCollection2.prototype.reversed), define2("constructClone", function(values) {
        var clone = new this.constructor();
        return clone.addEach(values), clone;
      }), define2("has", function(value, equals) {
        return -1 !== this.findValue(value, equals);
      }), define2("get", function(index, defaultValue) {
        if (+index !== index)
          throw new Error("Indicies must be numbers");
        return !index in this ? defaultValue : this[index];
      }), define2("set", function(index, value) {
        return this[index] = value, true;
      }), define2("add", function(value) {
        return this.push(value), true;
      }), define2("delete", function(value, equals) {
        var index = this.findValue(value, equals);
        return -1 !== index && (this.spliceOne(index), true);
      }), define2("deleteAll", function(value, equals) {
        equals = equals || this.contentEquals || Object.equals;
        for (var count = 0, index = 0; index < this.length; )
          equals(value, this[index]) ? (this.swap(index, 1), count++) : index++;
        return count;
      }), Array.prototype.find || define2("find", function(predicate) {
        if (null == this)
          throw new TypeError('"this" is null or not defined');
        var o = Object(this), len = o.length >>> 0;
        if ("function" != typeof predicate)
          throw new TypeError("predicate must be a function");
        for (var thisArg = arguments[1], k = 0; k < len; ) {
          var kValue = o[k];
          if (predicate.call(thisArg, kValue, k, o))
            return kValue;
          k++;
        }
      });
      var deprecatedWarnNonce = {};
      function deprecatedWarn(msg, notOnce) {
        "undefined" != typeof console && "function" == typeof console.warn && true !== notOnce && false === deprecatedWarnNonce.hasOwnProperty(msg) && (console.warn(msg), deprecatedWarnNonce[msg]++);
      }
      __name(deprecatedWarn, "deprecatedWarn");
      var ArrayFindPrototype = Object.getOwnPropertyDescriptor(Array.prototype, "find").value;
      function ArrayIterator(array, start, end) {
        this.array = array, this.start = null == start ? 0 : start, this.end = end;
      }
      __name(ArrayIterator, "ArrayIterator");
      return define2("find", function(value, equals, index) {
        return "function" == typeof arguments[0] && this instanceof Array ? ArrayFindPrototype.apply(this, arguments) : (deprecatedWarn("Array#find usage is deprecated please use Array#findValue"), this.findValue.apply(this, arguments));
      }), define2("findValue", function(value, equals, index) {
        if (index)
          throw new Error("Array#findValue does not support third argument: index");
        equals = equals || this.contentEquals || Object.equals;
        for (index = 0; index < this.length; index++)
          if (index in this && equals(value, this[index]))
            return index;
        return -1;
      }), define2("findLast", function(value, equals) {
        return deprecatedWarn("Array#findLast function is deprecated please use Array#findLastValue instead."), this.findLastValue.apply(this, arguments);
      }), define2("findLastValue", function(value, equals) {
        equals = equals || this.contentEquals || Object.equals;
        var index = this.length;
        do {
          if (--index in this && equals(this[index], value))
            return index;
        } while (index > 0);
        return -1;
      }), define2("swap", function(start, length, plus) {
        var args, plusLength, i, j, returnValue;
        if (start > this.length && (this.length = start), void 0 !== plus) {
          if (args = [start, length], Array.isArray(plus) || (plus = array_slice.call(plus)), i = 0, (plusLength = plus.length) < 1e3) {
            for (; i < plusLength; i++)
              args[i + 2] = plus[i];
            return array_splice.apply(this, args);
          }
          for (returnValue = array_splice.apply(this, args); i < plusLength; ) {
            for (args = [start + i, 0], j = 2; j < 1002 && i < plusLength; j++, i++)
              args[j] = plus[i];
            array_splice.apply(this, args);
          }
          return returnValue;
        }
        return void 0 !== length ? array_splice.call(this, start, length) : void 0 !== start ? array_splice.call(this, start) : [];
      }), define2("peek", function() {
        return this[0];
      }), define2("poke", function(value) {
        this.length > 0 && (this[0] = value);
      }), define2("peekBack", function() {
        if (this.length > 0)
          return this[this.length - 1];
      }), define2("pokeBack", function(value) {
        this.length > 0 && (this[this.length - 1] = value);
      }), define2("one", function() {
        for (var i in this)
          if (Object.owns(this, i))
            return this[i];
      }), Array.prototype.clear || define2("clear", function() {
        return this.length = 0, this;
      }), define2("compare", function(that, compare) {
        var i, length, relative;
        if (compare = compare || Object.compare, this === that)
          return 0;
        if (!that || !Array.isArray(that))
          return GenericOrder2.prototype.compare.call(this, that, compare);
        for (length = this.length < that.length ? this.length : that.length, i = 0; i < length; i++)
          if (i in this) {
            if (!(i in that))
              return -1;
            if (relative = compare(this[i], that[i]))
              return relative;
          } else if (i in that)
            return 1;
        return this.length - that.length;
      }), define2("equals", function(that, equals) {
        equals = equals || Object.equals;
        var i = 0, length = this.length;
        if (this === that)
          return true;
        if (!that || !Array.isArray(that))
          return GenericOrder2.prototype.equals.call(this, that);
        if (length !== that.length)
          return false;
        for (; i < length; ++i)
          if (i in this) {
            if (!(i in that))
              return false;
            if (!equals(this[i], that[i]))
              return false;
          } else if (i in that)
            return false;
        return true;
      }), define2("clone", function(depth, memo) {
        if (null == depth)
          depth = 1 / 0;
        else if (0 === depth)
          return this;
        if ((memo = memo || new WeakMap2()).has(this))
          return memo.get(this);
        var clone = new Array(this.length);
        for (var i in memo.set(this, clone), this)
          clone[i] = Object.clone(this[i], depth - 1, memo);
        return clone;
      }), define2("iterate", function(start, end) {
        return new ArrayIterator(this, start, end);
      }), void 0 === Array.prototype.spliceOne && define2("spliceOne", function(index, itemToAdd) {
        var len = this.length;
        if (len)
          if (1 === arguments.length) {
            for (; index < len; )
              this[index] = this[index + 1], index++;
            this.length--;
          } else
            this[index] = itemToAdd;
      }), define2("Iterator", ArrayIterator), ArrayIterator.prototype.__iterationObject = null, Object.defineProperty(ArrayIterator.prototype, "_iterationObject", { get: function() {
        return this.__iterationObject || (this.__iterationObject = { done: false, value: null });
      } }), ArrayIterator.prototype.next = function() {
        return this.start === (null == this.end ? this.array.length : this.end) ? (this._iterationObject.done = true, this._iterationObject.value = void 0) : this._iterationObject.value = this.array[this.start++], this._iterationObject;
      }, shimArray;
    }
    __name(requireShimArray, "requireShimArray");
    if (GenericOrder$1.prototype.equals = function(that, equals) {
      return equals = equals || this.contentEquals || Object$3.equals, this === that || !!that && (this.length === that.length && this.zip(that).every(function(pair) {
        return equals(pair[0], pair[1]);
      }));
    }, GenericOrder$1.prototype.compare = function(that, compare) {
      if (compare = compare || this.contentCompare || Object$3.compare, this === that)
        return 0;
      if (!that)
        return 1;
      var length = Math.min(this.length, that.length), comparison = this.zip(that).reduce(function(comparison2, pair, index) {
        return 0 === comparison2 ? index >= length ? comparison2 : compare(pair[0], pair[1]) : comparison2;
      }, 0);
      return 0 === comparison ? this.length - that.length : comparison;
    }, GenericOrder$1.prototype.toJSON = function() {
      return this.toArray();
    }, !RegExp.escape) {
      special = /[-[\]{}()*+?.\\^$|,#\s]/g;
      RegExp.escape = function(string) {
        return string.replace(special, "\\$&");
      };
    }
    var special;
    requireShimArray();
    var genericSet = GenericSet$3;
    function GenericSet$3() {
      throw new Error("Can't construct. GenericSet is a mixin.");
    }
    __name(GenericSet$3, "GenericSet$3");
    GenericSet$3.prototype.isSet = true, GenericSet$3.prototype.union = function(that) {
      var union = this.constructClone(this);
      return union.addEach(that), union;
    }, GenericSet$3.prototype.intersection = function(that) {
      return this.constructClone(this.filter(function(value) {
        return that.has(value);
      }));
    }, GenericSet$3.prototype.difference = function(that) {
      var union = this.constructClone(this);
      return union.deleteEach(that), union;
    }, GenericSet$3.prototype.symmetricDifference = function(that) {
      var union = this.union(that), intersection = this.intersection(that);
      return union.difference(intersection);
    }, GenericSet$3.prototype.deleteAll = function(value) {
      return +this.delete(value);
    }, GenericSet$3.prototype.equals = function(that, equals) {
      var self2 = this;
      return that && "function" == typeof that.reduce && this.length === that.length && that.reduce(function(equal, value) {
        return equal && self2.has(value, equals);
      }, true);
    }, GenericSet$3.prototype.forEach = function(callback) {
      var thisp = arguments[1];
      return this.reduce(function(undefined$1, value, key, object, depth) {
        callback.call(thisp, value, value, object, depth);
      }, void 0);
    }, GenericSet$3.prototype.toJSON = function() {
      return this.toArray();
    }, GenericSet$3.prototype.contains = function(value) {
      return this.has(value);
    }, GenericSet$3.prototype.remove = function(value) {
      return this.delete(value);
    }, GenericSet$3.prototype.toggle = function(value) {
      this.has(value) ? this.delete(value) : this.add(value);
    };
    var _valuesArrayFunction$1 = /* @__PURE__ */ __name(function(value, key) {
      return value;
    }, "_valuesArrayFunction$1");
    GenericSet$3.prototype.valuesArray = function() {
      return this.map(_valuesArrayFunction$1);
    };
    var _entriesArrayFunction$1 = /* @__PURE__ */ __name(function(value, key) {
      return [key, value];
    }, "_entriesArrayFunction$1");
    GenericSet$3.prototype.entriesArray = function() {
      return this.map(_entriesArrayFunction$1);
    };
    var _map = { exports: {} };
    var _set = { exports: {} };
    var _list = List$2;
    var GenericCollection$6 = requireGenericCollection();
    var GenericOrder = genericOrder;
    function List$2(values, equals, getDefault) {
      return List$2._init(List$2, this, values, equals, getDefault);
    }
    __name(List$2, "List$2");
    function ListIterator(head) {
      this.head = head, this.at = head.next;
    }
    __name(ListIterator, "ListIterator");
    function Node$1(value) {
      this.value = value, this.prev = null, this.next = null;
    }
    __name(Node$1, "Node$1");
    List$2._init = function(constructor, object, values, equals, getDefault) {
      if (!(object instanceof constructor))
        return new constructor(values, equals, getDefault);
      var head = object.head = new object.Node();
      head.next = head, head.prev = head, object.contentEquals = equals || Object.equals, object.getDefault = getDefault || Function.noop, object.length = 0, object.addEach(values);
    }, List$2.List = List$2, Object.addEach(List$2.prototype, GenericCollection$6.prototype), Object.addEach(List$2.prototype, GenericOrder.prototype), List$2.from = GenericCollection$6.from, List$2.prototype.constructClone = function(values) {
      return new this.constructor(values, this.contentEquals, this.getDefault);
    }, List$2.prototype.find = function(value, equals, index) {
      equals = equals || this.contentEquals;
      for (var head = this.head, at = this.scan(index, head.next); at !== head; ) {
        if (equals(at.value, value))
          return at;
        at = at.next;
      }
    }, List$2.prototype.findLast = function(value, equals, index) {
      equals = equals || this.contentEquals;
      for (var head = this.head, at = this.scan(index, head.prev); at !== head; ) {
        if (equals(at.value, value))
          return at;
        at = at.prev;
      }
    }, List$2.prototype.has = function(value, equals) {
      return !!this.find(value, equals);
    }, List$2.prototype.get = function(value, equals) {
      var found = this.find(value, equals);
      return found ? found.value : this.getDefault(value);
    }, List$2.prototype.delete = function(value, equals) {
      var found = this.findLast(value, equals);
      return !!found && (found.delete(), this.length--, true);
    }, List$2.prototype.deleteAll = function(value, equals) {
      equals = equals || this.contentEquals;
      for (var head = this.head, at = head.next, count = 0; at !== head; )
        equals(value, at.value) && (at.delete(), count++), at = at.next;
      return this.length -= count, count;
    }, List$2.prototype.clear = function() {
      this.head.next = this.head.prev = this.head, this.length = 0;
    }, List$2.prototype.add = function(value) {
      var node = new this.Node(value);
      return this._addNode(node);
    }, List$2.prototype._addNode = function(node) {
      return this.head.addBefore(node), this.length++, true;
    }, List$2.prototype.push = function() {
      for (var head = this.head, i = 0; i < arguments.length; i++) {
        var value = arguments[i], node = new this.Node(value);
        head.addBefore(node);
      }
      this.length += arguments.length;
    }, List$2.prototype.unshift = function() {
      for (var at = this.head, i = 0; i < arguments.length; i++) {
        var value = arguments[i], node = new this.Node(value);
        at.addAfter(node), at = node;
      }
      this.length += arguments.length;
    }, List$2.prototype._shouldPop = function() {
      var value, head = this.head;
      return head.prev !== head && (value = head.prev.value), value;
    }, List$2.prototype.pop = function(_before, _after) {
      var value, head = this.head;
      if (head.prev !== head) {
        value = head.prev.value;
        var index = this.length - 1, popDispatchValueArray = _before ? _before.call(this, value, index) : void 0;
        head.prev.delete(), this.length--, _after && _after.call(this, value, index, popDispatchValueArray);
      }
      return value;
    }, List$2.prototype.shift = function(_before, _after) {
      var value, head = this.head;
      if (head.prev !== head) {
        value = head.next.value;
        var dispatchValueArray = _before ? _before.call(this, value, 0) : void 0;
        head.next.delete(), this.length--, _after && _after.call(this, value, 0, dispatchValueArray);
      }
      return value;
    }, List$2.prototype.peek = function() {
      if (this.head !== this.head.next)
        return this.head.next.value;
    }, List$2.prototype.poke = function(value) {
      this.head !== this.head.next ? this.head.next.value = value : this.push(value);
    }, List$2.prototype.one = function() {
      return this.peek();
    }, List$2.prototype.scan = function(at, fallback) {
      var head = this.head;
      if ("number" == typeof at) {
        var count = at;
        if (count >= 0)
          for (at = head.next; count && (count--, (at = at.next) != head); )
            ;
        else
          for (at = head; count < 0 && (count++, (at = at.prev) != head); )
            ;
        return at;
      }
      return at || fallback;
    }, List$2.prototype.slice = function(at, end) {
      var sliced = [], head = this.head;
      for (at = this.scan(at, head.next), end = this.scan(end, head); at !== end && at !== head; )
        sliced.push(at.value), at = at.next;
      return sliced;
    }, List$2.prototype.splice = function(at, length) {
      return this.swap(at, length, Array.prototype.slice.call(arguments, 2));
    }, List$2.prototype.swap = function(start, length, plus, _before, _after) {
      var initial = start;
      start = this.scan(start, this.head), null == length && (length = 1 / 0), plus = Array.from(plus);
      for (var minus = [], at = start; length-- && length >= 0 && at !== this.head; )
        minus.push(at.value), at = at.next;
      _before && _before.call(this, start, plus, minus);
      at = start;
      var i = 0;
      for (at = start; i < minus.length; i++, at = at.next)
        at.delete();
      null == initial && at === this.head && (at = this.head.next);
      for (i = 0; i < plus.length; i++) {
        var node = new this.Node(plus[i]);
        at.addBefore(node);
      }
      return this.length += plus.length - minus.length, _after && _after.call(this, start, plus, minus), minus;
    }, List$2.prototype.reverse = function() {
      var at = this.head;
      do {
        var temp = at.next;
        at.next = at.prev, at.prev = temp, at = at.next;
      } while (at !== this.head);
      return this;
    }, List$2.prototype.sort = function() {
      this.swap(0, this.length, this.sorted.apply(this, arguments));
    }, List$2.prototype.reduce = function(callback, basis) {
      for (var thisp = arguments[2], head = this.head, at = head.next; at !== head; )
        basis = callback.call(thisp, basis, at.value, at, this), at = at.next;
      return basis;
    }, List$2.prototype.reduceRight = function(callback, basis) {
      for (var thisp = arguments[2], head = this.head, at = head.prev; at !== head; )
        basis = callback.call(thisp, basis, at.value, at, this), at = at.prev;
      return basis;
    }, List$2.prototype.updateIndexes = function(node, index) {
      for (; node !== this.head; )
        node.index = index++, node = node.next;
    }, List$2.prototype.iterate = function() {
      return new ListIterator(this.head);
    }, ListIterator.prototype.__iterationObject = null, Object.defineProperty(ListIterator.prototype, "_iterationObject", { get: function() {
      return this.__iterationObject || (this.__iterationObject = { done: false, value: null });
    } }), ListIterator.prototype.next = function() {
      if (this.at === this.head)
        this._iterationObject.done = true, this._iterationObject.value = void 0;
      else {
        var value = this.at.value;
        this.at = this.at.next, this._iterationObject.value = value;
      }
      return this._iterationObject;
    }, List$2.prototype.Node = Node$1, Node$1.prototype.delete = function() {
      this.prev.next = this.next, this.next.prev = this.prev;
    }, Node$1.prototype.addBefore = function(node) {
      var prev = this.prev;
      this.prev = node, node.prev = prev, prev.next = node, node.next = this;
    }, Node$1.prototype.addAfter = function(node) {
      var next = this.next;
      this.next = node, node.next = next, next.prev = node, node.prev = this;
    };
    var iterator = Iterator$3;
    var Object$2 = shimObject;
    var GenericCollection$5 = requireGenericCollection();
    function Iterator$3(iterable, standardMode) {
      var values = standardMode && iterable && iterable.values && iterable.values();
      if (values && "function" == typeof values.next)
        return values;
      if (!(this instanceof Iterator$3))
        return new Iterator$3(iterable);
      if (Array.isArray(iterable) || "string" == typeof iterable)
        return Iterator$3.iterate(iterable);
      if ((iterable = Object$2(iterable)) instanceof Iterator$3)
        return iterable;
      if (iterable.next)
        this.next = function() {
          return iterable.next();
        };
      else if (iterable.iterate) {
        var iterator2 = iterable.iterate();
        this.next = function() {
          return iterator2.next();
        };
      } else {
        if ("[object Function]" !== Object$2.prototype.toString.call(iterable))
          throw new TypeError("Can't iterate " + iterable);
        this.next = iterable;
      }
    }
    __name(Iterator$3, "Iterator$3");
    Iterator$3.prototype.forEach = GenericCollection$5.prototype.forEach, Iterator$3.prototype.map = GenericCollection$5.prototype.map, Iterator$3.prototype.filter = GenericCollection$5.prototype.filter, Iterator$3.prototype.every = GenericCollection$5.prototype.every, Iterator$3.prototype.some = GenericCollection$5.prototype.some, Iterator$3.prototype.any = GenericCollection$5.prototype.any, Iterator$3.prototype.all = GenericCollection$5.prototype.all, Iterator$3.prototype.min = GenericCollection$5.prototype.min, Iterator$3.prototype.max = GenericCollection$5.prototype.max, Iterator$3.prototype.sum = GenericCollection$5.prototype.sum, Iterator$3.prototype.average = GenericCollection$5.prototype.average, Iterator$3.prototype.flatten = GenericCollection$5.prototype.flatten, Iterator$3.prototype.zip = GenericCollection$5.prototype.zip, Iterator$3.prototype.enumerate = GenericCollection$5.prototype.enumerate, Iterator$3.prototype.sorted = GenericCollection$5.prototype.sorted, Iterator$3.prototype.group = GenericCollection$5.prototype.group, Iterator$3.prototype.reversed = GenericCollection$5.prototype.reversed, Iterator$3.prototype.toArray = GenericCollection$5.prototype.toArray, Iterator$3.prototype.toObject = GenericCollection$5.prototype.toObject, Iterator$3.prototype.iterator = GenericCollection$5.prototype.iterator, Iterator$3.prototype.__iterationObject = null, Object$2.defineProperty(Iterator$3.prototype, "_iterationObject", { get: function() {
      return this.__iterationObject || (this.__iterationObject = { done: false, value: void 0 });
    } }), Iterator$3.prototype.constructClone = function(values) {
      var clone = [];
      return clone.addEach(values), clone;
    }, Iterator$3.prototype.mapIterator = function(callback) {
      var self2 = Iterator$3(this), thisp = arguments[1], i = 0;
      if ("[object Function]" != Object$2.prototype.toString.call(callback))
        throw new TypeError();
      return new self2.constructor(function() {
        if (true !== self2._iterationObject.done) {
          var callbackValue = callback.call(thisp, self2.next().value, i++, self2);
          self2._iterationObject.value = callbackValue;
        }
        return self2._iterationObject;
      });
    }, Iterator$3.prototype.filterIterator = function(callback) {
      var self2 = Iterator$3(this), thisp = arguments[1], i = 0;
      if ("[object Function]" != Object$2.prototype.toString.call(callback))
        throw new TypeError();
      return new self2.constructor(function() {
        for (var nextEntry; ; ) {
          if (true === (nextEntry = self2.next()).done)
            return nextEntry;
          if (callback.call(thisp, nextEntry.value, i++, self2))
            return nextEntry;
        }
      });
    }, Iterator$3.prototype.reduce = function(callback) {
      var nextEntry, self2 = Iterator$3(this), result = arguments[1], thisp = arguments[2], i = 0;
      if ("[object Function]" != Object$2.prototype.toString.call(callback))
        throw new TypeError();
      if (true === (nextEntry = self2.next()).done) {
        if (arguments.length > 1)
          return arguments[1];
        throw TypeError("cannot reduce a value from an empty iterator with no initial value");
      }
      for (result = arguments.length > 1 ? callback.call(thisp, result, nextEntry.value, i, self2) : nextEntry.value, i++; ; ) {
        if (true === (nextEntry = self2.next()).done)
          return result;
        result = callback.call(thisp, result, nextEntry.value, i, self2), i++;
      }
    }, Iterator$3.prototype.concat = function() {
      return Iterator$3.concat(Array.prototype.concat.apply(this, arguments));
    }, Iterator$3.prototype.dropWhile = function(callback) {
      var stopValue, nextEntry, self2 = Iterator$3(this), thisp = arguments[1], stopped = false, i = 0;
      if ("[object Function]" != Object$2.prototype.toString.call(callback))
        throw new TypeError();
      for (; true !== (nextEntry = self2.next()).done; ) {
        if (!callback.call(thisp, nextEntry.value, i, self2)) {
          stopped = true, stopValue = nextEntry.value;
          break;
        }
        i++;
      }
      return stopped ? self2.constructor([stopValue]).concat(self2) : self2.constructor([]);
    }, Iterator$3.prototype.takeWhile = function(callback) {
      var self2 = Iterator$3(this), thisp = arguments[1], i = 0;
      if ("[object Function]" != Object$2.prototype.toString.call(callback))
        throw new TypeError();
      return new self2.constructor(function() {
        if (true !== self2._iterationObject.done) {
          var value = self2.next().value;
          callback.call(thisp, value, i++, self2) ? self2._iterationObject.value = value : (self2._iterationObject.done = true, self2._iterationObject.value = void 0);
        }
        return self2._iterationObject;
      });
    }, Iterator$3.prototype.zipIterator = function() {
      return Iterator$3.unzip(Array.prototype.concat.apply(this, arguments));
    }, Iterator$3.prototype.enumerateIterator = function(start) {
      return Iterator$3.count(start).zipIterator(this);
    }, Iterator$3.iterate = function(iterable) {
      var start;
      return start = 0, new Iterator$3(function() {
        if ("object" == typeof iterable)
          for (; !(start in iterable); ) {
            if (start >= iterable.length) {
              this._iterationObject.done = true, this._iterationObject.value = void 0;
              break;
            }
            start += 1;
          }
        else
          start >= iterable.length && (this._iterationObject.done = true, this._iterationObject.value = void 0);
        return this._iterationObject.done || (this._iterationObject.value = iterable[start], start += 1), this._iterationObject;
      });
    }, Iterator$3.cycle = function(cycle, times) {
      var next;
      return arguments.length < 2 && (times = 1 / 0), new Iterator$3(function() {
        var iteration, nextEntry;
        return next && (nextEntry = next()), next && true !== nextEntry.done || (times > 0 ? (times--, iteration = Iterator$3.iterate(cycle), nextEntry = (next = iteration.next.bind(iteration))()) : (this._iterationObject.done = true, nextEntry = this._iterationObject)), nextEntry;
      });
    }, Iterator$3.concat = function(iterators) {
      var next;
      return iterators = Iterator$3(iterators), new Iterator$3(function() {
        var iteration, nextEntry;
        return next && (nextEntry = next()), nextEntry && true !== nextEntry.done ? nextEntry : false === (nextEntry = iterators.next()).done ? (iteration = Iterator$3(nextEntry.value), (next = iteration.next.bind(iteration))()) : nextEntry;
      });
    }, Iterator$3.unzip = function(iterators) {
      return 0 === (iterators = Iterator$3(iterators).map(Iterator$3)).length ? new Iterator$3([]) : new Iterator$3(function() {
        var stopped, nextEntry, result = iterators.map(function(iterator2) {
          return true === (nextEntry = iterator2.next()).done && (stopped = true), nextEntry.value;
        });
        return stopped ? (this._iterationObject.done = true, this._iterationObject.value = void 0) : this._iterationObject.value = result, this._iterationObject;
      });
    }, Iterator$3.zip = function() {
      return Iterator$3.unzip(Array.prototype.slice.call(arguments));
    }, Iterator$3.chain = function() {
      return Iterator$3.concat(Array.prototype.slice.call(arguments));
    }, Iterator$3.range = function(start, stop, step) {
      return arguments.length < 3 && (step = 1), arguments.length < 2 && (stop = start, start = 0), start = start || 0, step = step || 1, new Iterator$3(function() {
        start >= stop && (this._iterationObject.done = true, this._iterationObject.value = void 0);
        var result = start;
        return start += step, this._iterationObject.value = result, this._iterationObject;
      });
    }, Iterator$3.count = function(start, step) {
      return Iterator$3.range(start, 1 / 0, step);
    }, Iterator$3.repeat = function(value, times) {
      return new Iterator$3.range(times).mapIterator(function() {
        return value;
      });
    };
    var Object$1 = shimObject;
    var Iterator$2 = iterator;
    var genericMap = GenericMap$2;
    function GenericMap$2() {
      throw new Error("Can't construct. GenericMap is a mixin.");
    }
    __name(GenericMap$2, "GenericMap$2");
    function Item(key, value) {
      this.key = key, this.value = value;
    }
    __name(Item, "Item");
    GenericMap$2.prototype.isMap = true, GenericMap$2.prototype.addEach = function(values) {
      var i;
      if (values && Object$1(values) === values)
        if ("function" == typeof values.forEach)
          true === values.isMap ? values.forEach(function(value, key) {
            this.set(key, value);
          }, this) : values.forEach(function(pair) {
            this.set(pair[0], pair[1]);
          }, this);
        else if ("number" == typeof values.length)
          for (i = 0; i < values.length; i++)
            this.add(values[i], i);
        else
          Object$1.keys(values).forEach(function(key) {
            this.set(key, values[key]);
          }, this);
      else if (values && "number" == typeof values.length)
        for (i = 0; i < values.length; i++)
          this.add(values[i], i);
      return this;
    }, GenericMap$2.prototype.get = function(key, defaultValue) {
      var item = this.store.get(new this.Item(key));
      return item ? item.value : arguments.length > 1 ? (console.log("Use of a second argument as default value is deprecated to match standards"), defaultValue) : this.getDefault(key);
    }, GenericMap$2.prototype.set = function(key, value) {
      var item = new this.Item(key, value), found = this.store.get(item);
      return found ? (this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, found.value), found.value = value, this.dispatchesMapChanges && this.dispatchMapChange(key, value)) : (this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, void 0), this.store.add(item) && this.length++, this.dispatchesMapChanges && this.dispatchMapChange(key, value)), this;
    }, GenericMap$2.prototype.add = function(value, key) {
      return this.set(key, value);
    }, GenericMap$2.prototype.has = function(key) {
      return this.store.has(new this.Item(key));
    }, GenericMap$2.prototype.delete = function(key) {
      var item = new this.Item(key);
      if (this.store.has(item)) {
        var from = this.store.get(item).value;
        return this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, from), this.store.delete(item), this.length--, this.dispatchesMapChanges && this.dispatchMapChange(key, void 0), true;
      }
      return false;
    }, GenericMap$2.prototype.clear = function() {
      var keys, key;
      if (this.dispatchesMapChanges && (this.forEach(function(value, key2) {
        this.dispatchBeforeMapChange(key2, value);
      }, this), keys = this.keysArray()), this.store.clear(), this.length = 0, this.dispatchesMapChanges)
        for (var i = 0; key = keys[i]; i++)
          this.dispatchMapChange(key);
    }, GenericMap$2.prototype.reduce = function(callback, basis, thisp) {
      return this.store.reduce(function(basis2, item) {
        return callback.call(thisp, basis2, item.value, item.key, this);
      }, basis, this);
    }, GenericMap$2.prototype.reduceRight = function(callback, basis, thisp) {
      return this.store.reduceRight(function(basis2, item) {
        return callback.call(thisp, basis2, item.value, item.key, this);
      }, basis, this);
    }, GenericMap$2.prototype.keysArray = function() {
      return this.map(function(value, key) {
        return key;
      });
    }, GenericMap$2.prototype.keys = function() {
      return new Iterator$2(this.keysArray(), true);
    }, GenericMap$2.prototype.valuesArray = function() {
      return this.map(Function.identity);
    }, GenericMap$2.prototype.values = function() {
      return new Iterator$2(this.valuesArray(), true);
    }, GenericMap$2.prototype.entriesArray = function() {
      return this.map(function(value, key) {
        return [key, value];
      });
    }, GenericMap$2.prototype.entries = function() {
      return new Iterator$2(this.entriesArray(), true);
    }, GenericMap$2.prototype.items = function() {
      return this.entriesArray();
    }, GenericMap$2.prototype.equals = function(that, equals) {
      return equals = equals || Object$1.equals, this === that || (that && "function" == typeof that.every ? that.length === this.length && that.every(function(value, key) {
        return equals(this.get(key), value);
      }, this) : Object$1.keys(that).length === this.length && Object$1.keys(that).every(function(key) {
        return equals(this.get(key), that[key]);
      }, this));
    }, GenericMap$2.prototype.toJSON = function() {
      return this.entriesArray();
    }, GenericMap$2.prototype.Item = Item, Item.prototype.equals = function(that) {
      return Object$1.equals(this.key, that.key) && Object$1.equals(this.value, that.value);
    }, Item.prototype.compare = function(that) {
      return Object$1.compare(this.key, that.key);
    };
    var GenericCollection$4 = requireGenericCollection();
    var GenericMap$1 = genericMap;
    var _dict = Dict$1;
    function Dict$1(values, getDefault) {
      if (!(this instanceof Dict$1))
        return new Dict$1(values, getDefault);
      getDefault = getDefault || Function.noop, this.getDefault = getDefault, this.store = /* @__PURE__ */ Object.create(null), this.length = 0, this.addEach(values);
    }
    __name(Dict$1, "Dict$1");
    Dict$1.Dict = Dict$1, Object.addEach(Dict$1.prototype, GenericCollection$4.prototype), Object.addEach(Dict$1.prototype, GenericMap$1.prototype), Dict$1.from = GenericCollection$4.from, Dict$1.prototype.constructClone = function(values) {
      return new this.constructor(values, this.getDefault);
    }, Dict$1.prototype.assertString = function(key) {
      if ("string" != typeof key)
        throw new TypeError("key must be a string but Got " + key);
    }, Object.defineProperty(Dict$1.prototype, "$__proto__", { writable: true }), Object.defineProperty(Dict$1.prototype, "_hasProto", { get: function() {
      return this.hasOwnProperty("$__proto__") && void 0 !== this._protoValue;
    } }), Object.defineProperty(Dict$1.prototype, "_protoValue", { get: function() {
      return this.$__proto__;
    }, set: function(value) {
      this.$__proto__ = value;
    } }), Object.defineProperty(Dict$1.prototype, "size", GenericCollection$4._sizePropertyDescriptor), Dict$1.prototype.get = function(key, defaultValue) {
      return this.assertString(key), "__proto__" === key ? this._hasProto ? this._protoValue : arguments.length > 1 ? defaultValue : this.getDefault(key) : key in this.store ? this.store[key] : arguments.length > 1 ? defaultValue : this.getDefault(key);
    }, Dict$1.prototype.set = function(key, value) {
      this.assertString(key);
      var isProtoKey = "__proto__" === key;
      return (isProtoKey ? this._hasProto : key in this.store) ? (this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, isProtoKey ? this._protoValue : this.store[key]), isProtoKey ? this._protoValue = value : this.store[key] = value, this.dispatchesMapChanges && this.dispatchMapChange(key, value), false) : (this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, void 0), this.length++, isProtoKey ? this._protoValue = value : this.store[key] = value, this.dispatchesMapChanges && this.dispatchMapChange(key, value), true);
    }, Dict$1.prototype.has = function(key) {
      return this.assertString(key), "__proto__" === key ? this._hasProto : key in this.store;
    }, Dict$1.prototype.delete = function(key) {
      return this.assertString(key), "__proto__" === key ? !!this._hasProto && (this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, this._protoValue), this._protoValue = void 0, this.length--, this.dispatchesMapChanges && this.dispatchMapChange(key, void 0), true) : key in this.store && (this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, this.store[key]), delete this.store[key], this.length--, this.dispatchesMapChanges && this.dispatchMapChange(key, void 0), true);
    }, Dict$1.prototype.clear = function() {
      var key;
      for (key in this._hasProto && (this.dispatchesMapChanges && this.dispatchBeforeMapChange("__proto__", this._protoValue), this._protoValue = void 0, this.dispatchesMapChanges && this.dispatchMapChange("__proto__", void 0)), this.store)
        this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, this.store[key]), delete this.store[key], this.dispatchesMapChanges && this.dispatchMapChange(key, void 0);
      this.length = 0;
    }, Dict$1.prototype.reduce = function(callback, basis, thisp) {
      this._hasProto && (basis = callback.call(thisp, basis, "$__proto__", "__proto__", this));
      var store = this.store;
      for (var key in this.store)
        basis = callback.call(thisp, basis, store[key], key, this);
      return basis;
    }, Dict$1.prototype.reduceRight = function(callback, basis, thisp) {
      var self2 = this, store = this.store;
      return basis = Object.keys(this.store).reduceRight(function(basis2, key) {
        return callback.call(thisp, basis2, store[key], key, self2);
      }, basis), this._hasProto ? callback.call(thisp, basis, this._protoValue, "__proto__", self2) : basis;
    }, Dict$1.prototype.one = function() {
      var key;
      for (key in this.store)
        return this.store[key];
      return this._protoValue;
    }, Dict$1.prototype.toJSON = function() {
      return this.toObject();
    };
    var treeLog = TreeLog$2;
    function TreeLog$2() {
    }
    __name(TreeLog$2, "TreeLog$2");
    TreeLog$2.ascii = { intersection: "+", through: "-", branchUp: "+", branchDown: "+", fromBelow: ".", fromAbove: "'", fromBoth: "+", strafe: "|" }, TreeLog$2.unicodeRound = { intersection: "\u254B", through: "\u2501", branchUp: "\u253B", branchDown: "\u2533", fromBelow: "\u256D", fromAbove: "\u2570", fromBoth: "\u2523", strafe: "\u2503" }, TreeLog$2.unicodeSharp = { intersection: "\u254B", through: "\u2501", branchUp: "\u253B", branchDown: "\u2533", fromBelow: "\u250F", fromAbove: "\u2517", fromBoth: "\u2523", strafe: "\u2503" };
    var Dict = _dict;
    var List$1 = _list;
    var GenericCollection$3 = requireGenericCollection();
    var GenericSet$2 = genericSet;
    var TreeLog$1 = treeLog;
    var _fastSet = FastSet$1;
    function FastSet$1(values, equals, hash, getDefault) {
      if (!(this instanceof FastSet$1))
        return new FastSet$1(values, equals, hash, getDefault);
      equals = equals || Object.equals, hash = hash || Object.hash, getDefault = getDefault || Function.noop, this.contentEquals = equals, this.contentHash = hash, this.getDefault = getDefault;
      var self2 = this;
      this.buckets = new this.Buckets(null, function() {
        return new self2.Bucket();
      }), this.length = 0, this.addEach(values);
    }
    __name(FastSet$1, "FastSet$1");
    FastSet$1.FastSet = FastSet$1, Object.addEach(FastSet$1.prototype, GenericCollection$3.prototype), Object.addEach(FastSet$1.prototype, GenericSet$2.prototype), FastSet$1.from = GenericCollection$3.from, FastSet$1.prototype.Buckets = Dict, FastSet$1.prototype.Bucket = List$1, FastSet$1.prototype.constructClone = function(values) {
      return new this.constructor(values, this.contentEquals, this.contentHash, this.getDefault);
    }, FastSet$1.prototype.has = function(value) {
      var hash = this.contentHash(value);
      return this.buckets.get(hash).has(value);
    }, FastSet$1.prototype.get = function(value, equals) {
      if (equals)
        throw new Error("FastSet#get does not support second argument: equals");
      var hash = this.contentHash(value), buckets = this.buckets;
      return buckets.has(hash) ? buckets.get(hash).get(value) : this.getDefault(value);
    }, FastSet$1.prototype.delete = function(value, equals) {
      if (equals)
        throw new Error("FastSet#delete does not support second argument: equals");
      var hash = this.contentHash(value), buckets = this.buckets;
      if (buckets.has(hash)) {
        var bucket = buckets.get(hash);
        if (bucket.delete(value))
          return this.length--, 0 === bucket.length && buckets.delete(hash), true;
      }
      return false;
    }, FastSet$1.prototype.clear = function() {
      this.buckets.clear(), this.length = 0;
    }, FastSet$1.prototype.add = function(value) {
      var hash = this.contentHash(value), buckets = this.buckets;
      return buckets.has(hash) || buckets.set(hash, new this.Bucket(null, this.contentEquals)), !buckets.get(hash).has(value) && (buckets.get(hash).add(value), this.length++, true);
    }, FastSet$1.prototype.reduce = function(callback, basis) {
      var thisp = arguments[2], buckets = this.buckets, index = 0;
      return buckets.reduce(function(basis2, bucket) {
        return bucket.reduce(function(basis3, value) {
          return callback.call(thisp, basis3, value, index++, this);
        }, basis2, this);
      }, basis, this);
    }, FastSet$1.prototype.one = function() {
      if (this.length > 0)
        return this.buckets.one().one();
    }, FastSet$1.prototype.iterate = function() {
      return this.buckets.valuesArray().flatten().iterate();
    }, FastSet$1.prototype.log = function(charmap, logNode, callback, thisp) {
      charmap = charmap || TreeLog$1.unicodeSharp, logNode = logNode || this.logNode, callback || (callback = console.log, thisp = console), callback = callback.bind(thisp);
      for (var hash, branch, leader, bucket, buckets = this.buckets, bucketsSize = buckets.size, mapIter = buckets.keys(), index = 0; hash = mapIter.next().value; )
        index === bucketsSize - 1 ? (branch = charmap.fromAbove, leader = " ") : 0 === index ? (branch = charmap.branchDown, leader = charmap.strafe) : (branch = charmap.fromBoth, leader = charmap.strafe), bucket = buckets.get(hash), callback.call(thisp, branch + charmap.through + charmap.branchDown + " " + hash), bucket.forEach(function(value, node) {
          var branch2, below, written;
          node === bucket.head.prev ? (branch2 = charmap.fromAbove, below = " ") : (branch2 = charmap.fromBoth, below = charmap.strafe), logNode(node, function(line) {
            written ? callback.call(thisp, leader + " " + below + "  " + line) : (callback.call(thisp, leader + " " + branch2 + charmap.through + charmap.through + line), written = true);
          }, function(line) {
            callback.call(thisp, leader + " " + charmap.strafe + "  " + line);
          });
        }), index++;
    }, FastSet$1.prototype.logNode = function(node, write) {
      var value = node.value;
      Object(value) === value ? JSON.stringify(value, null, 4).split("\n").forEach(function(line) {
        write(" " + line);
      }) : write(" " + value);
    };
    var GlobalSet;
    var CollectionsSet;
    var GenericCollection$2 = requireGenericCollection();
    var GenericSet$1 = genericSet;
    void 0 !== commonjsGlobal.Set && "function" == typeof commonjsGlobal.Set.prototype.values && ((GlobalSet = _set.exports = commonjsGlobal.Set).Set = GlobalSet, GlobalSet.prototype.reduce = function(callback, basis) {
      var thisp = arguments[2];
      return this.forEach(function(value) {
        basis = callback.call(thisp, basis, value, this);
      }), basis;
    }, GlobalSet.prototype.reduceRight = function(callback, basis) {
      for (var value, thisp = arguments[2], setIterator = this.values(), size = this.size, reverseOrder = new Array(this.size), i = size; value = setIterator.next().value; )
        reverseOrder[--i] = value;
      for (; i < size; )
        basis = callback.call(thisp, basis, reverseOrder[i++], this);
      return basis;
    }, GlobalSet.prototype.equals = function(that, equals) {
      var self2 = this;
      return that && "function" == typeof that.reduce && this.size === (that.size || that.length) && that.reduce(function(equal, value) {
        return equal && self2.has(value, equals);
      }, true);
    }, GlobalSet.prototype.constructClone = function(values) {
      return new this.constructor(values, this.contentEquals, this.contentHash, this.getDefault);
    }, GlobalSet.prototype.toJSON = function() {
      return this.entriesArray();
    }, GlobalSet.prototype.one = function() {
      if (this.size > 0)
        return this.values().next().value;
    }, GlobalSet.prototype.pop = function() {
      if (this.size) {
        for (var aValue, value, setIterator = this.values(); aValue = setIterator.next().value; )
          value = aValue;
        return this.delete(value, this.size - 1), value;
      }
    }, GlobalSet.prototype.shift = function() {
      if (this.size) {
        var firstValue = this.values().next().value;
        return this.delete(firstValue, 0), firstValue;
      }
    }, Object.defineProperty(GlobalSet.prototype, "length", { get: function() {
      return this.size;
    }, enumerable: true, configurable: true }), GlobalSet.from = function(value) {
      var result = new this();
      return result.addEach(value), result;
    }, Object.addEach(GlobalSet.prototype, GenericCollection$2.prototype, false), Object.addEach(GlobalSet.prototype, GenericSet$1.prototype, false));
    var List = _list;
    var FastSet = _fastSet;
    var Iterator$1 = iterator;
    (CollectionsSet = /* @__PURE__ */ __name(function CollectionsSet2(values, equals, hash, getDefault) {
      return CollectionsSet2._init(CollectionsSet2, this, values, equals, hash, getDefault);
    }, "CollectionsSet"))._init = function(constructor, object, values, equals, hash, getDefault) {
      if (!(object instanceof constructor))
        return new constructor(values, equals, hash, getDefault);
      equals = equals || Object.equals, hash = hash || Object.hash, getDefault = getDefault || Function.noop, object.contentEquals = equals, object.contentHash = hash, object.getDefault = getDefault, object.order = new object.Order(void 0, equals), object.store = new object.Store(void 0, function(a, b) {
        return equals(a.value, b.value);
      }, function(node) {
        return hash(node.value);
      }), object.length = 0, object.addEach(values);
    }, CollectionsSet.Set = CollectionsSet, CollectionsSet.CollectionsSet = CollectionsSet, Object.addEach(CollectionsSet.prototype, GenericCollection$2.prototype), Object.addEach(CollectionsSet.prototype, GenericSet$1.prototype), CollectionsSet.from = GenericCollection$2.from, Object.defineProperty(CollectionsSet.prototype, "size", GenericCollection$2._sizePropertyDescriptor), CollectionsSet.prototype.Order = List, CollectionsSet.prototype.Store = FastSet, CollectionsSet.prototype.constructClone = function(values) {
      return new this.constructor(values, this.contentEquals, this.contentHash, this.getDefault);
    }, CollectionsSet.prototype.has = function(value) {
      var node = new this.order.Node(value);
      return this.store.has(node);
    }, CollectionsSet.prototype.get = function(value, equals) {
      if (equals)
        throw new Error("Set#get does not support second argument: equals");
      var node = new this.order.Node(value);
      return (node = this.store.get(node)) ? node.value : this.getDefault(value);
    }, CollectionsSet.prototype.add = function(value) {
      var node = new this.order.Node(value);
      return !this.store.has(node) && (this.length, this.order.add(value), node = this.order.head.prev, this.store.add(node), this.length++, true);
    }, CollectionsSet.prototype.delete = function(value, equals) {
      if (equals)
        throw new Error("Set#delete does not support second argument: equals");
      var node = new this.order.Node(value);
      return !!this.store.has(node) && (node = this.store.get(node), this.store.delete(node), this.order.splice(node, 1), this.length--, true);
    }, CollectionsSet.prototype.pop = function() {
      if (this.length) {
        var result = this.order.head.prev.value;
        return this.delete(result), result;
      }
    }, CollectionsSet.prototype.shift = function() {
      if (this.length) {
        var result = this.order.head.next.value;
        return this.delete(result), result;
      }
    }, CollectionsSet.prototype.one = function() {
      if (this.length > 0)
        return this.store.one().value;
    }, CollectionsSet.prototype.clear = function() {
      this.store.clear(), this.order.clear(), this.length = 0;
    }, Object.defineProperty(CollectionsSet.prototype, "_clear", { value: CollectionsSet.prototype.clear }), CollectionsSet.prototype.reduce = function(callback, basis) {
      var thisp = arguments[2], list = this.order, index = 0;
      return list.reduce(function(basis2, value) {
        return callback.call(thisp, basis2, value, index++, this);
      }, basis, this);
    }, CollectionsSet.prototype.reduceRight = function(callback, basis) {
      var thisp = arguments[2], list = this.order, index = this.length - 1;
      return list.reduceRight(function(basis2, value) {
        return callback.call(thisp, basis2, value, index--, this);
      }, basis, this);
    }, CollectionsSet.prototype.iterate = function() {
      return this.order.iterate();
    }, CollectionsSet.prototype.values = function() {
      return new Iterator$1(this.valuesArray(), true);
    }, CollectionsSet.prototype.log = function() {
      var set = this.store;
      return set.log.apply(set, arguments);
    }, GlobalSet ? (GlobalSet.prototype.valuesArray = GenericSet$1.prototype.valuesArray, GlobalSet.prototype.entriesArray = GenericSet$1.prototype.entriesArray, _set.exports = GlobalSet, GlobalSet.CollectionsSet = CollectionsSet) : _set.exports = CollectionsSet;
    var Map$5;
    var GlobalMap;
    var CollectionsMap;
    var GenericCollection$1 = requireGenericCollection();
    if (void 0 !== commonjsGlobal.Map && "function" == typeof commonjsGlobal.Set.prototype.values) {
      GlobalMap = Map$5 = _map.exports = commonjsGlobal.Map, Map$5.Map = Map$5, map_makeObservable = {}.__proto__ === Object.prototype ? function() {
        this.__proto__ = ChangeDispatchMap;
      } : function() {
        Object.defineProperties(this, observableSetProperties);
      }, Object.defineProperty(Map$5.prototype, "makeObservable", { value: map_makeObservable, writable: true, configurable: true, enumerable: false }), Object.defineProperty(Map$5.prototype, "makePropertyObservable", { value: function() {
      }, writable: true, configurable: true, enumerable: false }), Map$5.prototype.constructClone = function(values) {
        return new this.constructor(values);
      }, Map$5.prototype.isMap = true, Map$5.prototype.addEach = function(values) {
        if (values && Object(values) === values)
          if ("function" == typeof values.forEach)
            true === values.isMap ? values.forEach(function(value, key) {
              this.set(key, value);
            }, this) : values.forEach(function(pair) {
              this.set(pair[0], pair[1]);
            }, this);
          else if ("number" == typeof values.length)
            for (var i = 0; i < values.length; i++)
              this.add(values[i], i);
          else
            Object.keys(values).forEach(function(key) {
              this.set(key, values[key]);
            }, this);
        else if (values && "number" == typeof values.length)
          for (i = 0; i < values.length; i++)
            this.add(values[i], i);
        return this;
      }, Map$5.prototype.add = function(value, key) {
        return this.set(key, value);
      }, Map$5.prototype.reduce = function(callback, basis) {
        var thisp = arguments[2];
        return this.forEach(function(value, key, map2) {
          basis = callback.call(thisp, basis, value, key, this);
        }), basis;
      }, Map$5.prototype.reduceRight = function(callback, basis) {
        for (var aKey, thisp = arguments[2], keysIterator = this.keys(), size = this.size, reverseOrder = new Array(this.size), i = 0; aKey = keysIterator.next().value; )
          reverseOrder[--size] = aKey;
        for (; i++ < size; )
          basis = callback.call(thisp, basis, this.get(reverseOrder[i]), reverseOrder[i], this);
        return basis;
      }, Map$5.prototype.equals = function(that, equals) {
        return equals = equals || Object.equals, this === that || (that && "function" == typeof that.every ? that.size === this.size && that.every(function(value, key) {
          return equals(this.get(key), value);
        }, this) : Object.keys(that).length === this.size && Object.keys(that).every(function(key) {
          return equals(this.get(key), that[key]);
        }, this));
      };
      _keysArrayFunction = /* @__PURE__ */ __name(function(value, key) {
        return key;
      }, "_keysArrayFunction");
      Map$5.prototype.keysArray = function() {
        return this.map(_keysArrayFunction);
      };
      _valuesArrayFunction = /* @__PURE__ */ __name(function(value, key) {
        return value;
      }, "_valuesArrayFunction");
      Map$5.prototype.valuesArray = function() {
        return this.map(_valuesArrayFunction);
      };
      _entriesArrayFunction = /* @__PURE__ */ __name(function(value, key) {
        return [key, value];
      }, "_entriesArrayFunction");
      Map$5.prototype.entriesArray = function() {
        return this.map(_entriesArrayFunction);
      }, Map$5.prototype.toJSON = function() {
        return this.entriesArray();
      }, Map$5.prototype.items = function() {
        return this.entriesArray();
      }, Map$5.from = function(value) {
        var result = new this();
        return result.addEach(value), result;
      }, Object.defineProperty(Map$5.prototype, "length", { get: function() {
        return this.size;
      }, enumerable: true, configurable: true });
      map_clear = Map$5.prototype.clear, map_set = Map$5.prototype.set, map_delete = Map$5.prototype.delete, observableMapProperties = { clear: { value: function() {
        var keys;
        this.dispatchesMapChanges && (this.forEach(function(value, key) {
          this.dispatchBeforeMapChange(key, value);
        }, this), keys = this.keysArray()), map_clear.call(this), this.dispatchesMapChanges && keys.forEach(function(key) {
          this.dispatchMapChange(key);
        }, this);
      }, writable: true, configurable: true }, set: { value: function(key, value) {
        var found = this.get(key);
        return found ? (this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, found), map_set.call(this, key, value), this.dispatchesMapChanges && this.dispatchMapChange(key, value)) : (this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, void 0), map_set.call(this, key, value), this.dispatchesMapChanges && this.dispatchMapChange(key, value)), this;
      }, writable: true, configurable: true }, delete: { value: function(key) {
        return !!this.has(key) && (this.dispatchesMapChanges && this.dispatchBeforeMapChange(key, this.get(key)), map_delete.call(this, key), this.dispatchesMapChanges && this.dispatchMapChange(key, void 0), true);
      } } };
      Object.addEach(Map$5.prototype, GenericCollection$1.prototype, false);
      ChangeDispatchMap = Object.create(Map$5.prototype, observableMapProperties);
    }
    var map_makeObservable;
    var _keysArrayFunction;
    var _valuesArrayFunction;
    var _entriesArrayFunction;
    var map_clear;
    var map_set;
    var map_delete;
    var observableMapProperties;
    var ChangeDispatchMap;
    var Set2 = _set.exports.CollectionsSet;
    var GenericMap = genericMap;
    CollectionsMap = Map$5 = /* @__PURE__ */ __name(function Map3(values, equals, hash, getDefault) {
      if (!(this instanceof Map3))
        return new Map3(values, equals, hash, getDefault);
      equals = equals || Object.equals, hash = hash || Object.hash, getDefault = getDefault || Function.noop, this.contentEquals = equals, this.contentHash = hash, this.getDefault = getDefault, this.store = new Set2(void 0, function(a, b) {
        return equals(a.key, b.key);
      }, function(item) {
        return hash(item.key);
      }), this.length = 0, this.addEach(values);
    }, "Map"), Map$5.Map = Map$5, Object.addEach(Map$5.prototype, GenericCollection$1.prototype), Object.addEach(Map$5.prototype, GenericMap.prototype), Object.defineProperty(Map$5.prototype, "size", GenericCollection$1._sizePropertyDescriptor), Map$5.from = GenericCollection$1.from, Map$5.prototype.constructClone = function(values) {
      return new this.constructor(values, this.contentEquals, this.contentHash, this.getDefault);
    }, Map$5.prototype.log = function(charmap, logNode, callback, thisp) {
      logNode = logNode || this.logNode, this.store.log(charmap, function(node, log, logBefore) {
        logNode(node.value.value, log, logBefore);
      }, callback, thisp);
    }, Map$5.prototype.logNode = function(node, log) {
      log(" key: " + node.key), log(" value: " + node.value);
    }, GlobalMap ? (_map.exports = GlobalMap, GlobalMap.CollectionsMap = CollectionsMap) : _map.exports = CollectionsMap;
    var changeDescriptor = {};
    var Map$4 = _map.exports;
    var ObjectChangeDescriptor$3 = changeDescriptor.ObjectChangeDescriptor = function(name) {
      return this.name = name, this.isActive = false, this._willChangeListeners = null, this._changeListeners = null, this;
    };
    Object.defineProperties(ObjectChangeDescriptor$3.prototype, { name: { value: null, writable: true }, isActive: { value: false, writable: true }, _willChangeListeners: { value: null, writable: true }, willChangeListeners: { get: function() {
      return this._willChangeListeners || (this._willChangeListeners = new this.willChangeListenersRecordConstructor(this.name));
    } }, _changeListeners: { value: null, writable: true }, changeListeners: { get: function() {
      return this._changeListeners || (this._changeListeners = new this.changeListenersRecordConstructor(this.name));
    } }, changeListenersRecordConstructor: { value: ChangeListenersRecord$2, writable: true }, willChangeListenersRecordConstructor: { value: WillChangeListenersRecord, writable: true } });
    var ListenerGhost$3 = changeDescriptor.ListenerGhost = /* @__PURE__ */ Object.create(null);
    var ChangeListenerSpecificHandlerMethodName = new Map$4();
    function ChangeListenersRecord$2(name) {
      var specificHandlerMethodName = ChangeListenerSpecificHandlerMethodName.get(name);
      return specificHandlerMethodName || (specificHandlerMethodName = "handle", specificHandlerMethodName += name, specificHandlerMethodName += "Change", ChangeListenerSpecificHandlerMethodName.set(name, specificHandlerMethodName)), this._current = null, this._current = null, this.specificHandlerMethodName = specificHandlerMethodName, this;
    }
    __name(ChangeListenersRecord$2, "ChangeListenersRecord$2");
    changeDescriptor.ChangeListenersRecord = ChangeListenersRecord$2, Object.defineProperties(ChangeListenersRecord$2.prototype, { _current: { value: null, writable: true }, current: { get: function() {
      return this._current;
    }, set: function(value) {
      this._current = value;
    } }, ListenerGhost: { value: ListenerGhost$3, writable: true }, ghostCount: { value: 0, writable: true }, maxListenerGhostRatio: { value: 0.3, writable: true }, listenerGhostFilter: { value: function(value) {
      return value !== this.ListenerGhost;
    } }, removeCurrentGostListenersIfNeeded: { value: function() {
      return this._current && this.ghostCount / this._current.length > this.maxListenerGhostRatio && (this.ghostCount = 0, this._current = this._current.filter(this.listenerGhostFilter, this)), this._current;
    } }, dispatchBeforeChange: { value: false, writable: true }, genericHandlerMethodName: { value: "handlePropertyChange", writable: true } }), changeDescriptor.WillChangeListenersRecord = WillChangeListenersRecord;
    var WillChangeListenerSpecificHandlerMethodName = new Map$4();
    function WillChangeListenersRecord(name) {
      var specificHandlerMethodName = WillChangeListenerSpecificHandlerMethodName.get(name);
      return specificHandlerMethodName || (specificHandlerMethodName = "handle", specificHandlerMethodName += name, specificHandlerMethodName += "WillChange", WillChangeListenerSpecificHandlerMethodName.set(name, specificHandlerMethodName)), this.specificHandlerMethodName = specificHandlerMethodName, this;
    }
    __name(WillChangeListenersRecord, "WillChangeListenersRecord");
    WillChangeListenersRecord.prototype = new ChangeListenersRecord$2(), WillChangeListenersRecord.prototype.constructor = WillChangeListenersRecord, WillChangeListenersRecord.prototype.genericHandlerMethodName = "handlePropertyWillChange";
    var propertyChanges = PropertyChanges$2;
    function PropertyChanges$2() {
      throw new Error("This is an abstract interface. Mix it. Don't construct it");
    }
    __name(PropertyChanges$2, "PropertyChanges$2");
    var Map$3 = _map.exports;
    var WeakMap$3 = weakMap;
    var ChangeDescriptor$2 = changeDescriptor;
    var ObjectChangeDescriptor$2 = ChangeDescriptor$2.ObjectChangeDescriptor;
    var ListenerGhost$2 = ChangeDescriptor$2.ListenerGhost;
    PropertyChanges$2.debug = true;
    var ObjectsPropertyChangeListeners = new WeakMap$3();
    var ObjectChangeDescriptorName = new Map$3();
    function dispatchEach(listeners, key, value, object) {
      if (listeners && listeners._current) {
        var current, listener, i, countI, thisp, specificHandlerMethodName = listeners.specificHandlerMethodName, genericHandlerMethodName = listeners.genericHandlerMethodName, Ghost = ListenerGhost$2;
        if (Array.isArray(listeners._current)) {
          for (i = 0, countI = (current = listeners.removeCurrentGostListenersIfNeeded()).length; i < countI; i++)
            if ((thisp = current[i]) !== Ghost) {
              if (!(listener = thisp[specificHandlerMethodName] || thisp[genericHandlerMethodName] || thisp).call)
                throw new Error("No event listener for " + listeners.specificHandlerName + " or " + listeners.genericHandlerName + " or call on " + listener);
              listener.call(thisp, value, key, object);
            }
        } else {
          if (!(listener = (thisp = listeners._current)[specificHandlerMethodName] || thisp[genericHandlerMethodName] || thisp).call)
            throw new Error("No event listener for " + listeners.specificHandlerName + " or " + listeners.genericHandlerName + " or call on " + listener);
          listener.call(thisp, value, key, object);
        }
      }
    }
    __name(dispatchEach, "dispatchEach");
    PropertyChanges$2.ObjectChangeDescriptor = function() {
    }, PropertyChanges$2.prototype.getOwnPropertyChangeDescriptor = function(key) {
      var keyChangeDescriptor, objectPropertyChangeDescriptors = ObjectsPropertyChangeListeners.get(this);
      if (objectPropertyChangeDescriptors || (objectPropertyChangeDescriptors = /* @__PURE__ */ Object.create(null), ObjectsPropertyChangeListeners.set(this, objectPropertyChangeDescriptors)), void 0 === (keyChangeDescriptor = objectPropertyChangeDescriptors[key])) {
        var propertyName = ObjectChangeDescriptorName.get(key);
        return propertyName || (propertyName = (propertyName = String(key)) && propertyName[0].toUpperCase() + propertyName.slice(1), ObjectChangeDescriptorName.set(key, propertyName)), objectPropertyChangeDescriptors[key] = new ObjectChangeDescriptor$2(propertyName);
      }
      return keyChangeDescriptor;
    }, PropertyChanges$2.prototype.hasOwnPropertyChangeDescriptor = function(key) {
      var objectPropertyChangeDescriptors = ObjectsPropertyChangeListeners.get(this);
      return !!objectPropertyChangeDescriptors && (!key || void 0 !== objectPropertyChangeDescriptors[key]);
    }, PropertyChanges$2.prototype.addOwnPropertyChangeListener = function(key, listener, beforeChange) {
      this.makeObservable && !this.isObservable && this.makeObservable();
      var descriptor = PropertyChanges$2.getOwnPropertyChangeDescriptor(this, key), listeners = beforeChange ? descriptor.willChangeListeners : descriptor.changeListeners;
      PropertyChanges$2.makePropertyObservable(this, key), listeners._current ? Array.isArray(listeners._current) ? listeners._current.push(listener) : listeners._current = [listeners._current, listener] : listeners._current = listener;
      var self2 = this;
      return function() {
        PropertyChanges$2.removeOwnPropertyChangeListener(self2, key, listener, beforeChange), self2 = null;
      };
    }, PropertyChanges$2.prototype.addBeforeOwnPropertyChangeListener = function(key, listener) {
      return PropertyChanges$2.addOwnPropertyChangeListener(this, key, listener, true);
    }, PropertyChanges$2.prototype.removeOwnPropertyChangeListener = /* @__PURE__ */ __name(function removeOwnPropertyChangeListener(key, listener, beforeChange) {
      var listeners, descriptor = PropertyChanges$2.getOwnPropertyChangeDescriptor(this, key);
      if ((listeners = beforeChange ? descriptor._willChangeListeners : descriptor._changeListeners) && listeners._current)
        if (listeners._current === listener)
          listeners._current = null;
        else {
          var index = listeners._current.lastIndexOf(listener);
          if (-1 === index)
            throw new Error("Can't remove property change listener: does not exist: property name" + JSON.stringify(key));
          descriptor.isActive ? (listeners.ghostCount = listeners.ghostCount + 1, listeners._current[index] = removeOwnPropertyChangeListener.ListenerGhost) : listeners._current.spliceOne(index);
        }
    }, "removeOwnPropertyChangeListener"), PropertyChanges$2.prototype.removeOwnPropertyChangeListener.ListenerGhost = ListenerGhost$2, PropertyChanges$2.prototype.removeBeforeOwnPropertyChangeListener = function(key, listener) {
      return PropertyChanges$2.removeOwnPropertyChangeListener(this, key, listener, true);
    }, PropertyChanges$2.prototype.dispatchOwnPropertyChange = /* @__PURE__ */ __name(function dispatchOwnPropertyChange(key, value, beforeChange) {
      var listeners, descriptor = PropertyChanges$2.getOwnPropertyChangeDescriptor(this, key);
      if (!descriptor.isActive) {
        descriptor.isActive = true, listeners = beforeChange ? descriptor._willChangeListeners : descriptor._changeListeners;
        try {
          dispatchOwnPropertyChange.dispatchEach(listeners, key, value, this);
        } finally {
          descriptor.isActive = false;
        }
      }
    }, "dispatchOwnPropertyChange"), PropertyChanges$2.prototype.dispatchOwnPropertyChange.dispatchEach = dispatchEach, dispatchEach.ListenerGhost = ListenerGhost$2, PropertyChanges$2.prototype.dispatchBeforeOwnPropertyChange = function(key, listener) {
      return PropertyChanges$2.dispatchOwnPropertyChange(this, key, listener, true);
    };
    var ObjectsOverriddenPropertyDescriptors = new WeakMap$3();
    new WeakMap$3();
    var propertyListener = { get: void 0, set: void 0, configurable: true, enumerable: false };
    PropertyChanges$2.prototype.makePropertyObservable = function(key) {
      var overriddenPropertyDescriptors = ObjectsOverriddenPropertyDescriptors.get(this);
      if (!overriddenPropertyDescriptors || void 0 === overriddenPropertyDescriptors.get(key)) {
        if (!overriddenPropertyDescriptors) {
          if (Array.isArray(this))
            return;
          if (!Object.isExtensible(this))
            throw new Error("Can't make property " + JSON.stringify(key) + " observable on " + this + " because object is not extensible");
          overriddenPropertyDescriptors = new Map$3(), ObjectsOverriddenPropertyDescriptors.set(this, overriddenPropertyDescriptors);
        }
        var overriddenDescriptor, attached = this;
        do {
          if (overriddenDescriptor = Object.getOwnPropertyDescriptor(attached, key))
            break;
          attached = Object.getPrototypeOf(attached);
        } while (attached);
        if (overriddenDescriptor) {
          if (!overriddenDescriptor.configurable)
            return;
          if (!overriddenDescriptor.writable && !overriddenDescriptor.set)
            return;
        } else
          overriddenDescriptor = { value: void 0, enumerable: true, writable: true, configurable: true };
        overriddenPropertyDescriptors.set(key, overriddenDescriptor), "value" in overriddenDescriptor ? (propertyListener.get = /* @__PURE__ */ __name(function dispatchingGetter() {
          return dispatchingGetter.overriddenDescriptor.value;
        }, "dispatchingGetter"), propertyListener.set = /* @__PURE__ */ __name(function dispatchingSetter(value) {
          var descriptor, isActive, overriddenDescriptor2 = dispatchingSetter.overriddenDescriptor;
          if (value !== overriddenDescriptor2.value) {
            if (!(isActive = (descriptor = dispatchingSetter.descriptor).isActive)) {
              descriptor.isActive = true;
              try {
                dispatchingSetter.dispatchEach(descriptor._willChangeListeners, dispatchingSetter.key, overriddenDescriptor2.value, this);
              } finally {
              }
            }
            if (overriddenDescriptor2.value = value, !isActive)
              try {
                dispatchingSetter.dispatchEach(descriptor._changeListeners, dispatchingSetter.key, value, this);
              } finally {
                descriptor.isActive = false;
              }
          }
        }, "dispatchingSetter"), propertyListener.set.dispatchEach = dispatchEach, propertyListener.set.key = key, propertyListener.get.overriddenDescriptor = propertyListener.set.overriddenDescriptor = overriddenDescriptor, propertyListener.set.descriptor = ObjectsPropertyChangeListeners.get(this)[key], propertyListener.enumerable = overriddenDescriptor.enumerable, propertyListener.configurable = true) : (propertyListener.get = overriddenDescriptor.get, propertyListener.set = /* @__PURE__ */ __name(function dispatchingSetter() {
          var descriptor, isActive, newValue, formerValue = dispatchingSetter.overriddenGetter.call(this);
          if (1 === arguments.length ? dispatchingSetter.overriddenSetter.call(this, arguments[0]) : 2 === arguments.length ? dispatchingSetter.overriddenSetter.call(this, arguments[0], arguments[1]) : dispatchingSetter.overriddenSetter.apply(this, arguments), (newValue = dispatchingSetter.overriddenGetter.call(this)) !== formerValue) {
            if (!(isActive = (descriptor = dispatchingSetter.descriptor).isActive)) {
              descriptor.isActive = true;
              try {
                dispatchingSetter.dispatchEach(descriptor._willChangeListeners, key, formerValue, this);
              } finally {
              }
            }
            if (!isActive)
              try {
                dispatchingSetter.dispatchEach(descriptor._changeListeners, key, newValue, this);
              } finally {
                descriptor.isActive = false;
              }
          }
        }, "dispatchingSetter"), propertyListener.enumerable = overriddenDescriptor.enumerable, propertyListener.configurable = true, propertyListener.set.dispatchEach = dispatchEach, propertyListener.set.overriddenSetter = overriddenDescriptor.set, propertyListener.set.overriddenGetter = overriddenDescriptor.get, propertyListener.set.descriptor = ObjectsPropertyChangeListeners.get(this)[key]), Object.defineProperty(this, key, propertyListener);
      }
    }, PropertyChanges$2.getOwnPropertyChangeDescriptor = function(object, key) {
      return object.getOwnPropertyChangeDescriptor ? object.getOwnPropertyChangeDescriptor(key) : PropertyChanges$2.prototype.getOwnPropertyChangeDescriptor.call(object, key);
    }, PropertyChanges$2.hasOwnPropertyChangeDescriptor = function(object, key) {
      return object.hasOwnPropertyChangeDescriptor ? object.hasOwnPropertyChangeDescriptor(key) : PropertyChanges$2.prototype.hasOwnPropertyChangeDescriptor.call(object, key);
    }, PropertyChanges$2.addOwnPropertyChangeListener = function(object, key, listener, beforeChange) {
      if (Object.isObject(object))
        return object.addOwnPropertyChangeListener ? object.addOwnPropertyChangeListener(key, listener, beforeChange) : this.prototype.addOwnPropertyChangeListener.call(object, key, listener, beforeChange);
    }, PropertyChanges$2.removeOwnPropertyChangeListener = function(object, key, listener, beforeChange) {
      if (Object.isObject(object))
        return object.removeOwnPropertyChangeListener ? object.removeOwnPropertyChangeListener(key, listener, beforeChange) : PropertyChanges$2.prototype.removeOwnPropertyChangeListener.call(object, key, listener, beforeChange);
    }, PropertyChanges$2.dispatchOwnPropertyChange = function(object, key, value, beforeChange) {
      if (Object.isObject(object))
        return object.dispatchOwnPropertyChange ? object.dispatchOwnPropertyChange(key, value, beforeChange) : PropertyChanges$2.prototype.dispatchOwnPropertyChange.call(object, key, value, beforeChange);
    }, PropertyChanges$2.addBeforeOwnPropertyChangeListener = function(object, key, listener) {
      return PropertyChanges$2.addOwnPropertyChangeListener(object, key, listener, true);
    }, PropertyChanges$2.removeBeforeOwnPropertyChangeListener = function(object, key, listener) {
      return PropertyChanges$2.removeOwnPropertyChangeListener(object, key, listener, true);
    }, PropertyChanges$2.dispatchBeforeOwnPropertyChange = function(object, key, value) {
      return PropertyChanges$2.dispatchOwnPropertyChange(object, key, value, true);
    }, PropertyChanges$2.makePropertyObservable = function(object, key) {
      return object.makePropertyObservable ? object.makePropertyObservable(key) : PropertyChanges$2.prototype.makePropertyObservable.call(object, key);
    };
    var WeakMap$2 = weakMap;
    var Map$2 = _map.exports;
    var ChangeDescriptor$1 = changeDescriptor;
    var ObjectChangeDescriptor$1 = ChangeDescriptor$1.ObjectChangeDescriptor;
    var ChangeListenersRecord$1 = ChangeDescriptor$1.ChangeListenersRecord;
    var ListenerGhost$1 = ChangeDescriptor$1.ListenerGhost;
    var rangeChangeDescriptors = new WeakMap$2();
    function RangeChangeDescriptor(name) {
      this.name = name, this.isActive = false, this._willChangeListeners = null, this._changeListeners = null;
    }
    __name(RangeChangeDescriptor, "RangeChangeDescriptor");
    RangeChangeDescriptor.prototype = new ObjectChangeDescriptor$1(), RangeChangeDescriptor.prototype.constructor = RangeChangeDescriptor, RangeChangeDescriptor.prototype.changeListenersRecordConstructor = RangeChangeListenersRecord, RangeChangeDescriptor.prototype.willChangeListenersRecordConstructor = RangeWillChangeListenersRecord, Object.defineProperty(RangeChangeDescriptor.prototype, "active", { get: function() {
      return this._active || (this._active = this._current ? this._current.slice() : []);
    } });
    var RangeChangeListenersSpecificHandlerMethodName = new Map$2();
    function RangeChangeListenersRecord(name) {
      var specificHandlerMethodName = RangeChangeListenersSpecificHandlerMethodName.get(name);
      return specificHandlerMethodName || (specificHandlerMethodName = "handle", specificHandlerMethodName += name.slice(0, 1).toUpperCase(), specificHandlerMethodName += name.slice(1), specificHandlerMethodName += "RangeChange", RangeChangeListenersSpecificHandlerMethodName.set(name, specificHandlerMethodName)), this.specificHandlerMethodName = specificHandlerMethodName, this;
    }
    __name(RangeChangeListenersRecord, "RangeChangeListenersRecord");
    RangeChangeListenersRecord.prototype = new ChangeListenersRecord$1(), RangeChangeListenersRecord.prototype.constructor = RangeChangeListenersRecord;
    var RangeWillChangeListenersSpecificHandlerMethodName = new Map$2();
    function RangeWillChangeListenersRecord(name) {
      var specificHandlerMethodName = RangeWillChangeListenersSpecificHandlerMethodName.get(name);
      return specificHandlerMethodName || (specificHandlerMethodName = "handle", specificHandlerMethodName += name.slice(0, 1).toUpperCase(), specificHandlerMethodName += name.slice(1), specificHandlerMethodName += "RangeWillChange", RangeWillChangeListenersSpecificHandlerMethodName.set(name, specificHandlerMethodName)), this.specificHandlerMethodName = specificHandlerMethodName, this;
    }
    __name(RangeWillChangeListenersRecord, "RangeWillChangeListenersRecord");
    RangeWillChangeListenersRecord.prototype = new ChangeListenersRecord$1(), RangeWillChangeListenersRecord.prototype.constructor = RangeWillChangeListenersRecord;
    var rangeChanges = RangeChanges$1;
    function RangeChanges$1() {
      throw new Error("Can't construct. RangeChanges is a mixin.");
    }
    __name(RangeChanges$1, "RangeChanges$1");
    RangeChanges$1.prototype.getAllRangeChangeDescriptors = function() {
      return rangeChangeDescriptors.has(this) || rangeChangeDescriptors.set(this, new Map$2()), rangeChangeDescriptors.get(this);
    }, RangeChanges$1.prototype.getRangeChangeDescriptor = function(token) {
      var tokenChangeDescriptors = this.getAllRangeChangeDescriptors();
      return token = token || "", tokenChangeDescriptors.has(token) || tokenChangeDescriptors.set(token, new RangeChangeDescriptor(token)), tokenChangeDescriptors.get(token);
    };
    var ObjectsDispatchesRangeChanges = new WeakMap$2();
    var dispatchesChangesPropertyDescriptor$1 = { get: function() {
      return ObjectsDispatchesRangeChanges.get(this);
    }, set: function(value) {
      return ObjectsDispatchesRangeChanges.set(this, value);
    }, configurable: true, enumerable: false };
    RangeChanges$1.prototype.addRangeChangeListener = function(listener, token, beforeChange) {
      !this.isObservable && this.makeObservable && this.makeObservable();
      var listeners, descriptor = this.getRangeChangeDescriptor(token);
      (listeners = beforeChange ? descriptor.willChangeListeners : descriptor.changeListeners)._current ? Array.isArray(listeners._current) ? listeners._current.push(listener) : listeners._current = [listeners._current, listener] : listeners._current = listener, void 0 === Object.getOwnPropertyDescriptor(this.__proto__ || Object.getPrototypeOf(this), "dispatchesRangeChanges") && Object.defineProperty(this.__proto__ || Object.getPrototypeOf(this), "dispatchesRangeChanges", dispatchesChangesPropertyDescriptor$1), this.dispatchesRangeChanges = true;
      var self2 = this;
      return function() {
        self2 && (self2.removeRangeChangeListener(listener, token, beforeChange), self2 = null);
      };
    }, RangeChanges$1.prototype.removeRangeChangeListener = function(listener, token, beforeChange) {
      var listeners, descriptor = this.getRangeChangeDescriptor(token);
      if ((listeners = beforeChange ? descriptor._willChangeListeners : descriptor._changeListeners)._current)
        if (listeners._current === listener)
          listeners._current = null;
        else {
          var index = listeners._current.lastIndexOf(listener);
          if (-1 === index)
            throw new Error("Can't remove range change listener: does not exist: token " + JSON.stringify(token));
          descriptor.isActive ? (listeners.ghostCount = listeners.ghostCount + 1, listeners._current[index] = ListenerGhost$1) : listeners._current.spliceOne(index);
        }
    }, RangeChanges$1.prototype.dispatchRangeChange = function(plus, minus, index, beforeChange) {
      var descriptor, listeners, tokenName, i, countI, listener, currentListeners, Ghost, descriptors = this.getAllRangeChangeDescriptors(), mapIter = descriptors.values();
      for (descriptors.dispatchBeforeChange = beforeChange; descriptor = mapIter.next().value; ) {
        if (descriptor.isActive)
          return;
        if ((listeners = beforeChange ? descriptor._willChangeListeners : descriptor._changeListeners) && listeners._current)
          if (tokenName = listeners.specificHandlerMethodName, Array.isArray(listeners._current)) {
            if (listeners._current.length) {
              descriptor.isActive = true;
              try {
                for (currentListeners = listeners.removeCurrentGostListenersIfNeeded(), Ghost = ListenerGhost$1, i = 0, countI = currentListeners.length; i < countI; i++)
                  if ((listener = currentListeners[i]) !== Ghost)
                    if (listener[tokenName])
                      listener[tokenName](plus, minus, index, this, beforeChange);
                    else {
                      if (!listener.call)
                        throw new Error("Handler " + listener + " has no method " + tokenName + " and is not callable");
                      listener.call(this, plus, minus, index, this, beforeChange);
                    }
              } finally {
                descriptor.isActive = false;
              }
            }
          } else {
            descriptor.isActive = true;
            try {
              if ((listener = listeners._current)[tokenName])
                listener[tokenName](plus, minus, index, this, beforeChange);
              else {
                if (!listener.call)
                  throw new Error("Handler " + listener + " has no method " + tokenName + " and is not callable");
                listener.call(this, plus, minus, index, this, beforeChange);
              }
            } finally {
              descriptor.isActive = false;
            }
          }
      }
    }, RangeChanges$1.prototype.addBeforeRangeChangeListener = function(listener, token) {
      return this.addRangeChangeListener(listener, token, true);
    }, RangeChanges$1.prototype.removeBeforeRangeChangeListener = function(listener, token) {
      return this.removeRangeChangeListener(listener, token, true);
    }, RangeChanges$1.prototype.dispatchBeforeRangeChange = function(plus, minus, index) {
      return this.dispatchRangeChange(plus, minus, index, true);
    };
    var sortedSet = SortedSet;
    var GenericCollection = requireGenericCollection();
    var GenericSet = genericSet;
    var PropertyChanges$1 = propertyChanges;
    var RangeChanges = rangeChanges;
    var TreeLog = treeLog;
    function SortedSet(values, equals, compare, getDefault) {
      if (!(this instanceof SortedSet))
        return new SortedSet(values, equals, compare, getDefault);
      this.contentEquals = equals || Object.equals, this.contentCompare = compare || Object.compare, this.getDefault = getDefault || Function.noop, this.root = null, this.length = 0, this.addEach(values);
    }
    __name(SortedSet, "SortedSet");
    function Node(value) {
      this.value = value, this.left = null, this.right = null, this.length = 1;
    }
    __name(Node, "Node");
    function Iterator(set, start, end) {
      if (this.set = set, this.prev = null, this.end = end, start) {
        var next = this.set.findLeastGreaterThanOrEqual(start);
        next && (this.set.splay(next.value), this.prev = next.getPrevious());
      }
    }
    __name(Iterator, "Iterator");
    SortedSet.SortedSet = SortedSet, Object.addEach(SortedSet.prototype, GenericCollection.prototype), Object.addEach(SortedSet.prototype, GenericSet.prototype), Object.addEach(SortedSet.prototype, PropertyChanges$1.prototype), Object.addEach(SortedSet.prototype, RangeChanges.prototype), Object.defineProperty(SortedSet.prototype, "size", GenericCollection._sizePropertyDescriptor), SortedSet.from = GenericCollection.from, SortedSet.prototype.isSorted = true, SortedSet.prototype.constructClone = function(values) {
      return new this.constructor(values, this.contentEquals, this.contentCompare, this.getDefault);
    }, SortedSet.prototype.has = function(value, equals) {
      if (equals)
        throw new Error("SortedSet#has does not support second argument: equals");
      return !!this.root && (this.splay(value), this.contentEquals(value, this.root.value));
    }, SortedSet.prototype.get = function(value, equals) {
      if (equals)
        throw new Error("SortedSet#get does not support second argument: equals");
      return this.root && (this.splay(value), this.contentEquals(value, this.root.value)) ? this.root.value : this.getDefault(value);
    }, SortedSet.prototype.add = function(value) {
      var node = new this.Node(value);
      if (!this.root)
        return this.dispatchesRangeChanges && this.dispatchBeforeRangeChange([value], [], 0), this.root = node, this.length++, this.dispatchesRangeChanges && this.dispatchRangeChange([value], [], 0), true;
      if (this.splay(value), !this.contentEquals(value, this.root.value)) {
        var comparison = this.contentCompare(value, this.root.value);
        if (0 === comparison)
          throw new Error("SortedSet cannot contain incomparable but inequal values: " + value + " and " + this.root.value);
        return this.dispatchesRangeChanges && this.dispatchBeforeRangeChange([value], [], this.root.index), comparison < 0 ? (node.right = this.root, node.left = this.root.left, this.root.left = null, this.root.touch()) : (node.left = this.root, node.right = this.root.right, this.root.right = null, this.root.touch()), node.touch(), this.root = node, this.length++, this.dispatchesRangeChanges && this.dispatchRangeChange([value], [], this.root.index), true;
      }
      return false;
    }, SortedSet.prototype.delete = function(value, equals) {
      if (equals)
        throw new Error("SortedSet#delete does not support second argument: equals");
      if (this.root && (this.splay(value), this.contentEquals(value, this.root.value))) {
        var index = this.root.index;
        if (this.dispatchesRangeChanges && this.dispatchBeforeRangeChange([], [value], index), this.root.left) {
          var right = this.root.right;
          this.root = this.root.left, this.splay(value), this.root.right = right;
        } else
          this.root = this.root.right;
        return this.length--, this.root && this.root.touch(), this.dispatchesRangeChanges && this.dispatchRangeChange([], [value], index), true;
      }
      return false;
    }, SortedSet.prototype.indexOf = function(value, index) {
      if (index)
        throw new Error("SortedSet#indexOf does not support second argument: startIndex");
      return this.root && (this.splay(value), this.contentEquals(value, this.root.value)) ? this.root.index : -1;
    }, SortedSet.prototype.find = function(value, equals, index) {
      if (equals)
        throw new Error("SortedSet#find does not support second argument: equals");
      if (index)
        throw new Error("SortedSet#find does not support third argument: index");
      if (this.root && (this.splay(value), this.contentEquals(value, this.root.value)))
        return this.root;
    }, SortedSet.prototype.findGreatest = function(at) {
      if (this.root) {
        for (at = at || this.root; at.right; )
          at = at.right;
        return at;
      }
    }, SortedSet.prototype.findLeast = function(at) {
      if (this.root) {
        for (at = at || this.root; at.left; )
          at = at.left;
        return at;
      }
    }, SortedSet.prototype.findGreatestLessThanOrEqual = function(value) {
      if (this.root)
        return this.splay(value), this.contentCompare(this.root.value, value) > 0 ? this.root.getPrevious() : this.root;
    }, SortedSet.prototype.findGreatestLessThan = function(value) {
      if (this.root)
        return this.splay(value), this.contentCompare(this.root.value, value) >= 0 ? this.root.getPrevious() : this.root;
    }, SortedSet.prototype.findLeastGreaterThanOrEqual = function(value) {
      if (this.root)
        return this.splay(value), this.contentCompare(this.root.value, value) >= 0 ? this.root : this.root.getNext();
    }, SortedSet.prototype.findLeastGreaterThan = function(value) {
      if (this.root)
        return this.splay(value), this.contentCompare(this.root.value, value) <= 0 ? this.root.getNext() : this.root;
    }, SortedSet.prototype.pop = function() {
      if (this.root) {
        var found = this.findGreatest();
        return this.delete(found.value), found.value;
      }
    }, SortedSet.prototype.shift = function() {
      if (this.root) {
        var found = this.findLeast();
        return this.delete(found.value), found.value;
      }
    }, SortedSet.prototype.push = function() {
      this.addEach(arguments);
    }, SortedSet.prototype.unshift = function() {
      this.addEach(arguments);
    }, SortedSet.prototype.slice = function(start, end) {
      start = start || 0, end = end || this.length, start < 0 && (start += this.length), end < 0 && (end += this.length);
      var sliced = [];
      if (this.root)
        for (this.splayIndex(start); this.root.index < end && (sliced.push(this.root.value), this.root.right); )
          this.splay(this.root.getNext().value);
      return sliced;
    }, SortedSet.prototype.splice = function(at, length) {
      return this.swap(at, length, Array.prototype.slice.call(arguments, 2));
    }, SortedSet.prototype.swap = function(start, length, plus) {
      if (void 0 === start && void 0 === length)
        return [];
      (start = start || 0) < 0 && (start += this.length), void 0 === length && (length = 1 / 0);
      var swapped = [];
      if (this.root) {
        this.splayIndex(start);
        for (var i = 0; i < length; i++) {
          swapped.push(this.root.value);
          var next = this.root.getNext();
          if (this.delete(this.root.value), !next)
            break;
          this.splay(next.value);
        }
      }
      return this.addEach(plus), swapped;
    }, SortedSet.prototype.splay = function(value) {
      var stub, left, right, temp, root, history;
      if (this.root) {
        for (stub = left = right = new this.Node(), history = new this.Node(), root = this.root; ; ) {
          var comparison = this.contentCompare(value, root.value);
          if (comparison < 0) {
            if (!root.left)
              break;
            if (this.contentCompare(value, root.left.value) < 0 && (temp = root.left, root.left = temp.right, root.touch(), temp.right = root, temp.touch(), !(root = temp).left))
              break;
            (temp = new Node()).right = root, temp.left = history.left, history.left = temp, right.left = root, right.touch(), right = root, root = root.left;
          } else {
            if (!(comparison > 0))
              break;
            if (!root.right)
              break;
            if (this.contentCompare(value, root.right.value) > 0 && (temp = root.right, root.right = temp.left, root.touch(), temp.left = root, temp.touch(), !(root = temp).right))
              break;
            (temp = new Node()).left = root, temp.right = history.right, history.right = temp, left.right = root, left.touch(), left = root, root = root.right;
          }
        }
        for (left.right = root.left, left.touch(), right.left = root.right, right.touch(), root.left = stub.right, root.right = stub.left; history.left; )
          history.left.right.touch(), history.left = history.left.left;
        for (; history.right; )
          history.right.left.touch(), history.right = history.right.right;
        root.touch(), this.root = root;
      }
    }, SortedSet.prototype.splayIndex = function(index) {
      if (this.root) {
        for (var at = this.root, atIndex = this.root.index; atIndex !== index; )
          if (atIndex > index && at.left)
            atIndex -= 1 + ((at = at.left).right ? at.right.length : 0);
          else {
            if (!(atIndex < index && at.right))
              break;
            atIndex += 1 + ((at = at.right).left ? at.left.length : 0);
          }
        return this.splay(at.value), this.root.index === index;
      }
      return false;
    }, SortedSet.prototype.reduce = function(callback, basis, thisp) {
      return this.root && (basis = this.root.reduce(callback, basis, 0, thisp, this)), basis;
    }, SortedSet.prototype.reduceRight = function(callback, basis, thisp) {
      return this.root && (basis = this.root.reduceRight(callback, basis, this.length - 1, thisp, this)), basis;
    }, SortedSet.prototype.min = function(at) {
      var least = this.findLeast(at);
      if (least)
        return least.value;
    }, SortedSet.prototype.max = function(at) {
      var greatest = this.findGreatest(at);
      if (greatest)
        return greatest.value;
    }, SortedSet.prototype.one = function() {
      return this.min();
    }, SortedSet.prototype.clear = function() {
      var minus;
      this.dispatchesRangeChanges && (minus = this.toArray(), this.dispatchBeforeRangeChange([], minus, 0)), this.root = null, this.length = 0, this.dispatchesRangeChanges && this.dispatchRangeChange([], minus, 0);
    }, SortedSet.prototype.iterate = function(start, end) {
      return new this.Iterator(this, start, end);
    }, SortedSet.prototype.Iterator = Iterator, SortedSet.prototype.summary = function() {
      return this.root ? this.root.summary() : "()";
    }, SortedSet.prototype.log = function(charmap, logNode, callback, thisp) {
      charmap = charmap || TreeLog.unicodeRound, logNode = logNode || this.logNode, callback || (callback = console.log, thisp = console), callback = callback.bind(thisp), this.root && this.root.log(charmap, logNode, callback, callback);
    }, SortedSet.prototype.logNode = function(node, log, logBefore) {
      log(" " + node.value);
    }, SortedSet.logCharsets = TreeLog, SortedSet.prototype.Node = Node, Node.prototype.reduce = function(callback, basis, index, thisp, tree, depth) {
      if (depth = depth || 0, this.left) {
        var length = this.left.length;
        basis = this.left.reduce(callback, basis, index, thisp, tree, depth + 1), index += length;
      }
      return basis = callback.call(thisp, basis, this.value, index, tree, this, depth), index += 1, this.right && (basis = this.right.reduce(callback, basis, index, thisp, tree, depth + 1)), basis;
    }, Node.prototype.reduceRight = function(callback, basis, index, thisp, tree, depth) {
      return depth = depth || 0, this.right && (basis = this.right.reduceRight(callback, basis, index, thisp, tree, depth + 1), index -= this.right.length), basis = callback.call(thisp, basis, this.value, this.value, tree, this, depth), index -= 1, this.left && (basis = this.left.reduceRight(callback, basis, index, thisp, tree, depth + 1)), basis;
    }, Node.prototype.touch = function() {
      this.length = 1 + (this.left ? this.left.length : 0) + (this.right ? this.right.length : 0), this.index = this.left ? this.left.length : 0;
    }, Node.prototype.checkIntegrity = function() {
      var length = 1;
      if (length += this.left ? this.left.checkIntegrity() : 0, length += this.right ? this.right.checkIntegrity() : 0, this.length !== length)
        throw new Error("Integrity check failed: " + this.summary());
      return length;
    }, Node.prototype.getNext = function() {
      var node = this;
      if (node.right) {
        for (node = node.right; node.left; )
          node = node.left;
        return node;
      }
    }, Node.prototype.getPrevious = function() {
      var node = this;
      if (node.left) {
        for (node = node.left; node.right; )
          node = node.right;
        return node;
      }
    }, Node.prototype.summary = function() {
      var value = this.value || "-";
      return value += " <" + this.length, this.left || this.right ? "(" + value + " " + (this.left ? this.left.summary() : "()") + ", " + (this.right ? this.right.summary() : "()") + ")" : "(" + value + ")";
    }, Node.prototype.log = function(charmap, logNode, log, logAbove) {
      var branch, loggedAbove, loggedOn, loggedBelow, self2 = this;
      branch = this.left && this.right ? charmap.intersection : this.left ? charmap.branchUp : this.right ? charmap.branchDown : charmap.through, this.left && this.left.log(charmap, logNode, function(line) {
        loggedAbove ? logAbove(charmap.strafe + " " + line) : (loggedAbove = true, logAbove(charmap.fromBelow + charmap.through + line));
      }, function(line) {
        logAbove("  " + line);
      }), logNode(this, function(line) {
        loggedOn ? log((self2.right ? charmap.strafe : " ") + line) : (loggedOn = true, log(branch + line));
      }, function(line) {
        logAbove((self2.left ? charmap.strafe : " ") + line);
      }), this.right && this.right.log(charmap, logNode, function(line) {
        loggedBelow ? log("  " + line) : (loggedBelow = true, log(charmap.fromAbove + charmap.through + line));
      }, function(line) {
        log(charmap.strafe + " " + line);
      });
    }, Iterator.prototype.__iterationObject = null, Object.defineProperty(Iterator.prototype, "_iterationObject", { get: function() {
      return this.__iterationObject || (this.__iterationObject = { done: false, value: null });
    } }), Iterator.prototype.next = function() {
      var next;
      return (next = this.prev ? this.set.findLeastGreaterThan(this.prev.value) : this.set.findLeast()) ? void 0 !== this.end && this.set.contentCompare(next.value, this.end) >= 0 ? (this._iterationObject.done = true, this._iterationObject.value = void 0) : (this.prev = next, this._iterationObject.value = next.value) : (this._iterationObject.done = true, this._iterationObject.value = void 0), this._iterationObject;
    };
    var WGS84 = { a: 6378.137, b: 6356.752314245, f: 1 / 298.257223563 };
    function radians(degrees2) {
      return degrees2 / (180 / Math.PI);
    }
    __name(radians, "radians");
    function degrees(radians2) {
      return radians2 * (180 / Math.PI);
    }
    __name(degrees, "degrees");
    var Point = class {
      constructor(x, y) {
        Array.isArray(x) ? (this.x = +x[y].longitude, this.y = +x[y].latitude, this.r = +y) : (this.x = x, this.y = y);
      }
      geojson(id2, properties) {
        return { type: "Feature", id: id2, properties: properties || {}, geometry: { type: "Point", coordinates: [this.x, this.y] } };
      }
      toString() {
        return JSON.stringify(this.geojson());
      }
      intersects(other) {
        if (other instanceof Point)
          return this.x == other.x && this.y == other.y;
        if (other instanceof Box)
          return other.intersects(this);
        throw new TypeError("other must be either Point or Box");
      }
      distanceEarth(p) {
        return this.distanceEarthFCC(p);
      }
      distanceEarthFCC(p) {
        const df = p.y - this.y, dg = p.x - this.x, fm = radians((this.y + p.y) / 2), cosfm = Math.cos(fm), cos2fm = 2 * cosfm * cosfm - 1, cos3fm = cosfm * (2 * cos2fm - 1), k1 = 111.13209 - 0.566605 * cos2fm + 12e-4 * (2 * cos2fm * cos2fm - 1), k2 = 111.41513 * cosfm - 0.09455 * cos3fm + 12e-5 * (2 * cos2fm * cos3fm - cosfm);
        return Math.sqrt(k1 * df * (k1 * df) + k2 * dg * (k2 * dg));
      }
      distanceEarthRev(dx, dy) {
        const lon = this.x + degrees(dx / 6371 / Math.cos(radians(this.y))), lat = this.y + degrees(dy / 6371);
        return new Point(lon, lat);
      }
      distanceEarthVincentys(p) {
        return function(p1, p2) {
          const \u03C61 = radians(p1.y), \u03BB1 = radians(p1.x), \u03C62 = radians(p2.y), \u03BB2 = radians(p2.x), { a, b, f } = WGS84, L = \u03BB2 - \u03BB1, tanU1 = (1 - f) * Math.tan(\u03C61), cosU1 = 1 / Math.sqrt(1 + tanU1 * tanU1), sinU1 = tanU1 * cosU1, tanU2 = (1 - f) * Math.tan(\u03C62), cosU2 = 1 / Math.sqrt(1 + tanU2 * tanU2), sinU2 = tanU2 * cosU2, sinU1sinU2 = sinU1 * sinU2, cosU1cosU2 = cosU1 * cosU2, cosU1sinU2 = cosU1 * sinU2, sinU1cosU2 = sinU1 * cosU2, antipodal = Math.abs(L) > Math.PI / 2 || Math.abs(\u03C62 - \u03C61) > Math.PI / 2;
          let \u03BB = L, sin\u03BB = null, cos\u03BB = null, \u03C3 = antipodal ? Math.PI : 0, sin\u03C3 = 0, cos\u03C3 = antipodal ? -1 : 1, sinSq\u03C3 = null, cos2\u03C3\u2098 = 1, sin\u03B1 = null, cosSq\u03B1 = 1, C = null, \u03BB\u02B9 = null, iterations = 0;
          do {
            sin\u03BB = Math.sin(\u03BB), cos\u03BB = Math.cos(\u03BB);
            const term1 = cosU2 * sin\u03BB, term2 = cosU1sinU2 - sinU1cosU2 * cos\u03BB;
            if (sinSq\u03C3 = term1 * term1 + term2 * term2, Math.abs(sinSq\u03C3) < Number.EPSILON)
              break;
            if (sin\u03C3 = Math.sqrt(sinSq\u03C3), cos\u03C3 = sinU1sinU2 + cosU1cosU2 * cos\u03BB, \u03C3 = Math.atan2(sin\u03C3, cos\u03C3), sin\u03B1 = cosU1cosU2 * sin\u03BB / sin\u03C3, cosSq\u03B1 = 1 - sin\u03B1 * sin\u03B1, cos2\u03C3\u2098 = 0 != cosSq\u03B1 ? cos\u03C3 - 2 * sinU1sinU2 / cosSq\u03B1 : 0, C = f / 16 * cosSq\u03B1 * (4 + f * (4 - 3 * cosSq\u03B1)), \u03BB\u02B9 = \u03BB, \u03BB = L + (1 - C) * f * sin\u03B1 * (\u03C3 + C * sin\u03C3 * (cos2\u03C3\u2098 + C * cos\u03C3 * (2 * cos2\u03C3\u2098 * cos2\u03C3\u2098 - 1))), (antipodal ? Math.abs(\u03BB) - Math.PI : Math.abs(\u03BB)) > Math.PI)
              throw new EvalError("\u03BB > \u03C0");
          } while (Math.abs(\u03BB - \u03BB\u02B9) > 1e-7 && ++iterations < 1e3);
          if (iterations >= 1e3)
            throw new EvalError("Vincenty formula failed to converge");
          const uSq = cosSq\u03B1 * (a * a - b * b) / (b * b), B = uSq / 1024 * (256 + uSq * (uSq * (74 - 47 * uSq) - 128)), s = b * (1 + uSq / 16384 * (4096 + uSq * (uSq * (320 - 175 * uSq) - 768))) * (\u03C3 - B * sin\u03C3 * (cos2\u03C3\u2098 + B / 4 * (cos\u03C3 * (2 * cos2\u03C3\u2098 * cos2\u03C3\u2098 - 1) - B / 6 * cos2\u03C3\u2098 * (4 * sin\u03C3 * sin\u03C3 - 3) * (4 * cos2\u03C3\u2098 * cos2\u03C3\u2098 - 3)))), \u03B11 = Math.abs(sinSq\u03C3) < Number.EPSILON ? 0 : Math.atan2(cosU2 * sin\u03BB, cosU1sinU2 - sinU1cosU2 * cos\u03BB), \u03B12 = Math.abs(sinSq\u03C3) < Number.EPSILON ? Math.PI : Math.atan2(cosU1 * sin\u03BB, cosU1sinU2 * cos\u03BB - sinU1cosU2);
          return { distance: s, initialBearing: Math.abs(s) < Number.EPSILON ? NaN : degrees(\u03B11), finalBearing: Math.abs(s) < Number.EPSILON ? NaN : degrees(\u03B12), iterations };
        }(this, p).distance;
      }
    };
    __name(Point, "Point");
    var Range = class {
      constructor(start, end) {
        if (this.start = start, this.end = end, end < start)
          throw new Error("start should be before end");
      }
      count() {
        return this.end - this.start + 1;
      }
      center() {
        return this.start + Math.floor((this.end - this.start) / 2);
      }
      left() {
        return new Range(this.start, this.center());
      }
      right() {
        return new Range(this.start + Math.ceil((this.end - this.start) / 2), this.end);
      }
      contains(p) {
        return this.start <= p && p <= this.end;
      }
      toString() {
        return `${this.start}:${this.end}`;
      }
    };
    __name(Range, "Range");
    var Box = class {
      constructor(a, b, c, d) {
        if (a instanceof Range) {
          this.x1 = 1 / 0, this.y1 = 1 / 0, this.x2 = -1 / 0, this.y2 = -1 / 0;
          for (let i = a.start; i <= a.end; i++)
            this.x1 = Math.min(b.flightPoints[i].x, this.x1), this.y1 = Math.min(b.flightPoints[i].y, this.y1), this.x2 = Math.max(b.flightPoints[i].x, this.x2), this.y2 = Math.max(b.flightPoints[i].y, this.y2);
        } else
          this.x1 = a, this.y1 = b, this.x2 = c, this.y2 = d;
      }
      vertices() {
        return [new Point(this.x1, this.y1), new Point(this.x2, this.y1), new Point(this.x2, this.y2), new Point(this.x1, this.y2)];
      }
      intersects(other) {
        return other instanceof Point ? this.x1 <= other.x && this.y1 <= other.y && this.x2 >= other.x && this.y2 >= other.y : !(this.x1 > other.x2 || this.x2 < other.x1 || this.y1 > other.y2 || this.y2 < other.y1);
      }
      area() {
        return Math.abs((this.x2 - this.x1) * (this.y2 - this.y1));
      }
      distance(other) {
        if (this.intersects(other))
          return 0;
        let x1 = this.x1, x2 = this.x1, y1 = this.y1, y2 = this.y1;
        return this.x1 > other.x2 ? x2 = other.x2 : this.x2 < other.x1 && (x1 = this.x2, x2 = other.x1), this.y1 < other.y2 ? y2 = other.y2 : this.y2 > other.y1 && (y1 = this.y2, y2 = other.y1), new Point(x1, y1).distanceEarth(new Point(x2, y2));
      }
      geojson(id2, properties) {
        return { type: "Feature", id: id2, properties: properties || {}, geometry: { type: "Polygon", coordinates: [[[this.x1, this.y1], [this.x1, this.y2], [this.x2, this.y2], [this.x2, this.y1], [this.x1, this.y1]]] } };
      }
      geojson_collection(boxes) {
        let features = [];
        for (let i = 0; i < boxes.length; i++)
          features.push(boxes[i].geojson(i, { id: i }));
        return { type: "FeatureCollection", features };
      }
      toString() {
        return JSON.stringify(this.geojson());
      }
    };
    __name(Box, "Box");
    var id = 0;
    var Solution2 = class {
      constructor(ranges, opt, parent) {
        ranges.length > opt.scoring.cardinality ? this.ranges = ranges.slice(0, opt.scoring.cardinality) : this.ranges = ranges, this.opt = opt, this.boxes = [];
        for (let r = 0; r < this.ranges.length; r++)
          r > 0 && this.ranges[r - 1].start > this.ranges[r].start && (this.ranges[r] = new Range(this.ranges[r - 1].start, this.ranges[r].end)), r < this.ranges.length - 1 && this.ranges[r].end > this.ranges[r + 1].end && (this.ranges[r] = new Range(this.ranges[r].start, this.ranges[r + 1].end)), this.boxes[r] = new Box(this.ranges[r], opt.flight);
        this.score = void 0, this.bound = void 0, this.id = id++, this.opt.config && this.opt.config.debug && (this.parent = parent, this.trace("constructor"));
      }
      do_branch() {
        let div = 0;
        for (let r = 0; r < this.ranges.length; r++)
          this.ranges[r].count() > this.ranges[div].count() && (div = r);
        for (let r = 0; r < this.ranges.length; r++)
          this.ranges[r].count() > 1 && this.boxes[r].area() > 8 * this.boxes[div].area() && (div = r);
        if (1 == this.ranges[div].count())
          return [];
        let subsolutions = [];
        for (let i of [this.ranges[div].left(), this.ranges[div].right()]) {
          let subranges = [];
          for (let r = 0; r < this.ranges.length; r++)
            subranges[r] = r != div ? this.ranges[r] : i;
          subsolutions.push(new Solution2(subranges, this.opt, this));
        }
        return subsolutions;
      }
      do_bound() {
        this.bound = this.opt.scoring.bound(this.ranges, this.boxes, this.opt), this.trace("bounding");
      }
      do_score() {
        for (let r = 0; r < this.ranges.length; r++)
          if (r < this.ranges.length - 1 && this.ranges[r].center() >= this.ranges[r + 1].center())
            return void (this.score = 0);
        let tp = [];
        for (let r = 0; r < this.ranges.length; r++)
          tp[r] = new Point(this.opt.flight.filtered, this.ranges[r].center());
        this.scoreInfo = this.opt.scoring.score(tp, this.opt), this.opt.scoring.post && this.opt.scoring.post(this.scoreInfo, this.opt), this.score = this.scoreInfo.score, this.trace("scoring");
      }
      contentEquals(self2, other) {
        return self2.id === other.id;
      }
      contentCompare(self2, other) {
        return self2.bound < other.bound ? -1 : self2.bound > other.bound ? 1 : self2.id < other.id ? -1 : self2.id > other.id ? 1 : 0;
      }
      geojson() {
        let features = [];
        if (this.opt.config && this.opt.config.debug)
          for (let r = 0; r < this.ranges.length; r++)
            features.push(new Box(this.ranges[r], this.opt.flight).geojson("box" + r, { id: "box" + r, area: new Box(this.ranges[r], this.opt.flight).area(), a: this.ranges[r].start, b: this.ranges[r].end }));
        try {
          const tp = this.scoreInfo.tp;
          for (const r in tp)
            features.push(tp[r].geojson("tp" + r, { id: "tp" + r, r: tp[r].r, timestamp: void 0 !== tp[r].r ? this.opt.flight.filtered[tp[r].r].timestamp : void 0 })), this.scoreInfo.ep && r == tp.length - 1 || features.push({ type: "Feature", id: "seg" + r, properties: { id: "seg" + r, stroke: "yellow", "stroke-width": 4, d: tp[r].distanceEarth(tp[(r + 1) % tp.length]) }, geometry: { type: "LineString", coordinates: [[tp[r].x, tp[r].y], [tp[(r + 1) % tp.length].x, tp[(r + 1) % tp.length].y]], style: { stroke: "yellow", "stroke-width": 4 } } });
          if (this.opt.config.debug && this.boxes)
            for (const b in this.boxes)
              features.push({ type: "Feature", id: "box" + b, properties: { id: "box" + b, stroke: "black", "stroke-width": 4 }, geometry: { type: "LineString", coordinates: [[this.boxes[b].x1, this.boxes[b].y1], [this.boxes[b].x2, this.boxes[b].y1], [this.boxes[b].x2, this.boxes[b].y2], [this.boxes[b].x1, this.boxes[b].y2], [this.boxes[b].x1, this.boxes[b].y1]], style: { stroke: "black", "stroke-width": 4 } } });
        } catch (e) {
        }
        try {
          if (void 0 !== this.scoreInfo.ep || void 0 !== this.scoreInfo.cp) {
            const cp = this.scoreInfo.cp, tp = this.scoreInfo.tp, ep = this.scoreInfo.ep;
            if (cp && cp.in && cp.out) {
              for (let r of ["in", "out"])
                features.push(cp[r].geojson("cp_" + r, { id: "cp_" + r, r: cp[r].r, timestamp: this.opt.flight.filtered[cp[r].r].timestamp }));
              features.push({ type: "Feature", id: "closing", properties: { id: "closing", stroke: "green", "stroke-width": 3, d: cp.in.distanceEarth(cp.out) }, geometry: { type: "LineString", coordinates: [[cp.in.x, cp.in.y], [cp.out.x, cp.out.y]], style: { stroke: "green", "stroke-width": 3 } } });
            }
            if (ep && ep.start && ep.finish) {
              for (let r of ["start", "finish"])
                features.push(ep[r].geojson("ep_" + r, { id: "ep_" + r, r: ep[r].r, timestamp: this.opt.flight.filtered[ep[r].r].timestamp }));
              features.push({ type: "Feature", id: "seg_in", properties: { id: "seg_in", stroke: "gold", "stroke-width": 3, d: ep.start.distanceEarth(tp[0]) }, geometry: { type: "LineString", coordinates: [[ep.start.x, ep.start.y], [tp[0].x, tp[0].y]], style: { stroke: "green", "stroke-width": 3 } } }), features.push({ type: "Feature", id: "seg_out", properties: { id: "seg_out", stroke: "gold", "stroke-width": 3, d: ep.finish.distanceEarth(tp[2]) }, geometry: { type: "LineString", coordinates: [[tp[2].x, tp[2].y], [ep.finish.x, ep.finish.y]], style: { stroke: "green", "stroke-width": 3 } } });
            }
          }
        } catch (e) {
        }
        for (let li = 0; li < this.opt.flight.ll.length; li++) {
          const l = this.opt.flight.ll[li];
          features.push(this.opt.flight.flightPoints[l.launch].geojson("launch" + li, { id: "launch" + li, r: l.launch, timestamp: this.opt.flight.filtered[l.launch].timestamp })), features.push(this.opt.flight.flightPoints[l.landing].geojson("land" + li, { id: "land" + li, r: l.landing, timestamp: this.opt.flight.filtered[l.landing].timestamp }));
        }
        if (!this.opt.config || !this.opt.config.noflight) {
          let flightData = [];
          for (let r of this.opt.flight.filtered)
            flightData.push([r.longitude, r.latitude]);
          features.push({ type: "Feature", id: "flight", properties: { id: "flight" }, geometry: { type: "LineString", coordinates: flightData } });
        }
        return { type: "FeatureCollection", properties: { name: "EPSG:3857", id: this.id, score: void 0 !== this.score ? this.score : void 0, bound: void 0 !== this.currentUpperBound ? this.currentUpperBound : this.bound, optimal: this.optimal, processedTime: this.time / 1e3, processedSolutions: this.processed, type: this.opt.scoring.name, code: this.opt.scoring.code }, features };
      }
      toString() {
        let s = `${this.opt.scoring.name}`;
        if (this.score && (s += ` ${this.score} points`), this.scoreInfo && (s += ` ${this.scoreInfo.distance.toFixed(2)}km`), s += ` ( <${this.bound.toFixed(2)} )`, this.opt.config && this.opt.config.debug) {
          s += ` { id: ${this.id} `;
          for (let r of this.ranges)
            s += " " + r.toString();
          s += " } ";
        }
        return s;
      }
      trace(msg) {
        if (!this.opt.config.trace || !process.stdout)
          return;
        const trace = this.opt.config.trace.split(",").map((str) => parseInt(str, 10));
        if (trace[0] < 0) {
          if (this.id % trace[1] != 0)
            return;
        } else if (this.ranges.some((range, i) => !range.contains(trace[i])))
          return;
        let r = `${msg || ""} solution tracing: ${this.id} ${this.opt.scoring.name} `;
        for (const range of this.ranges)
          r += range + " ";
        this.bound && (r += `bound: ${this.bound} `), this.score && (r += `score: ${this.score} `), process.stdout.write("\n" + r + "\n"), this.opt.config.env.fs.writeFileSync(`debug-${this.id}.json`, JSON.stringify(this.geojson({ debug: true })));
      }
    };
    __name(Solution2, "Solution");
    var FlatQueue = class {
      constructor() {
        this.ids = [], this.values = [], this.length = 0;
      }
      clear() {
        this.length = 0;
      }
      push(id2, value) {
        let pos = this.length++;
        for (; pos > 0; ) {
          const parent = pos - 1 >> 1, parentValue = this.values[parent];
          if (value >= parentValue)
            break;
          this.ids[pos] = this.ids[parent], this.values[pos] = parentValue, pos = parent;
        }
        this.ids[pos] = id2, this.values[pos] = value;
      }
      pop() {
        if (0 === this.length)
          return;
        const top = this.ids[0];
        if (this.length--, this.length > 0) {
          const id2 = this.ids[0] = this.ids[this.length], value = this.values[0] = this.values[this.length], halfLength = this.length >> 1;
          let pos = 0;
          for (; pos < halfLength; ) {
            let left = 1 + (pos << 1);
            const right = left + 1;
            let bestIndex = this.ids[left], bestValue = this.values[left];
            const rightValue = this.values[right];
            if (right < this.length && rightValue < bestValue && (left = right, bestIndex = this.ids[right], bestValue = rightValue), bestValue >= value)
              break;
            this.ids[pos] = bestIndex, this.values[pos] = bestValue, pos = left;
          }
          this.ids[pos] = id2, this.values[pos] = value;
        }
        return top;
      }
      peek() {
        if (0 !== this.length)
          return this.ids[0];
      }
      peekValue() {
        if (0 !== this.length)
          return this.values[0];
      }
      shrink() {
        this.ids.length = this.values.length = this.length;
      }
    };
    __name(FlatQueue, "FlatQueue");
    var ARRAY_TYPES = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
    var Flatbush = class {
      static from(data) {
        if (!(data instanceof ArrayBuffer))
          throw new Error("Data must be an instance of ArrayBuffer.");
        const [magic, versionAndType] = new Uint8Array(data, 0, 2);
        if (251 !== magic)
          throw new Error("Data does not appear to be in a Flatbush format.");
        if (versionAndType >> 4 != 3)
          throw new Error(`Got v${versionAndType >> 4} data when expected v3.`);
        const [nodeSize] = new Uint16Array(data, 2, 1), [numItems] = new Uint32Array(data, 4, 1);
        return new Flatbush(numItems, nodeSize, ARRAY_TYPES[15 & versionAndType], data);
      }
      constructor(numItems, nodeSize = 16, ArrayType = Float64Array, data) {
        if (void 0 === numItems)
          throw new Error("Missing required argument: numItems.");
        if (isNaN(numItems) || numItems <= 0)
          throw new Error(`Unpexpected numItems value: ${numItems}.`);
        this.numItems = +numItems, this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);
        let n = numItems, numNodes = n;
        this._levelBounds = [4 * n];
        do {
          n = Math.ceil(n / this.nodeSize), numNodes += n, this._levelBounds.push(4 * numNodes);
        } while (1 !== n);
        this.ArrayType = ArrayType || Float64Array, this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;
        const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType), nodesByteSize = 4 * numNodes * this.ArrayType.BYTES_PER_ELEMENT;
        if (arrayTypeIndex < 0)
          throw new Error(`Unexpected typed array class: ${ArrayType}.`);
        data && data instanceof ArrayBuffer ? (this.data = data, this._boxes = new this.ArrayType(this.data, 8, 4 * numNodes), this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes), this._pos = 4 * numNodes, this.minX = this._boxes[this._pos - 4], this.minY = this._boxes[this._pos - 3], this.maxX = this._boxes[this._pos - 2], this.maxY = this._boxes[this._pos - 1]) : (this.data = new ArrayBuffer(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT), this._boxes = new this.ArrayType(this.data, 8, 4 * numNodes), this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes), this._pos = 0, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, new Uint8Array(this.data, 0, 2).set([251, 48 + arrayTypeIndex]), new Uint16Array(this.data, 2, 1)[0] = nodeSize, new Uint32Array(this.data, 4, 1)[0] = numItems), this._queue = new FlatQueue();
      }
      add(minX, minY, maxX, maxY) {
        const index = this._pos >> 2;
        return this._indices[index] = index, this._boxes[this._pos++] = minX, this._boxes[this._pos++] = minY, this._boxes[this._pos++] = maxX, this._boxes[this._pos++] = maxY, minX < this.minX && (this.minX = minX), minY < this.minY && (this.minY = minY), maxX > this.maxX && (this.maxX = maxX), maxY > this.maxY && (this.maxY = maxY), index;
      }
      finish() {
        if (this._pos >> 2 !== this.numItems)
          throw new Error(`Added ${this._pos >> 2} items when expected ${this.numItems}.`);
        if (this.numItems <= this.nodeSize)
          return this._boxes[this._pos++] = this.minX, this._boxes[this._pos++] = this.minY, this._boxes[this._pos++] = this.maxX, void (this._boxes[this._pos++] = this.maxY);
        const width = this.maxX - this.minX || 1, height = this.maxY - this.minY || 1, hilbertValues = new Uint32Array(this.numItems);
        for (let i = 0; i < this.numItems; i++) {
          let pos = 4 * i;
          const minX = this._boxes[pos++], minY = this._boxes[pos++], maxX = this._boxes[pos++], maxY = this._boxes[pos++], x = Math.floor(65535 * ((minX + maxX) / 2 - this.minX) / width), y = Math.floor(65535 * ((minY + maxY) / 2 - this.minY) / height);
          hilbertValues[i] = hilbert(x, y);
        }
        sort(hilbertValues, this._boxes, this._indices, 0, this.numItems - 1, this.nodeSize);
        for (let i = 0, pos = 0; i < this._levelBounds.length - 1; i++) {
          const end = this._levelBounds[i];
          for (; pos < end; ) {
            const nodeIndex = pos;
            let nodeMinX = 1 / 0, nodeMinY = 1 / 0, nodeMaxX = -1 / 0, nodeMaxY = -1 / 0;
            for (let i2 = 0; i2 < this.nodeSize && pos < end; i2++)
              nodeMinX = Math.min(nodeMinX, this._boxes[pos++]), nodeMinY = Math.min(nodeMinY, this._boxes[pos++]), nodeMaxX = Math.max(nodeMaxX, this._boxes[pos++]), nodeMaxY = Math.max(nodeMaxY, this._boxes[pos++]);
            this._indices[this._pos >> 2] = nodeIndex, this._boxes[this._pos++] = nodeMinX, this._boxes[this._pos++] = nodeMinY, this._boxes[this._pos++] = nodeMaxX, this._boxes[this._pos++] = nodeMaxY;
          }
        }
      }
      search(minX, minY, maxX, maxY, filterFn) {
        if (this._pos !== this._boxes.length)
          throw new Error("Data not yet indexed - call index.finish().");
        let nodeIndex = this._boxes.length - 4;
        const queue = [], results = [];
        for (; void 0 !== nodeIndex; ) {
          const end = Math.min(nodeIndex + 4 * this.nodeSize, upperBound(nodeIndex, this._levelBounds));
          for (let pos = nodeIndex; pos < end; pos += 4) {
            if (maxX < this._boxes[pos])
              continue;
            if (maxY < this._boxes[pos + 1])
              continue;
            if (minX > this._boxes[pos + 2])
              continue;
            if (minY > this._boxes[pos + 3])
              continue;
            const index = 0 | this._indices[pos >> 2];
            nodeIndex < 4 * this.numItems ? (void 0 === filterFn || filterFn(index)) && results.push(index) : queue.push(index);
          }
          nodeIndex = queue.pop();
        }
        return results;
      }
      neighbors(x, y, maxResults = 1 / 0, maxDistance = 1 / 0, filterFn) {
        if (this._pos !== this._boxes.length)
          throw new Error("Data not yet indexed - call index.finish().");
        let nodeIndex = this._boxes.length - 4;
        const q = this._queue, results = [], maxDistSquared = maxDistance * maxDistance;
        for (; void 0 !== nodeIndex; ) {
          const end = Math.min(nodeIndex + 4 * this.nodeSize, upperBound(nodeIndex, this._levelBounds));
          for (let pos = nodeIndex; pos < end; pos += 4) {
            const index = 0 | this._indices[pos >> 2], dx = axisDist(x, this._boxes[pos], this._boxes[pos + 2]), dy = axisDist(y, this._boxes[pos + 1], this._boxes[pos + 3]), dist = dx * dx + dy * dy;
            nodeIndex < 4 * this.numItems ? (void 0 === filterFn || filterFn(index)) && q.push(1 + (index << 1), dist) : q.push(index << 1, dist);
          }
          for (; q.length && 1 & q.peek(); ) {
            if (q.peekValue() > maxDistSquared)
              return q.clear(), results;
            if (results.push(q.pop() >> 1), results.length === maxResults)
              return q.clear(), results;
          }
          nodeIndex = q.pop() >> 1;
        }
        return q.clear(), results;
      }
    };
    __name(Flatbush, "Flatbush");
    function axisDist(k, min, max) {
      return k < min ? min - k : k <= max ? 0 : k - max;
    }
    __name(axisDist, "axisDist");
    function upperBound(value, arr) {
      let i = 0, j = arr.length - 1;
      for (; i < j; ) {
        const m = i + j >> 1;
        arr[m] > value ? j = m : i = m + 1;
      }
      return arr[i];
    }
    __name(upperBound, "upperBound");
    function sort(values, boxes, indices, left, right, nodeSize) {
      if (Math.floor(left / nodeSize) >= Math.floor(right / nodeSize))
        return;
      const pivot = values[left + right >> 1];
      let i = left - 1, j = right + 1;
      for (; ; ) {
        do {
          i++;
        } while (values[i] < pivot);
        do {
          j--;
        } while (values[j] > pivot);
        if (i >= j)
          break;
        swap$1(values, boxes, indices, i, j);
      }
      sort(values, boxes, indices, left, j, nodeSize), sort(values, boxes, indices, j + 1, right, nodeSize);
    }
    __name(sort, "sort");
    function swap$1(values, boxes, indices, i, j) {
      const temp = values[i];
      values[i] = values[j], values[j] = temp;
      const k = 4 * i, m = 4 * j, a = boxes[k], b = boxes[k + 1], c = boxes[k + 2], d = boxes[k + 3];
      boxes[k] = boxes[m], boxes[k + 1] = boxes[m + 1], boxes[k + 2] = boxes[m + 2], boxes[k + 3] = boxes[m + 3], boxes[m] = a, boxes[m + 1] = b, boxes[m + 2] = c, boxes[m + 3] = d;
      const e = indices[i];
      indices[i] = indices[j], indices[j] = e;
    }
    __name(swap$1, "swap$1");
    function hilbert(x, y) {
      let a = x ^ y, b = 65535 ^ a, c = 65535 ^ (x | y), d = x & (65535 ^ y), A = a | b >> 1, B = a >> 1 ^ a, C = c >> 1 ^ b & d >> 1 ^ c, D = a & c >> 1 ^ d >> 1 ^ d;
      a = A, b = B, c = C, d = D, A = a & a >> 2 ^ b & b >> 2, B = a & b >> 2 ^ b & (a ^ b) >> 2, C ^= a & c >> 2 ^ b & d >> 2, D ^= b & c >> 2 ^ (a ^ b) & d >> 2, a = A, b = B, c = C, d = D, A = a & a >> 4 ^ b & b >> 4, B = a & b >> 4 ^ b & (a ^ b) >> 4, C ^= a & c >> 4 ^ b & d >> 4, D ^= b & c >> 4 ^ (a ^ b) & d >> 4, a = A, b = B, c = C, d = D, C ^= a & c >> 8 ^ b & d >> 8, D ^= b & c >> 8 ^ (a ^ b) & d >> 8, a = C ^ C >> 1, b = D ^ D >> 1;
      let i0 = x ^ y, i1 = b | 65535 ^ (i0 | a);
      return i0 = 16711935 & (i0 | i0 << 8), i0 = 252645135 & (i0 | i0 << 4), i0 = 858993459 & (i0 | i0 << 2), i0 = 1431655765 & (i0 | i0 << 1), i1 = 16711935 & (i1 | i1 << 8), i1 = 252645135 & (i1 | i1 << 4), i1 = 858993459 & (i1 | i1 << 2), i1 = 1431655765 & (i1 | i1 << 1), (i1 << 1 | i0) >>> 0;
    }
    __name(hilbert, "hilbert");
    var WeakMap$1 = weakMap;
    var Map$1 = _map.exports;
    var ChangeDescriptor = changeDescriptor;
    var ObjectChangeDescriptor = ChangeDescriptor.ObjectChangeDescriptor;
    var ChangeListenersRecord = ChangeDescriptor.ChangeListenersRecord;
    var ListenerGhost = ChangeDescriptor.ListenerGhost;
    var mapChanges = MapChanges$1;
    function MapChanges$1() {
      throw new Error("Can't construct. MapChanges is a mixin.");
    }
    __name(MapChanges$1, "MapChanges$1");
    var mapChangeDescriptors = new WeakMap$1();
    function MapChangeDescriptor(name) {
      this.name = name, this.isActive = false, this._willChangeListeners = null, this._changeListeners = null;
    }
    __name(MapChangeDescriptor, "MapChangeDescriptor");
    MapChangeDescriptor.prototype = new ObjectChangeDescriptor(), MapChangeDescriptor.prototype.constructor = MapChangeDescriptor, MapChangeDescriptor.prototype.changeListenersRecordConstructor = MapChangeListenersRecord, MapChangeDescriptor.prototype.willChangeListenersRecordConstructor = MapWillChangeListenersRecord;
    var MapChangeListenersSpecificHandlerMethodName = new Map$1();
    function MapChangeListenersRecord(name) {
      var specificHandlerMethodName = MapChangeListenersSpecificHandlerMethodName.get(name);
      return specificHandlerMethodName || (specificHandlerMethodName = "handle", specificHandlerMethodName += name.slice(0, 1).toUpperCase(), specificHandlerMethodName += name.slice(1), specificHandlerMethodName += "MapChange", MapChangeListenersSpecificHandlerMethodName.set(name, specificHandlerMethodName)), this.specificHandlerMethodName = specificHandlerMethodName, this;
    }
    __name(MapChangeListenersRecord, "MapChangeListenersRecord");
    MapChangeListenersRecord.prototype = new ChangeListenersRecord(), MapChangeListenersRecord.prototype.constructor = MapChangeListenersRecord, MapChangeListenersRecord.prototype.genericHandlerMethodName = "handleMapChange";
    var MapWillChangeListenersSpecificHandlerMethodName = new Map$1();
    function MapWillChangeListenersRecord(name) {
      var specificHandlerMethodName = MapWillChangeListenersSpecificHandlerMethodName.get(name);
      return specificHandlerMethodName || (specificHandlerMethodName = "handle", specificHandlerMethodName += name.slice(0, 1).toUpperCase(), specificHandlerMethodName += name.slice(1), specificHandlerMethodName += "MapWillChange", MapWillChangeListenersSpecificHandlerMethodName.set(name, specificHandlerMethodName)), this.specificHandlerMethodName = specificHandlerMethodName, this;
    }
    __name(MapWillChangeListenersRecord, "MapWillChangeListenersRecord");
    MapWillChangeListenersRecord.prototype = new ChangeListenersRecord(), MapWillChangeListenersRecord.prototype.constructor = MapWillChangeListenersRecord, MapWillChangeListenersRecord.prototype.genericHandlerMethodName = "handleMapWillChange", MapChanges$1.prototype.getAllMapChangeDescriptors = function() {
      return mapChangeDescriptors.has(this) || mapChangeDescriptors.set(this, new Map$1()), mapChangeDescriptors.get(this);
    }, MapChanges$1.prototype.getMapChangeDescriptor = function(token) {
      var tokenChangeDescriptors = this.getAllMapChangeDescriptors();
      return token = token || "", tokenChangeDescriptors.has(token) || tokenChangeDescriptors.set(token, new MapChangeDescriptor(token)), tokenChangeDescriptors.get(token);
    };
    var ObjectsDispatchesMapChanges = new WeakMap$1();
    var dispatchesChangesPropertyDescriptor = { get: function() {
      return ObjectsDispatchesMapChanges.get(this);
    }, set: function(value) {
      return ObjectsDispatchesMapChanges.set(this, value);
    }, configurable: true, enumerable: false };
    MapChanges$1.prototype.addMapChangeListener = function(listener, token, beforeChange) {
      !this.isObservable && this.makeObservable && this.makeObservable();
      var listeners, descriptor = this.getMapChangeDescriptor(token);
      (listeners = beforeChange ? descriptor.willChangeListeners : descriptor.changeListeners)._current ? Array.isArray(listeners._current) ? listeners._current.push(listener) : listeners._current = [listeners._current, listener] : listeners._current = listener, void 0 === Object.getOwnPropertyDescriptor(this.__proto__ || Object.getPrototypeOf(this), "dispatchesMapChanges") && Object.defineProperty(this.__proto__ || Object.getPrototypeOf(this), "dispatchesMapChanges", dispatchesChangesPropertyDescriptor), this.dispatchesMapChanges = true;
      var self2 = this;
      return function() {
        self2 && (self2.removeMapChangeListener(listener, token, beforeChange), self2 = null);
      };
    }, MapChanges$1.prototype.removeMapChangeListener = function(listener, token, beforeChange) {
      var listeners, descriptor = this.getMapChangeDescriptor(token);
      if ((listeners = beforeChange ? descriptor.willChangeListeners : descriptor.changeListeners)._current)
        if (listeners._current === listener)
          listeners._current = null;
        else {
          var index = listeners._current.lastIndexOf(listener);
          if (-1 === index)
            throw new Error("Can't remove map change listener: does not exist: token " + JSON.stringify(token));
          descriptor.isActive ? (listeners.ghostCount = listeners.ghostCount + 1, listeners._current[index] = ListenerGhost) : listeners._current.spliceOne(index);
        }
    }, MapChanges$1.prototype.dispatchMapChange = function(key, value, beforeChange) {
      var descriptors = this.getAllMapChangeDescriptors(), Ghost = ListenerGhost;
      descriptors.forEach(function(descriptor, token) {
        if (!descriptor.isActive) {
          var listeners = beforeChange ? descriptor.willChangeListeners : descriptor.changeListeners;
          if (listeners && listeners._current) {
            var tokenName = listeners.specificHandlerMethodName;
            if (Array.isArray(listeners._current)) {
              if (listeners._current.length) {
                var i, countI, listener, currentListeners = listeners.removeCurrentGostListenersIfNeeded();
                descriptor.isActive = true;
                try {
                  for (i = 0, countI = currentListeners.length; i < countI; i++)
                    if ((listener = currentListeners[i]) !== Ghost)
                      if (listener[tokenName])
                        listener[tokenName](value, key, this);
                      else {
                        if (!listener.call)
                          throw new Error("Handler " + listener + " has no method " + tokenName + " and is not callable");
                        listener.call(listener, value, key, this);
                      }
                } finally {
                  descriptor.isActive = false;
                }
              }
            } else {
              descriptor.isActive = true;
              try {
                if ((listener = listeners._current)[tokenName])
                  listener[tokenName](value, key, this);
                else {
                  if (!listener.call)
                    throw new Error("Handler " + listener + " has no method " + tokenName + " and is not callable");
                  listener.call(listener, value, key, this);
                }
              } finally {
                descriptor.isActive = false;
              }
            }
          }
        }
      }, this);
    }, MapChanges$1.prototype.addBeforeMapChangeListener = function(listener, token) {
      return this.addMapChangeListener(listener, token, true);
    }, MapChanges$1.prototype.removeBeforeMapChangeListener = function(listener, token) {
      return this.removeMapChangeListener(listener, token, true);
    }, MapChanges$1.prototype.dispatchBeforeMapChange = function(key, value) {
      return this.dispatchMapChange(key, value, true);
    };
    var Map2 = _map.exports;
    var PropertyChanges = propertyChanges;
    var MapChanges = mapChanges;
    var map = Map2;
    function quickselect(arr, k, left, right, compare) {
      quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
    }
    __name(quickselect, "quickselect");
    function quickselectStep(arr, k, left, right, compare) {
      for (; right > left; ) {
        if (right - left > 600) {
          var n = right - left + 1, m = k - left + 1, z = Math.log(n), s = 0.5 * Math.exp(2 * z / 3), sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
          quickselectStep(arr, k, Math.max(left, Math.floor(k - m * s / n + sd)), Math.min(right, Math.floor(k + (n - m) * s / n + sd)), compare);
        }
        var t = arr[k], i = left, j = right;
        for (swap(arr, left, k), compare(arr[right], t) > 0 && swap(arr, left, right); i < j; ) {
          for (swap(arr, i, j), i++, j--; compare(arr[i], t) < 0; )
            i++;
          for (; compare(arr[j], t) > 0; )
            j--;
        }
        0 === compare(arr[left], t) ? swap(arr, left, j) : swap(arr, ++j, right), j <= k && (left = j + 1), k <= j && (right = j - 1);
      }
    }
    __name(quickselectStep, "quickselectStep");
    function swap(arr, i, j) {
      var tmp = arr[i];
      arr[i] = arr[j], arr[j] = tmp;
    }
    __name(swap, "swap");
    function defaultCompare(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    __name(defaultCompare, "defaultCompare");
    void 0 === commonjsGlobal.Map || "function" != typeof commonjsGlobal.Set.prototype.values ? (Object.addEach(Map2.prototype, PropertyChanges.prototype), Object.addEach(Map2.prototype, MapChanges.prototype)) : (Object.defineEach(Map2.prototype, PropertyChanges.prototype, false, true, false, true), Object.defineEach(Map2.prototype, MapChanges.prototype, false, true, false, true));
    var RBush = class {
      constructor(maxEntries = 9) {
        this._maxEntries = Math.max(4, maxEntries), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
      }
      all() {
        return this._all(this.data, []);
      }
      search(bbox) {
        let node = this.data;
        const result = [];
        if (!intersects(bbox, node))
          return result;
        const toBBox = this.toBBox, nodesToSearch = [];
        for (; node; ) {
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i], childBBox = node.leaf ? toBBox(child) : child;
            intersects(bbox, childBBox) && (node.leaf ? result.push(child) : contains(bbox, childBBox) ? this._all(child, result) : nodesToSearch.push(child));
          }
          node = nodesToSearch.pop();
        }
        return result;
      }
      collides(bbox) {
        let node = this.data;
        if (!intersects(bbox, node))
          return false;
        const nodesToSearch = [];
        for (; node; ) {
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i], childBBox = node.leaf ? this.toBBox(child) : child;
            if (intersects(bbox, childBBox)) {
              if (node.leaf || contains(bbox, childBBox))
                return true;
              nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return false;
      }
      load(data) {
        if (!data || !data.length)
          return this;
        if (data.length < this._minEntries) {
          for (let i = 0; i < data.length; i++)
            this.insert(data[i]);
          return this;
        }
        let node = this._build(data.slice(), 0, data.length - 1, 0);
        if (this.data.children.length)
          if (this.data.height === node.height)
            this._splitRoot(this.data, node);
          else {
            if (this.data.height < node.height) {
              const tmpNode = this.data;
              this.data = node, node = tmpNode;
            }
            this._insert(node, this.data.height - node.height - 1, true);
          }
        else
          this.data = node;
        return this;
      }
      insert(item) {
        return item && this._insert(item, this.data.height - 1), this;
      }
      clear() {
        return this.data = createNode([]), this;
      }
      remove(item, equalsFn) {
        if (!item)
          return this;
        let node = this.data;
        const bbox = this.toBBox(item), path = [], indexes = [];
        let i, parent, goingUp;
        for (; node || path.length; ) {
          if (node || (node = path.pop(), parent = path[path.length - 1], i = indexes.pop(), goingUp = true), node.leaf) {
            const index = findItem(item, node.children, equalsFn);
            if (-1 !== index)
              return node.children.splice(index, 1), path.push(node), this._condense(path), this;
          }
          goingUp || node.leaf || !contains(node, bbox) ? parent ? (i++, node = parent.children[i], goingUp = false) : node = null : (path.push(node), indexes.push(i), i = 0, parent = node, node = node.children[0]);
        }
        return this;
      }
      toBBox(item) {
        return item;
      }
      compareMinX(a, b) {
        return a.minX - b.minX;
      }
      compareMinY(a, b) {
        return a.minY - b.minY;
      }
      toJSON() {
        return this.data;
      }
      fromJSON(data) {
        return this.data = data, this;
      }
      _all(node, result) {
        const nodesToSearch = [];
        for (; node; )
          node.leaf ? result.push(...node.children) : nodesToSearch.push(...node.children), node = nodesToSearch.pop();
        return result;
      }
      _build(items, left, right, height) {
        const N = right - left + 1;
        let node, M = this._maxEntries;
        if (N <= M)
          return node = createNode(items.slice(left, right + 1)), calcBBox(node, this.toBBox), node;
        height || (height = Math.ceil(Math.log(N) / Math.log(M)), M = Math.ceil(N / Math.pow(M, height - 1))), node = createNode([]), node.leaf = false, node.height = height;
        const N2 = Math.ceil(N / M), N1 = N2 * Math.ceil(Math.sqrt(M));
        multiSelect(items, left, right, N1, this.compareMinX);
        for (let i = left; i <= right; i += N1) {
          const right2 = Math.min(i + N1 - 1, right);
          multiSelect(items, i, right2, N2, this.compareMinY);
          for (let j = i; j <= right2; j += N2) {
            const right3 = Math.min(j + N2 - 1, right2);
            node.children.push(this._build(items, j, right3, height - 1));
          }
        }
        return calcBBox(node, this.toBBox), node;
      }
      _chooseSubtree(bbox, node, level, path) {
        for (; path.push(node), !node.leaf && path.length - 1 !== level; ) {
          let targetNode, minArea = 1 / 0, minEnlargement = 1 / 0;
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i], area = bboxArea(child), enlargement = (a = bbox, b = child, (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY)) - area);
            enlargement < minEnlargement ? (minEnlargement = enlargement, minArea = area < minArea ? area : minArea, targetNode = child) : enlargement === minEnlargement && area < minArea && (minArea = area, targetNode = child);
          }
          node = targetNode || node.children[0];
        }
        var a, b;
        return node;
      }
      _insert(item, level, isNode) {
        const bbox = isNode ? item : this.toBBox(item), insertPath = [], node = this._chooseSubtree(bbox, this.data, level, insertPath);
        for (node.children.push(item), extend(node, bbox); level >= 0 && insertPath[level].children.length > this._maxEntries; )
          this._split(insertPath, level), level--;
        this._adjustParentBBoxes(bbox, insertPath, level);
      }
      _split(insertPath, level) {
        const node = insertPath[level], M = node.children.length, m = this._minEntries;
        this._chooseSplitAxis(node, m, M);
        const splitIndex = this._chooseSplitIndex(node, m, M), newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height, newNode.leaf = node.leaf, calcBBox(node, this.toBBox), calcBBox(newNode, this.toBBox), level ? insertPath[level - 1].children.push(newNode) : this._splitRoot(node, newNode);
      }
      _splitRoot(node, newNode) {
        this.data = createNode([node, newNode]), this.data.height = node.height + 1, this.data.leaf = false, calcBBox(this.data, this.toBBox);
      }
      _chooseSplitIndex(node, m, M) {
        let index, minOverlap = 1 / 0, minArea = 1 / 0;
        for (let i = m; i <= M - m; i++) {
          const bbox1 = distBBox(node, 0, i, this.toBBox), bbox2 = distBBox(node, i, M, this.toBBox), overlap = intersectionArea(bbox1, bbox2), area = bboxArea(bbox1) + bboxArea(bbox2);
          overlap < minOverlap ? (minOverlap = overlap, index = i, minArea = area < minArea ? area : minArea) : overlap === minOverlap && area < minArea && (minArea = area, index = i);
        }
        return index || M - m;
      }
      _chooseSplitAxis(node, m, M) {
        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
        this._allDistMargin(node, m, M, compareMinX) < this._allDistMargin(node, m, M, compareMinY) && node.children.sort(compareMinX);
      }
      _allDistMargin(node, m, M, compare) {
        node.children.sort(compare);
        const toBBox = this.toBBox, leftBBox = distBBox(node, 0, m, toBBox), rightBBox = distBBox(node, M - m, M, toBBox);
        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
        for (let i = m; i < M - m; i++) {
          const child = node.children[i];
          extend(leftBBox, node.leaf ? toBBox(child) : child), margin += bboxMargin(leftBBox);
        }
        for (let i = M - m - 1; i >= m; i--) {
          const child = node.children[i];
          extend(rightBBox, node.leaf ? toBBox(child) : child), margin += bboxMargin(rightBBox);
        }
        return margin;
      }
      _adjustParentBBoxes(bbox, path, level) {
        for (let i = level; i >= 0; i--)
          extend(path[i], bbox);
      }
      _condense(path) {
        for (let siblings, i = path.length - 1; i >= 0; i--)
          0 === path[i].children.length ? i > 0 ? (siblings = path[i - 1].children, siblings.splice(siblings.indexOf(path[i]), 1)) : this.clear() : calcBBox(path[i], this.toBBox);
      }
    };
    __name(RBush, "RBush");
    function findItem(item, items, equalsFn) {
      if (!equalsFn)
        return items.indexOf(item);
      for (let i = 0; i < items.length; i++)
        if (equalsFn(item, items[i]))
          return i;
      return -1;
    }
    __name(findItem, "findItem");
    function calcBBox(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
    }
    __name(calcBBox, "calcBBox");
    function distBBox(node, k, p, toBBox, destNode) {
      destNode || (destNode = createNode(null)), destNode.minX = 1 / 0, destNode.minY = 1 / 0, destNode.maxX = -1 / 0, destNode.maxY = -1 / 0;
      for (let i = k; i < p; i++) {
        const child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
      }
      return destNode;
    }
    __name(distBBox, "distBBox");
    function extend(a, b) {
      return a.minX = Math.min(a.minX, b.minX), a.minY = Math.min(a.minY, b.minY), a.maxX = Math.max(a.maxX, b.maxX), a.maxY = Math.max(a.maxY, b.maxY), a;
    }
    __name(extend, "extend");
    function compareNodeMinX(a, b) {
      return a.minX - b.minX;
    }
    __name(compareNodeMinX, "compareNodeMinX");
    function compareNodeMinY(a, b) {
      return a.minY - b.minY;
    }
    __name(compareNodeMinY, "compareNodeMinY");
    function bboxArea(a) {
      return (a.maxX - a.minX) * (a.maxY - a.minY);
    }
    __name(bboxArea, "bboxArea");
    function bboxMargin(a) {
      return a.maxX - a.minX + (a.maxY - a.minY);
    }
    __name(bboxMargin, "bboxMargin");
    function intersectionArea(a, b) {
      const minX = Math.max(a.minX, b.minX), minY = Math.max(a.minY, b.minY), maxX = Math.min(a.maxX, b.maxX), maxY = Math.min(a.maxY, b.maxY);
      return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
    }
    __name(intersectionArea, "intersectionArea");
    function contains(a, b) {
      return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
    }
    __name(contains, "contains");
    function intersects(a, b) {
      return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
    }
    __name(intersects, "intersects");
    function createNode(children) {
      return { children, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
    }
    __name(createNode, "createNode");
    function multiSelect(arr, left, right, n, compare) {
      const stack = [left, right];
      for (; stack.length; ) {
        if ((right = stack.pop()) - (left = stack.pop()) <= n)
          continue;
        const mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare), stack.push(left, mid, mid, right);
      }
    }
    __name(multiSelect, "multiSelect");
    function minDistance2Rectangles(boxes) {
      const v0 = boxes[0].vertices(), v1 = boxes[1].vertices();
      let distanceMin = 1 / 0;
      for (let i of v0)
        for (let j of v1) {
          const distance = i.distanceEarth(j);
          distanceMin = Math.min(distanceMin, distance);
        }
      return distanceMin;
    }
    __name(minDistance2Rectangles, "minDistance2Rectangles");
    function maxDistance2Rectangles(boxes) {
      const v0 = boxes[0].vertices(), v1 = boxes[1].vertices();
      let distanceMax = 0;
      for (let i of v0)
        for (let j of v1) {
          const distance = i.distanceEarth(j);
          distanceMax = Math.max(distanceMax, distance);
        }
      return distanceMax;
    }
    __name(maxDistance2Rectangles, "maxDistance2Rectangles");
    function maxDistancePath(origin, path, pathStart) {
      let distanceMax = 0;
      for (let i of path[pathStart]) {
        const distance1 = void 0 !== origin ? i.distanceEarth(origin) : 0, distance2 = path.length > pathStart + 1 ? maxDistancePath(i, path, pathStart + 1) : 0;
        distanceMax = Math.max(distanceMax, distance1 + distance2);
      }
      return distanceMax;
    }
    __name(maxDistancePath, "maxDistancePath");
    function maxDistanceNRectangles(boxes) {
      let vertices = [], minx = 1 / 0, miny = 1 / 0, maxx = -1 / 0, maxy = -1 / 0, path = [];
      for (let r = 0; r < boxes.length; r++) {
        if (boxes[r] instanceof Box)
          vertices[r] = boxes[r].vertices(), minx = Math.min(minx, boxes[r].x1), miny = Math.min(miny, boxes[r].y1), maxx = Math.max(maxx, boxes[r].x2), maxy = Math.max(maxy, boxes[r].y2);
        else {
          if (!(boxes[r] instanceof Point))
            throw new TypeError("boxes must contain only Box or Point");
          vertices[r] = [boxes[r]], minx = Math.min(minx, boxes[r].x), miny = Math.min(miny, boxes[r].y), maxx = Math.max(maxx, boxes[r].x), maxy = Math.max(maxy, boxes[r].y);
        }
        path[r] = [];
      }
      for (let i = 1; i < boxes.length; i++) {
        boxes[i - 1].intersects(boxes[i]) && (boxes[i - 1].intersecting = true, boxes[i].intersecting = true);
      }
      for (let i = 0; i < boxes.length; i++)
        if (boxes[i].intersecting)
          path[i] = vertices[i];
        else {
          for (let v of vertices[i])
            v.x != minx && v.x != maxx || v.y != miny && v.y != maxy || path[i].push(v);
          if (0 == path[i].length)
            for (let v of vertices[i])
              v.x != minx && v.x != maxx && v.y != miny && v.y != maxy || path[i].push(v);
          0 == path[i].length && (path[i] = vertices[i]);
        }
      return maxDistancePath(void 0, path, 0);
    }
    __name(maxDistanceNRectangles, "maxDistanceNRectangles");
    function findFurthestPointInSegment(sega, segb, target, opt) {
      let points, pos, zSearch;
      if (target instanceof Box)
        points = target.vertices();
      else {
        if (!(target instanceof Point))
          throw new TypeError("target must be either Point or Box");
        points = [target];
      }
      if (sega === opt.launch)
        pos = 0, zSearch = +segb;
      else {
        if (segb !== opt.landing)
          throw new RangeError("this function supports seeking only from the launch or the landing point");
        pos = 1, zSearch = +sega;
      }
      let fpoint, distanceMax = -1 / 0;
      for (let v of points) {
        let fVpoint, precomputed, distanceVMax = -1 / 0;
        const precomputedAll = opt.flight.furthestPoints[pos].get(v.x + ":" + v.y);
        for (const p of precomputedAll || [])
          if (zSearch >= p.min && zSearch <= p.max) {
            precomputed = p;
            break;
          }
        if (precomputed) {
          if (!(sega <= precomputed.o.r && precomputed.o.r <= segb))
            throw new Error("furthestPoints cache inconsistency");
          distanceVMax = v.distanceEarth(precomputed.o), fVpoint = precomputed.o;
        }
        if (void 0 === fVpoint) {
          let intersecting = false, canCache = false;
          for (let p = sega; p <= segb; p++) {
            const f = opt.flight.flightPoints[p];
            if (target instanceof Box && target.intersects(f)) {
              intersecting = true;
              continue;
            }
            const d = v.distanceEarth(f);
            d > distanceVMax && (distanceVMax = d, fVpoint = f, canCache = true);
          }
          if (intersecting)
            for (let p of points) {
              const d = v.distanceEarth(p);
              d > distanceVMax && (distanceVMax = d, fVpoint = target, canCache = false);
            }
          if (canCache) {
            let zCache;
            sega === opt.launch ? zCache = { min: +fVpoint.r, max: +segb } : segb === opt.landing && (zCache = { min: +sega, max: +fVpoint.r });
            let c = precomputedAll;
            c || (c = [], opt.flight.furthestPoints[pos].set(v.x + ":" + v.y, c));
            const existing = c.filter((x) => x.o.r == fVpoint.r && !(zCache.max <= x.min || zCache.min >= x.max))[0];
            existing ? (existing.min = Math.min(zCache.min, existing.min), existing.max = Math.max(zCache.max, existing.max)) : c.push({ ...zCache, o: fVpoint });
          }
        }
        distanceVMax > distanceMax && (distanceMax = distanceVMax, fpoint = fVpoint);
      }
      return void 0 === fpoint && (fpoint = target), fpoint;
    }
    __name(findFurthestPointInSegment, "findFurthestPointInSegment");
    function isTriangleClosed(p1, p2, distance, opt) {
      const fastCandidates = opt.flight.closestPairs.search({ minX: opt.launch, minY: p2, maxX: p1, maxY: opt.landing });
      for (let f of fastCandidates)
        if (f.o.d <= opt.scoring.closingDistanceFree)
          return f.o;
      const min = function(p12, p22, opt2) {
        let precomputedAll = opt2.flight.closestPairs.search({ minX: p12, minY: p22, maxX: p12, maxY: p22 }), precomputed = precomputedAll.reduce((a, x) => !a || x.in > a.in ? x : a, void 0);
        if (precomputed = precomputedAll.reduce((a, x) => !a || x.out < a.out ? x : a, precomputed), void 0 !== precomputed)
          return precomputed.o;
        const rtree = new Flatbush(p12 + 1 - opt2.launch, 8), lc = Math.abs(Math.cos(radians(opt2.flight.flightPoints[p12].y)));
        for (let i = opt2.launch; i <= p12; i++) {
          const r = opt2.flight.flightPoints[i];
          rtree.add(r.x * lc, r.y, r.x * lc, r.y);
        }
        rtree.finish(), precomputedAll = opt2.flight.closestPairs.search({ minX: p12, minY: p22, maxX: p12, maxY: opt2.landing });
        const precomputedNext = precomputedAll.reduce((a, x) => !a || x.out < a.out ? x : a, void 0), lastUnknown = void 0 !== precomputedNext ? precomputedNext.maxY : opt2.landing;
        let min2 = { d: 1 / 0 };
        for (let i = p22; i <= lastUnknown; i++) {
          const pout = opt2.flight.flightPoints[i], n = rtree.neighbors(pout.x * lc, pout.y, 1)[0] + opt2.launch;
          if (void 0 !== n) {
            const pin = opt2.flight.flightPoints[n], d = opt2.scoring.rounding(pout.distanceEarth(pin));
            d < min2.d && (min2.d = d, min2.out = pout, min2.in = pin);
          }
        }
        if (void 0 !== precomputedNext) {
          const pout = precomputedNext.o.out, pin = precomputedNext.o.in, d = opt2.scoring.rounding(pout.distanceEarth(pin));
          d < min2.d && (console.log("This flight is very interesting because it has multiple possible closings, please consider submitting it for the unit testing of this program by opening an issue on https://github.com/mmomtchev/igc-xc-score"), min2.d = d, min2.out = pout, min2.in = pin);
        }
        return opt2.flight.closestPairs.insert({ minX: min2.in.r, minY: p22, maxX: p12, maxY: min2.out.r, o: min2 }), min2;
      }(p1, p2, opt);
      return min.d <= opt.scoring.closingDistance(distance, opt) && min;
    }
    __name(isTriangleClosed, "isTriangleClosed");
    function isOutAndReturnClosed(range_a, range_b, distance, opt) {
      const min = function(range_a2, range_b2, opt2) {
        const rtree = new Flatbush(range_a2.end + 1 - range_a2.start), lc = Math.abs(Math.cos(radians(opt2.flight.flightPoints[range_a2.start].y)));
        for (let i = range_a2.start; i <= range_a2.end; i++) {
          const r = opt2.flight.flightPoints[i];
          rtree.add(r.x * lc, r.y, r.x * lc, r.y);
        }
        rtree.finish();
        let min2 = { d: 1 / 0 };
        for (let i = range_b2.start; i <= range_b2.end; i++) {
          const pout = opt2.flight.flightPoints[i], n = rtree.neighbors(pout.x * lc, pout.y, 1)[0] + range_a2.start;
          if (void 0 !== n) {
            const pin = opt2.flight.flightPoints[n], d = opt2.scoring.rounding(pout.distanceEarth(pin));
            d < min2.d && (min2.d = d, min2.out = pout, min2.in = pin);
          }
        }
        return min2;
      }(range_a, range_b, opt);
      return min.d <= opt.scoring.closingDistance(distance, opt) && min;
    }
    __name(isOutAndReturnClosed, "isOutAndReturnClosed");
    var definitionFlight_t = 60;
    var definitionFlight_x0 = 1.5;
    var definitionFlight_xt = 5;
    var definitionFlight_z0 = 0.05;
    var definitionFlight_zt = 0.9;
    var definitionGround_t = 20;
    var definitionGround_xmax = 2.5;
    var definitionGround_zmax = 0.1;
    function analyze(flight, config) {
      if (config.invalid ? flight.filtered = flight.fixes.slice(0) : flight.filtered = flight.fixes.filter((x) => x.valid).filter((x, i, a) => 0 == i || a[i - 1].timestamp !== x.timestamp), flight.filtered.length < 5)
        throw new Error(`Flight must contain at least 5 valid GPS fixes, ${flight.filtered.length} valid fixes found (out of ${flight.fixes.length})`);
      config.trim || config.detectLaunch || config.detectLanding ? (!function(fixes) {
        for (let i = 0; i < fixes.length; i++)
          if ((null == fixes[i].pressureAltitude || fixes[i].pressureAltitude < -1e3) && (fixes[i].pressureAltitude = fixes[i].gpsAltitude), null === fixes[i].pressureAltitude && (fixes[i].gpsAltitude = void 0), i > 0) {
            const deltaTimestamp = fixes[i].timestamp - fixes[i - 1].timestamp;
            deltaTimestamp > 0 ? (fixes[i].hspeed = 1e3 * new Point(fixes, i - 1).distanceEarth(new Point(fixes, i)) / deltaTimestamp * 1e3, fixes[i].vspeed = (fixes[i].pressureAltitude - fixes[i - 1].pressureAltitude) / deltaTimestamp * 1e3) : (fixes[i].hspeed = fixes[i - 1].hspeed, fixes[i].vspeed = fixes[i - 1].vspeed);
          } else
            fixes[i].hspeed = 0, fixes[i].vspeed = 0;
        for (let i = 0; i < fixes.length; i++) {
          const now = fixes[i].timestamp;
          let start, end;
          for (start = i; start > 0 && fixes[start].timestamp > now - Math.round(5e3); start--)
            ;
          for (end = i; end < fixes.length - 1 && fixes[end].timestamp < now + Math.round(5e3); end++)
            ;
          const maSegment = fixes.slice(start, end + 1);
          fixes[i].hma = maSegment.reduce((sum, x) => sum + x.hspeed, 0) / maSegment.length, fixes[i].vma = maSegment.reduce((sum, x) => sum + Math.abs(x.vspeed), 0) / maSegment.length;
        }
      }(flight.filtered), function(fixes) {
        let start;
        for (let i = 0; i < fixes.length - 1; i++)
          if (void 0 === start && fixes[i].hma > definitionFlight_xt && fixes[i].vma > definitionFlight_zt && (start = i), void 0 !== start)
            if (fixes[i].hma > definitionFlight_x0 && fixes[i].vma > definitionFlight_z0) {
              if (fixes[i].timestamp > fixes[start].timestamp + 1e3 * definitionFlight_t)
                for (let j = start; j <= i; j++)
                  fixes[i].stateFlight = true;
            } else
              start = void 0;
      }(flight.filtered), function(fixes) {
        let start;
        for (let i = 0; i < fixes.length - 1; i++)
          if (void 0 === start && fixes[i].hma < definitionGround_xmax && fixes[i].vma < definitionGround_zmax && (start = i), void 0 !== start)
            if (fixes[i].hma < definitionGround_xmax && fixes[i].vma < definitionGround_zmax) {
              if (fixes[i].timestamp > fixes[start].timestamp + 1e3 * definitionGround_t)
                for (let j = start; j <= i; j++)
                  fixes[i].stateGround = true;
            } else
              start = void 0;
      }(flight.filtered), flight.ll = function(fixes) {
        let ll = [];
        for (let i = 0; i < fixes.length - 1; i++)
          if (fixes[i].stateFlight) {
            let j;
            for (j = i; j > 0 && !fixes[j].stateGround; j--)
              ;
            const launch = j;
            for (j = i; j < fixes.length - 2 && !fixes[j].stateGround; j++)
              ;
            const landing = j;
            i = j, ll.push({ launch, landing });
          }
        return 0 == ll.length && ll.push({ launch: 0, landing: fixes.length - 1 }), ll;
      }(flight.filtered)) : flight.ll = [{ launch: 0, landing: flight.filtered.length - 1 }];
    }
    __name(analyze, "analyze");
    function closingPenalty(cd, opt) {
      return opt.scoring.rounding(cd > (opt.scoring.closingDistanceFree || 0) ? cd : 0);
    }
    __name(closingPenalty, "closingPenalty");
    function closingWithLimit(distance, opt) {
      return opt.scoring.rounding(Math.max(opt.scoring.closingDistanceFixed || 0, distance * (opt.scoring.closingDistanceRelative || 0)));
    }
    __name(closingWithLimit, "closingWithLimit");
    function finalRounding(v, opt) {
      return opt.scoring.finalRounding ? opt.scoring.finalRounding(v) : opt.scoring.rounding ? opt.scoring.rounding(v) : v;
    }
    __name(finalRounding, "finalRounding");
    function boundDistance3Points(ranges, boxes, opt) {
      const pin = findFurthestPointInSegment(opt.launch, ranges[0].start, boxes[0], opt), pout = findFurthestPointInSegment(ranges[2].end, opt.landing, boxes[2], opt), maxDistance = opt.scoring.rounding(maxDistanceNRectangles([pin, boxes[0], boxes[1], boxes[2], pout]));
      return maxDistance < (opt.scoring.minDistance || 0) ? 0 : finalRounding(maxDistance * opt.scoring.multiplier, opt);
    }
    __name(boundDistance3Points, "boundDistance3Points");
    function scoreDistance3Points(tp, opt) {
      let distance = 0;
      const pin = findFurthestPointInSegment(opt.launch, tp[0].r, tp[0], opt), pout = findFurthestPointInSegment(tp[2].r, opt.landing, tp[2], opt), all = [pin, tp[0], tp[1], tp[2], pout], legs = [{ name: "START : TP1" }, { name: "TP1 : TP2" }, { name: "TP2 : TP3" }, { name: "TP3 : FINISH" }];
      for (let i = 0; i < all.length - 1; i++)
        legs[i].d = opt.scoring.rounding(all[i].distanceEarth(all[i + 1])), distance += legs[i].d, legs[i].start = all[i], legs[i].finish = all[i + 1];
      distance = finalRounding(distance, opt);
      return { distance, score: distance >= (opt.scoring.minDistance || 0) ? finalRounding(distance * opt.scoring.multiplier, opt) : 0, tp, ep: { start: pin, finish: pout }, legs };
    }
    __name(scoreDistance3Points, "scoreDistance3Points");
    function maxFAIDistance(maxTriDistance, boxes, opt) {
      const minTriDistance = function(boxes2, distance_fn) {
        const v0 = boxes2[0].vertices(), v1 = boxes2[1].vertices(), v2 = boxes2[2].vertices();
        let distanceMin = 1 / 0;
        for (let i of v0)
          for (let j of v1)
            for (let k of v2) {
              const distance = distance_fn(i, j, k);
              distanceMin = Math.min(distanceMin, distance);
            }
        return distanceMin;
      }(boxes, (i, j, k) => opt.scoring.rounding(i.distanceEarth(j)) + opt.scoring.rounding(j.distanceEarth(k)) + opt.scoring.rounding(k.distanceEarth(i)));
      if (maxTriDistance < minTriDistance)
        return 0;
      const maxAB = opt.scoring.rounding(maxDistance2Rectangles([boxes[0], boxes[1]])), maxBC = opt.scoring.rounding(maxDistance2Rectangles([boxes[1], boxes[2]])), maxCA = opt.scoring.rounding(maxDistance2Rectangles([boxes[2], boxes[0]])), maxDistance = opt.scoring.rounding(Math.min(maxAB, maxBC, maxCA) / opt.scoring.minSide);
      return maxDistance < minTriDistance ? 0 : Math.min(maxDistance, maxTriDistance);
    }
    __name(maxFAIDistance, "maxFAIDistance");
    function boundTriangle(ranges, boxes, opt) {
      const maxTriDistance = function(boxes2, distance_fn) {
        const minx = Math.min(boxes2[0].x1, boxes2[1].x1, boxes2[2].x1), miny = Math.min(boxes2[0].y1, boxes2[1].y1, boxes2[2].y1), maxx = Math.max(boxes2[0].x2, boxes2[1].x2, boxes2[2].x2), maxy = Math.max(boxes2[0].y2, boxes2[1].y2, boxes2[2].y2);
        let intersecting = false;
        for (let i = 0; i < 3; i++)
          if (boxes2[i].intersects(boxes2[(i + 1) % 3])) {
            intersecting = true;
            break;
          }
        const path = [[], [], []];
        for (let i = 0; i < 3; i++) {
          const vertices = boxes2[i].vertices();
          for (let v of vertices)
            v.x != minx && v.x != maxx || v.y != miny && v.y != maxy || path[i].push(v);
          if (0 == path[i].length)
            for (let v of vertices)
              v.x != minx && v.x != maxx && v.y != miny && v.y != maxy || path[i].push(v);
          (0 == path[i].length || intersecting) && (path[i] = vertices);
        }
        let distanceMax = 0;
        for (let i of path[0])
          for (let j of path[1])
            for (let k of path[2]) {
              const distance = distance_fn(i, j, k);
              distanceMax = Math.max(distanceMax, distance);
            }
        return distanceMax;
      }(boxes, (i, j, k) => opt.scoring.rounding(i.distanceEarth(j)) + opt.scoring.rounding(j.distanceEarth(k)) + opt.scoring.rounding(k.distanceEarth(i)));
      if (maxTriDistance < (opt.scoring.minDistance || 0))
        return 0;
      let maxDistance = maxTriDistance;
      if (void 0 !== opt.scoring.minSide && (maxDistance = maxFAIDistance(maxDistance, boxes, opt)), void 0 !== opt.scoring.maxSide && (maxDistance = function(maxTriDistance2, boxes2, opt2) {
        const minAB = opt2.scoring.rounding(minDistance2Rectangles([boxes2[0], boxes2[1]])), minBC = opt2.scoring.rounding(minDistance2Rectangles([boxes2[1], boxes2[2]])), minCA = opt2.scoring.rounding(minDistance2Rectangles([boxes2[2], boxes2[0]]));
        return opt2.scoring.rounding(Math.max(minAB, minBC, minCA) / opt2.scoring.maxSide) > maxTriDistance2 ? 0 : maxTriDistance2;
      }(maxDistance, boxes, opt)), 0 === maxDistance)
        return 0;
      let cp = { d: 0 };
      return ranges[0].end < ranges[2].start ? (cp = isTriangleClosed(ranges[0].end, ranges[2].start, maxDistance, opt), cp ? finalRounding((maxDistance - closingPenalty(cp.d, opt)) * opt.scoring.multiplier, opt) : 0) : finalRounding(maxDistance * opt.scoring.multiplier, opt);
    }
    __name(boundTriangle, "boundTriangle");
    function scoreTriangle(tp, opt) {
      let distance = 0;
      const legs = [{ name: "TP1 : TP2" }, { name: "TP2 : TP3" }, { name: "TP3 : TP1" }];
      for (let i = 0; i < tp.length; i++)
        legs[i].d = opt.scoring.rounding(tp[i].distanceEarth(tp[(i + 1) % tp.length])), distance += legs[i].d, legs[i].start = tp[i], legs[i].finish = tp[(i + 1) % tp.length];
      if (distance = finalRounding(distance, opt), distance < (opt.scoring.minDistance || 0))
        return { score: 0 };
      if (void 0 !== opt.scoring.minSide) {
        const minSide = opt.scoring.minSide * distance;
        if (legs[0].d < minSide || legs[1].d < minSide || legs[2].d < minSide)
          return { score: 0 };
      }
      if (void 0 !== opt.scoring.maxSide) {
        const maxSide = opt.scoring.maxSide * distance;
        if (legs[0].d > maxSide || legs[1].d > maxSide || legs[2].d > maxSide)
          return { score: 0 };
      }
      let cp = isTriangleClosed(tp[0].r, tp[2].r, distance, opt);
      if (!cp)
        return { score: 0 };
      const penalty = closingPenalty(cp.d, opt);
      return { distance, score: finalRounding((distance - penalty) * opt.scoring.multiplier, opt), tp, cp, legs, penalty };
    }
    __name(scoreTriangle, "scoreTriangle");
    function boundOutAndReturn2(ranges, boxes, opt) {
      const maxDistance = 2 * opt.scoring.rounding(maxDistance2Rectangles(boxes));
      if (maxDistance < (opt.scoring.minDistance || 0))
        return 0;
      if (ranges[0].end < ranges[1].start) {
        const cp = isTriangleClosed(ranges[0].end, ranges[1].start, maxDistance, opt);
        return cp ? finalRounding((maxDistance - closingPenalty(cp.d, opt)) * opt.scoring.multiplier, opt) : 0;
      }
      return finalRounding(maxDistance * opt.scoring.multiplier, opt);
    }
    __name(boundOutAndReturn2, "boundOutAndReturn2");
    function scoreOutAndReturn2(tp, opt) {
      const leg = opt.scoring.rounding(tp[0].distanceEarth(tp[1])), distance = finalRounding(2 * leg, opt);
      if (distance < (opt.scoring.minDistance || 0))
        return { score: 0 };
      let cp = isTriangleClosed(tp[0].r, tp[1].r, distance, opt);
      if (!cp)
        return { score: 0 };
      const penalty = closingPenalty(cp.d, opt);
      return { distance, score: finalRounding((distance - penalty) * opt.scoring.multiplier, opt), tp, cp, legs: [{ name: "TP1 : TP2", start: tp[0], finish: tp[1], d: leg }, { name: "TP2 : TP1", start: tp[1], finish: tp[0], d: leg }], penalty };
    }
    __name(scoreOutAndReturn2, "scoreOutAndReturn2");
    function adjustFAICylinders(score, opt) {
      if (!score.tp || !score.legs || 0 == score.score)
        return;
      function moveAway(point, origin) {
        const d0 = point.distanceEarth(origin), t = (d0 + opt.scoring.cylinders) / d0, x = (1 - t) * origin.x + t * point.x, y = (1 - t) * origin.y + t * point.y;
        return new Point(x, y);
      }
      __name(moveAway, "moveAway");
      const newTP = [];
      for (const i in score.tp) {
        if (void 0 === score.tp[i].r)
          continue;
        let previous = +i - 1;
        previous = previous < 0 ? score.ep ? score.ep.start : score.tp[score.tp.length - 1] : score.tp[previous];
        let next = +i + 1;
        next = next >= score.tp.length ? score.ep ? score.ep.finish : score.tp[0] : score.tp[next];
        const centroid = new Point((previous.x + next.x) / 2, (previous.y + next.y) / 2);
        newTP[i] = moveAway(score.tp[i], centroid);
      }
      for (const i in score.tp)
        newTP[i] && (score.tp[i] = newTP[i]);
      switch (score.ep && score.ep.start && (score.ep.start = moveAway(score.ep.start, score.tp[0])), score.ep && score.ep.finish && (score.ep.finish = moveAway(score.ep.finish, score.tp[2])), opt.scoring.code) {
        case "tri":
        case "fai":
          score.distance = 0;
          for (let i = 0; i < score.legs.length; i++)
            score.legs[i].d = opt.scoring.rounding(score.tp[i].distanceEarth(score.tp[(i + 1) % score.tp.length])) - 2 * opt.scoring.cylinders, score.distance += score.legs[i].d;
          break;
        case "oar":
          {
            const distance = opt.scoring.rounding(score.tp[0].distanceEarth(score.tp[1])) - opt.scoring.cylinders;
            score.legs[0].d = score.legs[1].d = distance, score.distance = 2 * distance;
          }
          break;
        case "od": {
          const all = [score.ep.start, score.tp[0], score.tp[1], score.tp[2], score.ep.finish];
          score.distance = 0;
          for (let i = 0; i < all.length - 1; i++)
            score.legs[i].d = opt.scoring.rounding(all[i].distanceEarth(all[i + 1])), score.legs[i].d -= 2 * opt.scoring.cylinders, score.distance += score.legs[i].d;
        }
      }
      score.distance = finalRounding(score.distance, opt), score.score = score.distance >= (opt.scoring.minDistance || 0) ? finalRounding((score.distance - (score.penalty || 0)) * opt.scoring.multiplier, opt) : 0;
    }
    __name(adjustFAICylinders, "adjustFAICylinders");
    var scoringRules = { FFVL: [{ name: "Distance 3 points", multiplier: 1, bound: boundDistance3Points, score: scoreDistance3Points, rounding: round2, cardinality: 3, code: "od" }, { name: "Triangle plat", multiplier: 1.2, bound: boundTriangle, score: scoreTriangle, closingDistance: closingWithLimit, closingDistanceFixed: 3, closingDistanceFree: 3, closingDistanceRelative: 0.05, rounding: round2, cardinality: 3, code: "tri" }, { name: "Triangle FAI", multiplier: 1.4, bound: boundTriangle, score: scoreTriangle, minSide: 0.28, closingDistance: closingWithLimit, closingDistanceFixed: 3, closingDistanceFree: 3, closingDistanceRelative: 0.05, rounding: round2, cardinality: 3, code: "fai" }], XContest: [{ name: "Free Flight", multiplier: 1, bound: boundDistance3Points, score: scoreDistance3Points, rounding: round2, cardinality: 3, code: "od" }, { name: "Free Triangle", multiplier: 1.2, bound: boundTriangle, score: scoreTriangle, closingDistance: closingWithLimit, closingDistanceRelative: 0.2, rounding: round2, cardinality: 3, code: "tri" }, { name: "FAI Triangle", multiplier: 1.4, bound: boundTriangle, score: scoreTriangle, minSide: 0.28, closingDistance: closingWithLimit, closingDistanceRelative: 0.2, rounding: round2, cardinality: 3, code: "fai" }, { name: "Closed Free Triangle", multiplier: 1.4, bound: boundTriangle, score: scoreTriangle, closingDistance: closingWithLimit, closingDistanceFixed: 0, closingDistanceFree: 0, closingDistanceRelative: 0.05, rounding: round2, cardinality: 3, code: "tri" }, { name: "Closed FAI Triangle", multiplier: 1.6, bound: boundTriangle, score: scoreTriangle, minSide: 0.28, closingDistance: closingWithLimit, closingDistanceFixed: 0, closingDistanceFree: 0, closingDistanceRelative: 0.05, rounding: round2, cardinality: 3, code: "fai" }], FAI: [{ name: "Free Distance around 3 TPs", multiplier: 1, bound: boundDistance3Points, score: scoreDistance3Points, rounding: round2, finalRounding: round1, cardinality: 3, code: "od" }, { name: "Free Triangle", multiplier: 1.2, bound: boundTriangle, score: scoreTriangle, closingDistance: closingWithLimit, closingDistanceFree: 0.8, closingDistanceFixed: 0.8, rounding: round2, finalRounding: round1, cardinality: 3, code: "tri" }, { name: "FAI Triangle", multiplier: 1.4, bound: boundTriangle, score: scoreTriangle, minSide: 0.28, closingDistance: closingWithLimit, closingDistanceFree: 0.8, closingDistanceFixed: 0.8, rounding: round2, finalRounding: round1, cardinality: 3, code: "fai" }], "FAI-Cylinders": [{ name: "Free Distance around 3 TPs", multiplier: 1, bound: boundDistance3Points, score: scoreDistance3Points, rounding: round2, finalRounding: round1, cardinality: 3, code: "od", cylinders: 0.4, post: adjustFAICylinders }, { name: "Free Triangle", multiplier: 1.2, bound: boundTriangle, score: scoreTriangle, closingDistance: closingWithLimit, closingDistanceFree: 0.8, closingDistanceFixed: 0.8, rounding: round2, finalRounding: round1, cardinality: 3, code: "tri", cylinders: 0.4, post: adjustFAICylinders }, { name: "FAI Triangle", multiplier: 1.4, bound: boundTriangle, score: scoreTriangle, minSide: 0.28, closingDistance: closingWithLimit, closingDistanceFree: 0.8, closingDistanceFixed: 0.8, rounding: round2, finalRounding: round1, cardinality: 3, code: "fai", cylinders: 0.4, post: adjustFAICylinders }], "FAI-OAR": [{ name: "Out-and-Return Distance", multiplier: 1, bound: function(ranges, boxes, opt) {
      const box2 = new Box(Math.min(boxes[0].x1, boxes[2].x1), Math.min(boxes[0].y1, boxes[2].y1), Math.max(boxes[0].x2, boxes[2].x2), Math.max(boxes[0].y2, boxes[2].y2)), maxDistance = opt.scoring.rounding(maxDistance2Rectangles([boxes[1], box2]));
      if (maxDistance < (opt.scoring.minDistance || 0))
        return 0;
      if (ranges[0].end < ranges[2].start) {
        const cp = isOutAndReturnClosed(ranges[0], ranges[2], maxDistance, opt);
        if (!cp)
          return 0;
        const box22 = new Box((boxes[0].x1 + boxes[2].x1) / 2, (boxes[0].y1 + boxes[2].y1) / 2, (boxes[0].x2 + boxes[2].x2) / 2, (boxes[0].y2 + boxes[2].y2) / 2);
        return finalRounding(2 * (opt.scoring.rounding(maxDistance2Rectangles([boxes[1], box22])) - closingPenalty(cp.d, opt)) * opt.scoring.multiplier, opt);
      }
      return finalRounding(2 * maxDistance * opt.scoring.multiplier, opt);
    }, score: function(tp, opt) {
      const tp2 = new Point((tp[0].x + tp[2].x) / 2, (tp[0].y + tp[2].y) / 2), leg = opt.scoring.rounding(tp[1].distanceEarth(tp2)), distance = finalRounding(2 * leg, opt);
      if (distance < (opt.scoring.minDistance || 0))
        return { score: 0 };
      const closing = opt.scoring.rounding(tp[0].distanceEarth(tp[2]));
      if (closing > opt.scoring.closingDistance(distance, opt))
        return { score: 0 };
      const score = finalRounding((distance - closingPenalty(closing, opt)) * opt.scoring.multiplier, opt), legs = [{ name: "TP1 : TP2", start: tp[1], finish: tp2, d: leg }, { name: "TP2 : TP1", start: tp2, finish: tp[1], d: leg }];
      return { distance, score, tp: [tp[1], tp2], cp: { d: closing, in: tp[0], out: tp[2] }, legs };
    }, closingDistance: closingWithLimit, closingDistanceFree: 0.8, closingDistanceFixed: 0.8, rounding: round2, finalRounding: round1, cardinality: 3, code: "oar" }], "FAI-OAR2": [{ name: "Out-and-Return Flight around 2 TPs", multiplier: 1, bound: boundOutAndReturn2, score: scoreOutAndReturn2, closingDistance: closingWithLimit, closingDistanceFree: 0.8, closingDistanceFixed: 0.8, rounding: round2, finalRounding: round1, cardinality: 2, code: "oar" }], XCLeague: [{ name: "Out-and-Return Distance >=35km", multiplier: 2, bound: boundOutAndReturn2, score: scoreOutAndReturn2, closingDistance: closingWithLimit, closingDistanceFixed: 0.8, rounding: round2, finalRounding: round1, cardinality: 2, code: "oar", minDistance: 35 }, { name: "Out-and-Return Distance >=15km", multiplier: 1.5, bound: boundOutAndReturn2, score: scoreOutAndReturn2, closingDistance: closingWithLimit, closingDistanceFixed: 0.8, rounding: round2, finalRounding: round1, cardinality: 2, code: "oar", minDistance: 15 }, { name: "Out-and-Return Distance >=5km (Clubs)", multiplier: 1.2, bound: boundOutAndReturn2, score: scoreOutAndReturn2, closingDistance: closingWithLimit, closingDistanceFixed: 0.8, rounding: round2, finalRounding: round1, cardinality: 2, code: "oar", minDistance: 5 }, { name: "Turnpoint Flight", multiplier: 1, bound: boundDistance3Points, score: scoreDistance3Points, rounding: round2, finalRounding: round1, cardinality: 3, code: "od", minDistance: 5 }, { name: "Flat Triangle >=35km", multiplier: 2, bound: boundTriangle, score: scoreTriangle, minSide: 0.15, maxSide: 0.45, closingDistance: closingWithLimit, closingDistanceFixed: 0.8, rounding: round2, finalRounding: round1, cardinality: 3, code: "tri", minDistance: 35 }, { name: "Flat Triangle >=15km", multiplier: 1.5, bound: boundTriangle, score: scoreTriangle, minSide: 0.15, maxSide: 0.45, closingDistance: closingWithLimit, closingDistanceFixed: 0.8, rounding: round2, finalRounding: round1, cardinality: 3, code: "tri", minDistance: 15 }, { name: "Flat Triangle >=5km (Clubs)", multiplier: 1.2, bound: boundTriangle, score: scoreTriangle, minSide: 0.15, maxSide: 0.45, closingDistance: closingWithLimit, closingDistanceFixed: 0.8, rounding: round2, finalRounding: round1, cardinality: 3, code: "tri", minDistance: 5 }, { name: "FAI Triangle >=25km", multiplier: 2.3, bound: boundTriangle, score: scoreTriangle, minSide: 0.28, closingDistance: closingWithLimit, closingDistanceFixed: 0.8, rounding: round2, finalRounding: round1, cardinality: 3, code: "tri", minDistance: 25 }, { name: "FAI Triangle >=15km", multiplier: 2, bound: boundTriangle, score: scoreTriangle, minSide: 0.28, closingDistance: closingWithLimit, closingDistanceFixed: 0.8, rounding: round2, finalRounding: round1, cardinality: 3, code: "tri", minDistance: 15 }, { name: "FAI Triangle >=5km (Clubs)", multiplier: 1.5, bound: boundTriangle, score: scoreTriangle, minSide: 0.28, closingDistance: closingWithLimit, closingDistanceFixed: 0.8, rounding: round2, finalRounding: round1, cardinality: 3, code: "tri", minDistance: 5 }] };
    function round2(score) {
      return parseFloat(parseFloat(score).toFixed(2));
    }
    __name(round2, "round2");
    function round1(score) {
      return parseFloat(parseFloat(score).toFixed(1));
    }
    __name(round1, "round1");
    exports.scoringRules = scoringRules, exports.solver = function* (flight, _scoringTypes, _config) {
      let reset;
      const scoringTypes = _scoringTypes || scoringRules.FFVL, config = _config || {};
      analyze(flight, config), function(opt) {
        opt.flight.closestPairs = new RBush(), opt.flight.furthestPoints = [new map(), new map()], opt.flight.flightPoints = new Array(opt.flight.filtered.length);
        for (let r in opt.flight.filtered)
          opt.flight.flightPoints[r] = new Point(opt.flight.filtered, r);
      }({ flight }), config.hp ? Point.prototype.distanceEarth = Point.prototype.distanceEarthVincentys : Point.prototype.distanceEarth = Point.prototype.distanceEarthFCC;
      let solutionRoots = [];
      for (let scoringType of scoringTypes)
        for (let l of flight.ll) {
          const opt = { flight, launch: l.launch, landing: l.landing, scoring: scoringType, config };
          let solutionRoot = new Solution2([new Range(l.launch, l.landing), new Range(l.launch, l.landing), new Range(l.launch, l.landing)], opt);
          solutionRoot.do_bound(), solutionRoot.do_score(), solutionRoots.push(solutionRoot);
        }
      let best = solutionRoots[0], solutionQueue = new sortedSet(solutionRoots, Solution2.prototype.contentEquals, Solution2.prototype.contentCompare), processed = 0, tcum = 0;
      do {
        const tstart = Date.now();
        for (; solutionQueue.length > 0; ) {
          if (processed % 100 == 0 && config.env && "undefined" !== config.env.v8) {
            const mem = config.env.v8.getHeapStatistics();
            if (mem.used_heap_size / mem.heap_size_limit > 0.98) {
              console.error(`Out of memory: ${mem.used_heap_size / 1024}KiB used of ${mem.heap_size_limit / 1024}KiB total`);
              break;
            }
          }
          let current = solutionQueue.pop();
          if (current.bound <= best.score) {
            solutionQueue.clear();
            break;
          }
          let children = current.do_branch();
          for (let s of children)
            if (s.do_bound(), !(s.bound <= best.score)) {
              if (s.do_score(), processed++, s.score >= best.score && s.score > 0) {
                if (best = s, solutionQueue.findLeast() && solutionQueue.findLeast().value.bound <= best.score) {
                  const garbageBest = solutionQueue.findGreatestLessThanOrEqual({ bound: best.score });
                  if (void 0 !== garbageBest) {
                    const cutoff = solutionQueue.indexOf(garbageBest.value);
                    solutionQueue.splice(0, cutoff + 1).length;
                  }
                }
              } else
                delete s.scoreInfo;
              solutionQueue.push(s), config.debug && (best.last = s);
            }
          if (processed > config.maxloop || Date.now() - tstart > config.maxcycle)
            break;
        }
        best.processed = processed;
        const currentUpperBound = solutionQueue.findGreatest();
        if (best.currentUpperBound = currentUpperBound ? currentUpperBound.value.bound : best.bound, tcum += Date.now() - tstart, best.time = tcum, 0 == solutionQueue.length ? best.optimal = true : best.optimal = false, best.optimal)
          return reset = true, best;
        reset = yield best;
      } while (!reset);
    };
  }
});

// node_modules/exifr/dist/full.umd.js
var require_full_umd = __commonJS({
  "node_modules/exifr/dist/full.umd.js"(exports, module2) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module2 ? t(exports) : "function" == typeof define && define.amd ? define("exifr", ["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).exifr = {});
    }(exports, function(e) {
      "use strict";
      var t = "undefined" != typeof self ? self : global;
      const i = "undefined" != typeof navigator, n = i && "undefined" == typeof HTMLImageElement, s = !("undefined" == typeof global || "undefined" == typeof process || !process.versions || !process.versions.node), r = t.Buffer, a = t.BigInt, o = !!r, l = /* @__PURE__ */ __name((e2) => e2, "l");
      function h(e2, t2 = l) {
        if (s)
          try {
            return "function" == typeof require ? Promise.resolve(t2(require(e2))) : import(
              /* webpackIgnore: true */
              e2
            ).then(t2);
          } catch (t3) {
            console.warn(`Couldn't load ${e2}`);
          }
      }
      __name(h, "h");
      let u = t.fetch;
      const c = /* @__PURE__ */ __name((e2) => u = e2, "c");
      if (!t.fetch) {
        const e2 = h("http", (e3) => e3), t2 = h("https", (e3) => e3), i2 = /* @__PURE__ */ __name((n2, { headers: s2 } = {}) => new Promise(async (r2, a2) => {
          let { port: o2, hostname: l2, pathname: h2, protocol: u2, search: c2 } = new URL(n2);
          const f2 = { method: "GET", hostname: l2, path: encodeURI(h2) + c2, headers: s2 };
          "" !== o2 && (f2.port = Number(o2));
          const d2 = ("https:" === u2 ? await t2 : await e2).request(f2, (e3) => {
            if (301 === e3.statusCode || 302 === e3.statusCode) {
              let t3 = new URL(e3.headers.location, n2).toString();
              return i2(t3, { headers: s2 }).then(r2).catch(a2);
            }
            r2({ status: e3.statusCode, arrayBuffer: () => new Promise((t3) => {
              let i3 = [];
              e3.on("data", (e4) => i3.push(e4)), e3.on("end", () => t3(Buffer.concat(i3)));
            }) });
          });
          d2.on("error", a2), d2.end();
        }), "i");
        c(i2);
      }
      function f(e2, t2, i2) {
        return t2 in e2 ? Object.defineProperty(e2, t2, { value: i2, enumerable: true, configurable: true, writable: true }) : e2[t2] = i2, e2;
      }
      __name(f, "f");
      const d = /* @__PURE__ */ __name((e2) => g(e2) ? void 0 : e2, "d"), p = /* @__PURE__ */ __name((e2) => void 0 !== e2, "p");
      function g(e2) {
        return void 0 === e2 || (e2 instanceof Map ? 0 === e2.size : 0 === Object.values(e2).filter(p).length);
      }
      __name(g, "g");
      function m(e2) {
        let t2 = new Error(e2);
        throw delete t2.stack, t2;
      }
      __name(m, "m");
      function S(e2) {
        return "" === (e2 = function(e3) {
          for (; e3.endsWith("\0"); )
            e3 = e3.slice(0, -1);
          return e3;
        }(e2).trim()) ? void 0 : e2;
      }
      __name(S, "S");
      function C(e2) {
        let t2 = function(e3) {
          let t3 = 0;
          return e3.ifd0.enabled && (t3 += 1024), e3.exif.enabled && (t3 += 2048), e3.makerNote && (t3 += 2048), e3.userComment && (t3 += 1024), e3.gps.enabled && (t3 += 512), e3.interop.enabled && (t3 += 100), e3.ifd1.enabled && (t3 += 1024), t3 + 2048;
        }(e2);
        return e2.jfif.enabled && (t2 += 50), e2.xmp.enabled && (t2 += 2e4), e2.iptc.enabled && (t2 += 14e3), e2.icc.enabled && (t2 += 6e3), t2;
      }
      __name(C, "C");
      const y = /* @__PURE__ */ __name((e2) => String.fromCharCode.apply(null, e2), "y"), b = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8") : void 0;
      function P(e2) {
        return b ? b.decode(e2) : o ? Buffer.from(e2).toString("utf8") : decodeURIComponent(escape(y(e2)));
      }
      __name(P, "P");
      class I {
        static from(e2, t2) {
          return e2 instanceof this && e2.le === t2 ? e2 : new I(e2, void 0, void 0, t2);
        }
        constructor(e2, t2 = 0, i2, n2) {
          if ("boolean" == typeof n2 && (this.le = n2), Array.isArray(e2) && (e2 = new Uint8Array(e2)), 0 === e2)
            this.byteOffset = 0, this.byteLength = 0;
          else if (e2 instanceof ArrayBuffer) {
            void 0 === i2 && (i2 = e2.byteLength - t2);
            let n3 = new DataView(e2, t2, i2);
            this._swapDataView(n3);
          } else if (e2 instanceof Uint8Array || e2 instanceof DataView || e2 instanceof I) {
            void 0 === i2 && (i2 = e2.byteLength - t2), (t2 += e2.byteOffset) + i2 > e2.byteOffset + e2.byteLength && m("Creating view outside of available memory in ArrayBuffer");
            let n3 = new DataView(e2.buffer, t2, i2);
            this._swapDataView(n3);
          } else if ("number" == typeof e2) {
            let t3 = new DataView(new ArrayBuffer(e2));
            this._swapDataView(t3);
          } else
            m("Invalid input argument for BufferView: " + e2);
        }
        _swapArrayBuffer(e2) {
          this._swapDataView(new DataView(e2));
        }
        _swapBuffer(e2) {
          this._swapDataView(new DataView(e2.buffer, e2.byteOffset, e2.byteLength));
        }
        _swapDataView(e2) {
          this.dataView = e2, this.buffer = e2.buffer, this.byteOffset = e2.byteOffset, this.byteLength = e2.byteLength;
        }
        _lengthToEnd(e2) {
          return this.byteLength - e2;
        }
        set(e2, t2, i2 = I) {
          return e2 instanceof DataView || e2 instanceof I ? e2 = new Uint8Array(e2.buffer, e2.byteOffset, e2.byteLength) : e2 instanceof ArrayBuffer && (e2 = new Uint8Array(e2)), e2 instanceof Uint8Array || m("BufferView.set(): Invalid data argument."), this.toUint8().set(e2, t2), new i2(this, t2, e2.byteLength);
        }
        subarray(e2, t2) {
          return t2 = t2 || this._lengthToEnd(e2), new I(this, e2, t2);
        }
        toUint8() {
          return new Uint8Array(this.buffer, this.byteOffset, this.byteLength);
        }
        getUint8Array(e2, t2) {
          return new Uint8Array(this.buffer, this.byteOffset + e2, t2);
        }
        getString(e2 = 0, t2 = this.byteLength) {
          return P(this.getUint8Array(e2, t2));
        }
        getLatin1String(e2 = 0, t2 = this.byteLength) {
          let i2 = this.getUint8Array(e2, t2);
          return y(i2);
        }
        getUnicodeString(e2 = 0, t2 = this.byteLength) {
          const i2 = [];
          for (let n2 = 0; n2 < t2 && e2 + n2 < this.byteLength; n2 += 2)
            i2.push(this.getUint16(e2 + n2));
          return y(i2);
        }
        getInt8(e2) {
          return this.dataView.getInt8(e2);
        }
        getUint8(e2) {
          return this.dataView.getUint8(e2);
        }
        getInt16(e2, t2 = this.le) {
          return this.dataView.getInt16(e2, t2);
        }
        getInt32(e2, t2 = this.le) {
          return this.dataView.getInt32(e2, t2);
        }
        getUint16(e2, t2 = this.le) {
          return this.dataView.getUint16(e2, t2);
        }
        getUint32(e2, t2 = this.le) {
          return this.dataView.getUint32(e2, t2);
        }
        getFloat32(e2, t2 = this.le) {
          return this.dataView.getFloat32(e2, t2);
        }
        getFloat64(e2, t2 = this.le) {
          return this.dataView.getFloat64(e2, t2);
        }
        getFloat(e2, t2 = this.le) {
          return this.dataView.getFloat32(e2, t2);
        }
        getDouble(e2, t2 = this.le) {
          return this.dataView.getFloat64(e2, t2);
        }
        getUintBytes(e2, t2, i2) {
          switch (t2) {
            case 1:
              return this.getUint8(e2, i2);
            case 2:
              return this.getUint16(e2, i2);
            case 4:
              return this.getUint32(e2, i2);
            case 8:
              return this.getUint64 && this.getUint64(e2, i2);
          }
        }
        getUint(e2, t2, i2) {
          switch (t2) {
            case 8:
              return this.getUint8(e2, i2);
            case 16:
              return this.getUint16(e2, i2);
            case 32:
              return this.getUint32(e2, i2);
            case 64:
              return this.getUint64 && this.getUint64(e2, i2);
          }
        }
        toString(e2) {
          return this.dataView.toString(e2, this.constructor.name);
        }
        ensureChunk() {
        }
      }
      __name(I, "I");
      function k(e2, t2) {
        m(`${e2} '${t2}' was not loaded, try using full build of exifr.`);
      }
      __name(k, "k");
      class w extends Map {
        constructor(e2) {
          super(), this.kind = e2;
        }
        get(e2, t2) {
          return this.has(e2) || k(this.kind, e2), t2 && (e2 in t2 || function(e3, t3) {
            m(`Unknown ${e3} '${t3}'.`);
          }(this.kind, e2), t2[e2].enabled || k(this.kind, e2)), super.get(e2);
        }
        keyList() {
          return Array.from(this.keys());
        }
      }
      __name(w, "w");
      var T = new w("file parser"), A = new w("segment parser"), D = new w("file reader");
      const O = "Invalid input argument";
      function x(e2, t2) {
        return "string" == typeof e2 ? v(e2, t2) : i && !n && e2 instanceof HTMLImageElement ? v(e2.src, t2) : e2 instanceof Uint8Array || e2 instanceof ArrayBuffer || e2 instanceof DataView ? new I(e2) : i && e2 instanceof Blob ? M(e2, t2, "blob", U) : void m(O);
      }
      __name(x, "x");
      function v(e2, t2) {
        return (n2 = e2).startsWith("data:") || n2.length > 1e4 ? R2(e2, t2, "base64") : s && e2.includes("://") ? M(e2, t2, "url", L) : s ? R2(e2, t2, "fs") : i ? M(e2, t2, "url", L) : void m(O);
        var n2;
      }
      __name(v, "v");
      async function M(e2, t2, i2, n2) {
        return D.has(i2) ? R2(e2, t2, i2) : n2 ? async function(e3, t3) {
          let i3 = await t3(e3);
          return new I(i3);
        }(e2, n2) : void m(`Parser ${i2} is not loaded`);
      }
      __name(M, "M");
      async function R2(e2, t2, i2) {
        let n2 = new (D.get(i2))(e2, t2);
        return await n2.read(), n2;
      }
      __name(R2, "R");
      const L = /* @__PURE__ */ __name((e2) => u(e2).then((e3) => e3.arrayBuffer()), "L"), U = /* @__PURE__ */ __name((e2) => new Promise((t2, i2) => {
        let n2 = new FileReader();
        n2.onloadend = () => t2(n2.result || new ArrayBuffer()), n2.onerror = i2, n2.readAsArrayBuffer(e2);
      }), "U");
      class F extends Map {
        get tagKeys() {
          return this.allKeys || (this.allKeys = Array.from(this.keys())), this.allKeys;
        }
        get tagValues() {
          return this.allValues || (this.allValues = Array.from(this.values())), this.allValues;
        }
      }
      __name(F, "F");
      function B(e2, t2, i2) {
        let n2 = new F();
        for (let [e3, t3] of i2)
          n2.set(e3, t3);
        if (Array.isArray(t2))
          for (let i3 of t2)
            e2.set(i3, n2);
        else
          e2.set(t2, n2);
        return n2;
      }
      __name(B, "B");
      function E(e2, t2, i2) {
        let n2, s2 = e2.get(t2);
        for (n2 of i2)
          s2.set(n2[0], n2[1]);
      }
      __name(E, "E");
      const N = /* @__PURE__ */ new Map(), G = /* @__PURE__ */ new Map(), V = /* @__PURE__ */ new Map(), z = 37500, H = 37510, j = 700, W = 33723, K = 34675, X = 34665, _ = 34853, Y = 40965, $ = ["chunked", "firstChunkSize", "firstChunkSizeNode", "firstChunkSizeBrowser", "chunkSize", "chunkLimit"], J = ["jfif", "xmp", "icc", "iptc", "ihdr"], q = ["tiff", ...J], Q = ["ifd0", "ifd1", "exif", "gps", "interop"], Z = [...q, ...Q], ee = ["makerNote", "userComment"], te = ["translateKeys", "translateValues", "reviveValues", "multiSegment"], ie = [...te, "sanitize", "mergeOutput", "silentErrors"];
      class ne {
        get translate() {
          return this.translateKeys || this.translateValues || this.reviveValues;
        }
      }
      __name(ne, "ne");
      class se extends ne {
        get needed() {
          return this.enabled || this.deps.size > 0;
        }
        constructor(e2, t2, i2, n2) {
          if (super(), f(this, "enabled", false), f(this, "skip", /* @__PURE__ */ new Set()), f(this, "pick", /* @__PURE__ */ new Set()), f(this, "deps", /* @__PURE__ */ new Set()), f(this, "translateKeys", false), f(this, "translateValues", false), f(this, "reviveValues", false), this.key = e2, this.enabled = t2, this.parse = this.enabled, this.applyInheritables(n2), this.canBeFiltered = Q.includes(e2), this.canBeFiltered && (this.dict = N.get(e2)), void 0 !== i2)
            if (Array.isArray(i2))
              this.parse = this.enabled = true, this.canBeFiltered && i2.length > 0 && this.translateTagSet(i2, this.pick);
            else if ("object" == typeof i2) {
              if (this.enabled = true, this.parse = false !== i2.parse, this.canBeFiltered) {
                let { pick: e3, skip: t3 } = i2;
                e3 && e3.length > 0 && this.translateTagSet(e3, this.pick), t3 && t3.length > 0 && this.translateTagSet(t3, this.skip);
              }
              this.applyInheritables(i2);
            } else
              true === i2 || false === i2 ? this.parse = this.enabled = i2 : m(`Invalid options argument: ${i2}`);
        }
        applyInheritables(e2) {
          let t2, i2;
          for (t2 of te)
            i2 = e2[t2], void 0 !== i2 && (this[t2] = i2);
        }
        translateTagSet(e2, t2) {
          if (this.dict) {
            let i2, n2, { tagKeys: s2, tagValues: r2 } = this.dict;
            for (i2 of e2)
              "string" == typeof i2 ? (n2 = r2.indexOf(i2), -1 === n2 && (n2 = s2.indexOf(Number(i2))), -1 !== n2 && t2.add(Number(s2[n2]))) : t2.add(i2);
          } else
            for (let i2 of e2)
              t2.add(i2);
        }
        finalizeFilters() {
          !this.enabled && this.deps.size > 0 ? (this.enabled = true, ue(this.pick, this.deps)) : this.enabled && this.pick.size > 0 && ue(this.pick, this.deps);
        }
      }
      __name(se, "se");
      var re = { jfif: false, tiff: true, xmp: false, icc: false, iptc: false, ifd0: true, ifd1: false, exif: true, gps: true, interop: false, ihdr: void 0, makerNote: false, userComment: false, multiSegment: false, skip: [], pick: [], translateKeys: true, translateValues: true, reviveValues: true, sanitize: true, mergeOutput: true, silentErrors: true, chunked: true, firstChunkSize: void 0, firstChunkSizeNode: 512, firstChunkSizeBrowser: 65536, chunkSize: 65536, chunkLimit: 5 }, ae = /* @__PURE__ */ new Map();
      class oe extends ne {
        static useCached(e2) {
          let t2 = ae.get(e2);
          return void 0 !== t2 || (t2 = new this(e2), ae.set(e2, t2)), t2;
        }
        constructor(e2) {
          super(), true === e2 ? this.setupFromTrue() : void 0 === e2 ? this.setupFromUndefined() : Array.isArray(e2) ? this.setupFromArray(e2) : "object" == typeof e2 ? this.setupFromObject(e2) : m(`Invalid options argument ${e2}`), void 0 === this.firstChunkSize && (this.firstChunkSize = i ? this.firstChunkSizeBrowser : this.firstChunkSizeNode), this.mergeOutput && (this.ifd1.enabled = false), this.filterNestedSegmentTags(), this.traverseTiffDependencyTree(), this.checkLoadedPlugins();
        }
        setupFromUndefined() {
          let e2;
          for (e2 of $)
            this[e2] = re[e2];
          for (e2 of ie)
            this[e2] = re[e2];
          for (e2 of ee)
            this[e2] = re[e2];
          for (e2 of Z)
            this[e2] = new se(e2, re[e2], void 0, this);
        }
        setupFromTrue() {
          let e2;
          for (e2 of $)
            this[e2] = re[e2];
          for (e2 of ie)
            this[e2] = re[e2];
          for (e2 of ee)
            this[e2] = true;
          for (e2 of Z)
            this[e2] = new se(e2, true, void 0, this);
        }
        setupFromArray(e2) {
          let t2;
          for (t2 of $)
            this[t2] = re[t2];
          for (t2 of ie)
            this[t2] = re[t2];
          for (t2 of ee)
            this[t2] = re[t2];
          for (t2 of Z)
            this[t2] = new se(t2, false, void 0, this);
          this.setupGlobalFilters(e2, void 0, Q);
        }
        setupFromObject(e2) {
          let t2;
          for (t2 of (Q.ifd0 = Q.ifd0 || Q.image, Q.ifd1 = Q.ifd1 || Q.thumbnail, Object.assign(this, e2), $))
            this[t2] = he(e2[t2], re[t2]);
          for (t2 of ie)
            this[t2] = he(e2[t2], re[t2]);
          for (t2 of ee)
            this[t2] = he(e2[t2], re[t2]);
          for (t2 of q)
            this[t2] = new se(t2, re[t2], e2[t2], this);
          for (t2 of Q)
            this[t2] = new se(t2, re[t2], e2[t2], this.tiff);
          this.setupGlobalFilters(e2.pick, e2.skip, Q, Z), true === e2.tiff ? this.batchEnableWithBool(Q, true) : false === e2.tiff ? this.batchEnableWithUserValue(Q, e2) : Array.isArray(e2.tiff) ? this.setupGlobalFilters(e2.tiff, void 0, Q) : "object" == typeof e2.tiff && this.setupGlobalFilters(e2.tiff.pick, e2.tiff.skip, Q);
        }
        batchEnableWithBool(e2, t2) {
          for (let i2 of e2)
            this[i2].enabled = t2;
        }
        batchEnableWithUserValue(e2, t2) {
          for (let i2 of e2) {
            let e3 = t2[i2];
            this[i2].enabled = false !== e3 && void 0 !== e3;
          }
        }
        setupGlobalFilters(e2, t2, i2, n2 = i2) {
          if (e2 && e2.length) {
            for (let e3 of n2)
              this[e3].enabled = false;
            let t3 = le(e2, i2);
            for (let [e3, i3] of t3)
              ue(this[e3].pick, i3), this[e3].enabled = true;
          } else if (t2 && t2.length) {
            let e3 = le(t2, i2);
            for (let [t3, i3] of e3)
              ue(this[t3].skip, i3);
          }
        }
        filterNestedSegmentTags() {
          let { ifd0: e2, exif: t2, xmp: i2, iptc: n2, icc: s2 } = this;
          this.makerNote ? t2.deps.add(z) : t2.skip.add(z), this.userComment ? t2.deps.add(H) : t2.skip.add(H), i2.enabled || e2.skip.add(j), n2.enabled || e2.skip.add(W), s2.enabled || e2.skip.add(K);
        }
        traverseTiffDependencyTree() {
          let { ifd0: e2, exif: t2, gps: i2, interop: n2 } = this;
          n2.needed && (t2.deps.add(Y), e2.deps.add(Y)), t2.needed && e2.deps.add(X), i2.needed && e2.deps.add(_), this.tiff.enabled = Q.some((e3) => true === this[e3].enabled) || this.makerNote || this.userComment;
          for (let e3 of Q)
            this[e3].finalizeFilters();
        }
        get onlyTiff() {
          return !J.map((e2) => this[e2].enabled).some((e2) => true === e2) && this.tiff.enabled;
        }
        checkLoadedPlugins() {
          for (let e2 of q)
            this[e2].enabled && !A.has(e2) && k("segment parser", e2);
        }
      }
      __name(oe, "oe");
      function le(e2, t2) {
        let i2, n2, s2, r2, a2 = [];
        for (s2 of t2) {
          for (r2 of (i2 = N.get(s2), n2 = [], i2))
            (e2.includes(r2[0]) || e2.includes(r2[1])) && n2.push(r2[0]);
          n2.length && a2.push([s2, n2]);
        }
        return a2;
      }
      __name(le, "le");
      function he(e2, t2) {
        return void 0 !== e2 ? e2 : void 0 !== t2 ? t2 : void 0;
      }
      __name(he, "he");
      function ue(e2, t2) {
        for (let i2 of t2)
          e2.add(i2);
      }
      __name(ue, "ue");
      f(oe, "default", re);
      class ce {
        constructor(e2) {
          f(this, "parsers", {}), f(this, "output", {}), f(this, "errors", []), f(this, "pushToErrors", (e3) => this.errors.push(e3)), this.options = oe.useCached(e2);
        }
        async read(e2) {
          this.file = await x(e2, this.options);
        }
        setup() {
          if (this.fileParser)
            return;
          let { file: e2 } = this, t2 = e2.getUint16(0);
          for (let [i2, n2] of T)
            if (n2.canHandle(e2, t2))
              return this.fileParser = new n2(this.options, this.file, this.parsers), e2[i2] = true;
          this.file.close && this.file.close(), m("Unknown file format");
        }
        async parse() {
          let { output: e2, errors: t2 } = this;
          return this.setup(), this.options.silentErrors ? (await this.executeParsers().catch(this.pushToErrors), t2.push(...this.fileParser.errors)) : await this.executeParsers(), this.file.close && this.file.close(), this.options.silentErrors && t2.length > 0 && (e2.errors = t2), d(e2);
        }
        async executeParsers() {
          let { output: e2 } = this;
          await this.fileParser.parse();
          let t2 = Object.values(this.parsers).map(async (t3) => {
            let i2 = await t3.parse();
            t3.assignToOutput(e2, i2);
          });
          this.options.silentErrors && (t2 = t2.map((e3) => e3.catch(this.pushToErrors))), await Promise.all(t2);
        }
        async extractThumbnail() {
          this.setup();
          let { options: e2, file: t2 } = this, i2 = A.get("tiff", e2);
          var n2;
          if (t2.tiff ? n2 = { start: 0, type: "tiff" } : t2.jpeg && (n2 = await this.fileParser.getOrFindSegment("tiff")), void 0 === n2)
            return;
          let s2 = await this.fileParser.ensureSegmentChunk(n2), r2 = this.parsers.tiff = new i2(s2, e2, t2), a2 = await r2.extractThumbnail();
          return t2.close && t2.close(), a2;
        }
      }
      __name(ce, "ce");
      async function fe(e2, t2) {
        let i2 = new ce(t2);
        return await i2.read(e2), i2.parse();
      }
      __name(fe, "fe");
      var de = Object.freeze({ __proto__: null, parse: fe, Exifr: ce, fileParsers: T, segmentParsers: A, fileReaders: D, tagKeys: N, tagValues: G, tagRevivers: V, createDictionary: B, extendDictionary: E, fetchUrlAsArrayBuffer: L, readBlobAsArrayBuffer: U, chunkedProps: $, otherSegments: J, segments: q, tiffBlocks: Q, segmentsAndBlocks: Z, tiffExtractables: ee, inheritables: te, allFormatters: ie, Options: oe });
      class pe {
        constructor(e2, t2, i2) {
          f(this, "errors", []), f(this, "ensureSegmentChunk", async (e3) => {
            let t3 = e3.start, i3 = e3.size || 65536;
            if (this.file.chunked)
              if (this.file.available(t3, i3))
                e3.chunk = this.file.subarray(t3, i3);
              else
                try {
                  e3.chunk = await this.file.readChunk(t3, i3);
                } catch (t4) {
                  m(`Couldn't read segment: ${JSON.stringify(e3)}. ${t4.message}`);
                }
            else
              this.file.byteLength > t3 + i3 ? e3.chunk = this.file.subarray(t3, i3) : void 0 === e3.size ? e3.chunk = this.file.subarray(t3) : m("Segment unreachable: " + JSON.stringify(e3));
            return e3.chunk;
          }), this.extendOptions && this.extendOptions(e2), this.options = e2, this.file = t2, this.parsers = i2;
        }
        injectSegment(e2, t2) {
          this.options[e2].enabled && this.createParser(e2, t2);
        }
        createParser(e2, t2) {
          let i2 = new (A.get(e2))(t2, this.options, this.file);
          return this.parsers[e2] = i2;
        }
        createParsers(e2) {
          for (let t2 of e2) {
            let { type: e3, chunk: i2 } = t2, n2 = this.options[e3];
            if (n2 && n2.enabled) {
              let t3 = this.parsers[e3];
              t3 && t3.append || t3 || this.createParser(e3, i2);
            }
          }
        }
        async readSegments(e2) {
          let t2 = e2.map(this.ensureSegmentChunk);
          await Promise.all(t2);
        }
      }
      __name(pe, "pe");
      class ge {
        static findPosition(e2, t2) {
          let i2 = e2.getUint16(t2 + 2) + 2, n2 = "function" == typeof this.headerLength ? this.headerLength(e2, t2, i2) : this.headerLength, s2 = t2 + n2, r2 = i2 - n2;
          return { offset: t2, length: i2, headerLength: n2, start: s2, size: r2, end: s2 + r2 };
        }
        static parse(e2, t2 = {}) {
          return new this(e2, new oe({ [this.type]: t2 }), e2).parse();
        }
        normalizeInput(e2) {
          return e2 instanceof I ? e2 : new I(e2);
        }
        constructor(e2, t2 = {}, i2) {
          f(this, "errors", []), f(this, "raw", /* @__PURE__ */ new Map()), f(this, "handleError", (e3) => {
            if (!this.options.silentErrors)
              throw e3;
            this.errors.push(e3.message);
          }), this.chunk = this.normalizeInput(e2), this.file = i2, this.type = this.constructor.type, this.globalOptions = this.options = t2, this.localOptions = t2[this.type], this.canTranslate = this.localOptions && this.localOptions.translate;
        }
        translate() {
          this.canTranslate && (this.translated = this.translateBlock(this.raw, this.type));
        }
        get output() {
          return this.translated ? this.translated : this.raw ? Object.fromEntries(this.raw) : void 0;
        }
        translateBlock(e2, t2) {
          let i2 = V.get(t2), n2 = G.get(t2), s2 = N.get(t2), r2 = this.options[t2], a2 = r2.reviveValues && !!i2, o2 = r2.translateValues && !!n2, l2 = r2.translateKeys && !!s2, h2 = {};
          for (let [t3, r3] of e2)
            a2 && i2.has(t3) ? r3 = i2.get(t3)(r3) : o2 && n2.has(t3) && (r3 = this.translateValue(r3, n2.get(t3))), l2 && s2.has(t3) && (t3 = s2.get(t3) || t3), h2[t3] = r3;
          return h2;
        }
        translateValue(e2, t2) {
          return t2[e2] || t2.DEFAULT || e2;
        }
        assignToOutput(e2, t2) {
          this.assignObjectToOutput(e2, this.constructor.type, t2);
        }
        assignObjectToOutput(e2, t2, i2) {
          if (this.globalOptions.mergeOutput)
            return Object.assign(e2, i2);
          e2[t2] ? Object.assign(e2[t2], i2) : e2[t2] = i2;
        }
      }
      __name(ge, "ge");
      f(ge, "headerLength", 4), f(ge, "type", void 0), f(ge, "multiSegment", false), f(ge, "canHandle", () => false);
      function me(e2) {
        return 192 === e2 || 194 === e2 || 196 === e2 || 219 === e2 || 221 === e2 || 218 === e2 || 254 === e2;
      }
      __name(me, "me");
      function Se(e2) {
        return e2 >= 224 && e2 <= 239;
      }
      __name(Se, "Se");
      function Ce(e2, t2, i2) {
        for (let [n2, s2] of A)
          if (s2.canHandle(e2, t2, i2))
            return n2;
      }
      __name(Ce, "Ce");
      class ye extends pe {
        constructor(...e2) {
          super(...e2), f(this, "appSegments", []), f(this, "jpegSegments", []), f(this, "unknownSegments", []);
        }
        static canHandle(e2, t2) {
          return 65496 === t2;
        }
        async parse() {
          await this.findAppSegments(), await this.readSegments(this.appSegments), this.mergeMultiSegments(), this.createParsers(this.mergedAppSegments || this.appSegments);
        }
        setupSegmentFinderArgs(e2) {
          true === e2 ? (this.findAll = true, this.wanted = new Set(A.keyList())) : (e2 = void 0 === e2 ? A.keyList().filter((e3) => this.options[e3].enabled) : e2.filter((e3) => this.options[e3].enabled && A.has(e3)), this.findAll = false, this.remaining = new Set(e2), this.wanted = new Set(e2)), this.unfinishedMultiSegment = false;
        }
        async findAppSegments(e2 = 0, t2) {
          this.setupSegmentFinderArgs(t2);
          let { file: i2, findAll: n2, wanted: s2, remaining: r2 } = this;
          if (!n2 && this.file.chunked && (n2 = Array.from(s2).some((e3) => {
            let t3 = A.get(e3), i3 = this.options[e3];
            return t3.multiSegment && i3.multiSegment;
          }), n2 && await this.file.readWhole()), e2 = this.findAppSegmentsInRange(e2, i2.byteLength), !this.options.onlyTiff && i2.chunked) {
            let t3 = false;
            for (; r2.size > 0 && !t3 && (i2.canReadNextChunk || this.unfinishedMultiSegment); ) {
              let { nextChunkOffset: n3 } = i2, s3 = this.appSegments.some((e3) => !this.file.available(e3.offset || e3.start, e3.length || e3.size));
              if (t3 = e2 > n3 && !s3 ? !await i2.readNextChunk(e2) : !await i2.readNextChunk(n3), void 0 === (e2 = this.findAppSegmentsInRange(e2, i2.byteLength)))
                return;
            }
          }
        }
        findAppSegmentsInRange(e2, t2) {
          t2 -= 2;
          let i2, n2, s2, r2, a2, o2, { file: l2, findAll: h2, wanted: u2, remaining: c2, options: f2 } = this;
          for (; e2 < t2; e2++)
            if (255 === l2.getUint8(e2)) {
              if (i2 = l2.getUint8(e2 + 1), Se(i2)) {
                if (n2 = l2.getUint16(e2 + 2), s2 = Ce(l2, e2, n2), s2 && u2.has(s2) && (r2 = A.get(s2), a2 = r2.findPosition(l2, e2), o2 = f2[s2], a2.type = s2, this.appSegments.push(a2), !h2 && (r2.multiSegment && o2.multiSegment ? (this.unfinishedMultiSegment = a2.chunkNumber < a2.chunkCount, this.unfinishedMultiSegment || c2.delete(s2)) : c2.delete(s2), 0 === c2.size)))
                  break;
                f2.recordUnknownSegments && (a2 = ge.findPosition(l2, e2), a2.marker = i2, this.unknownSegments.push(a2)), e2 += n2 + 1;
              } else if (me(i2)) {
                if (n2 = l2.getUint16(e2 + 2), 218 === i2 && false !== f2.stopAfterSos)
                  return;
                f2.recordJpegSegments && this.jpegSegments.push({ offset: e2, length: n2, marker: i2 }), e2 += n2 + 1;
              }
            }
          return e2;
        }
        mergeMultiSegments() {
          if (!this.appSegments.some((e3) => e3.multiSegment))
            return;
          let e2 = function(e3, t2) {
            let i2, n2, s2, r2 = /* @__PURE__ */ new Map();
            for (let a2 = 0; a2 < e3.length; a2++)
              i2 = e3[a2], n2 = i2[t2], r2.has(n2) ? s2 = r2.get(n2) : r2.set(n2, s2 = []), s2.push(i2);
            return Array.from(r2);
          }(this.appSegments, "type");
          this.mergedAppSegments = e2.map(([e3, t2]) => {
            let i2 = A.get(e3, this.options);
            if (i2.handleMultiSegments) {
              return { type: e3, chunk: i2.handleMultiSegments(t2) };
            }
            return t2[0];
          });
        }
        getSegment(e2) {
          return this.appSegments.find((t2) => t2.type === e2);
        }
        async getOrFindSegment(e2) {
          let t2 = this.getSegment(e2);
          return void 0 === t2 && (await this.findAppSegments(0, [e2]), t2 = this.getSegment(e2)), t2;
        }
      }
      __name(ye, "ye");
      f(ye, "type", "jpeg"), T.set("jpeg", ye);
      const be = [void 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, 4];
      class Pe extends ge {
        parseHeader() {
          var e2 = this.chunk.getUint16();
          18761 === e2 ? this.le = true : 19789 === e2 && (this.le = false), this.chunk.le = this.le, this.headerParsed = true;
        }
        parseTags(e2, t2, i2 = /* @__PURE__ */ new Map()) {
          let { pick: n2, skip: s2 } = this.options[t2];
          n2 = new Set(n2);
          let r2 = n2.size > 0, a2 = 0 === s2.size, o2 = this.chunk.getUint16(e2);
          e2 += 2;
          for (let l2 = 0; l2 < o2; l2++) {
            let o3 = this.chunk.getUint16(e2);
            if (r2) {
              if (n2.has(o3) && (i2.set(o3, this.parseTag(e2, o3, t2)), n2.delete(o3), 0 === n2.size))
                break;
            } else
              !a2 && s2.has(o3) || i2.set(o3, this.parseTag(e2, o3, t2));
            e2 += 12;
          }
          return i2;
        }
        parseTag(e2, t2, i2) {
          let { chunk: n2 } = this, s2 = n2.getUint16(e2 + 2), r2 = n2.getUint32(e2 + 4), a2 = be[s2];
          if (a2 * r2 <= 4 ? e2 += 8 : e2 = n2.getUint32(e2 + 8), (s2 < 1 || s2 > 13) && m(`Invalid TIFF value type. block: ${i2.toUpperCase()}, tag: ${t2.toString(16)}, type: ${s2}, offset ${e2}`), e2 > n2.byteLength && m(`Invalid TIFF value offset. block: ${i2.toUpperCase()}, tag: ${t2.toString(16)}, type: ${s2}, offset ${e2} is outside of chunk size ${n2.byteLength}`), 1 === s2)
            return n2.getUint8Array(e2, r2);
          if (2 === s2)
            return S(n2.getString(e2, r2));
          if (7 === s2)
            return n2.getUint8Array(e2, r2);
          if (1 === r2)
            return this.parseTagValue(s2, e2);
          {
            let t3 = new (function(e3) {
              switch (e3) {
                case 1:
                  return Uint8Array;
                case 3:
                  return Uint16Array;
                case 4:
                  return Uint32Array;
                case 5:
                  return Array;
                case 6:
                  return Int8Array;
                case 8:
                  return Int16Array;
                case 9:
                  return Int32Array;
                case 10:
                  return Array;
                case 11:
                  return Float32Array;
                case 12:
                  return Float64Array;
                default:
                  return Array;
              }
            }(s2))(r2), i3 = a2;
            for (let n3 = 0; n3 < r2; n3++)
              t3[n3] = this.parseTagValue(s2, e2), e2 += i3;
            return t3;
          }
        }
        parseTagValue(e2, t2) {
          let { chunk: i2 } = this;
          switch (e2) {
            case 1:
              return i2.getUint8(t2);
            case 3:
              return i2.getUint16(t2);
            case 4:
              return i2.getUint32(t2);
            case 5:
              return i2.getUint32(t2) / i2.getUint32(t2 + 4);
            case 6:
              return i2.getInt8(t2);
            case 8:
              return i2.getInt16(t2);
            case 9:
              return i2.getInt32(t2);
            case 10:
              return i2.getInt32(t2) / i2.getInt32(t2 + 4);
            case 11:
              return i2.getFloat(t2);
            case 12:
              return i2.getDouble(t2);
            case 13:
              return i2.getUint32(t2);
            default:
              m(`Invalid tiff type ${e2}`);
          }
        }
      }
      __name(Pe, "Pe");
      class Ie extends Pe {
        static canHandle(e2, t2) {
          return 225 === e2.getUint8(t2 + 1) && 1165519206 === e2.getUint32(t2 + 4) && 0 === e2.getUint16(t2 + 8);
        }
        async parse() {
          this.parseHeader();
          let { options: e2 } = this;
          return e2.ifd0.enabled && await this.parseIfd0Block(), e2.exif.enabled && await this.safeParse("parseExifBlock"), e2.gps.enabled && await this.safeParse("parseGpsBlock"), e2.interop.enabled && await this.safeParse("parseInteropBlock"), e2.ifd1.enabled && await this.safeParse("parseThumbnailBlock"), this.createOutput();
        }
        safeParse(e2) {
          let t2 = this[e2]();
          return void 0 !== t2.catch && (t2 = t2.catch(this.handleError)), t2;
        }
        findIfd0Offset() {
          void 0 === this.ifd0Offset && (this.ifd0Offset = this.chunk.getUint32(4));
        }
        findIfd1Offset() {
          if (void 0 === this.ifd1Offset) {
            this.findIfd0Offset();
            let e2 = this.chunk.getUint16(this.ifd0Offset), t2 = this.ifd0Offset + 2 + 12 * e2;
            this.ifd1Offset = this.chunk.getUint32(t2);
          }
        }
        parseBlock(e2, t2) {
          let i2 = /* @__PURE__ */ new Map();
          return this[t2] = i2, this.parseTags(e2, t2, i2), i2;
        }
        async parseIfd0Block() {
          if (this.ifd0)
            return;
          let { file: e2 } = this;
          this.findIfd0Offset(), this.ifd0Offset < 8 && m("Malformed EXIF data"), !e2.chunked && this.ifd0Offset > e2.byteLength && m(`IFD0 offset points to outside of file.
this.ifd0Offset: ${this.ifd0Offset}, file.byteLength: ${e2.byteLength}`), e2.tiff && await e2.ensureChunk(this.ifd0Offset, C(this.options));
          let t2 = this.parseBlock(this.ifd0Offset, "ifd0");
          return 0 !== t2.size ? (this.exifOffset = t2.get(X), this.interopOffset = t2.get(Y), this.gpsOffset = t2.get(_), this.xmp = t2.get(j), this.iptc = t2.get(W), this.icc = t2.get(K), this.options.sanitize && (t2.delete(X), t2.delete(Y), t2.delete(_), t2.delete(j), t2.delete(W), t2.delete(K)), t2) : void 0;
        }
        async parseExifBlock() {
          if (this.exif)
            return;
          if (this.ifd0 || await this.parseIfd0Block(), void 0 === this.exifOffset)
            return;
          this.file.tiff && await this.file.ensureChunk(this.exifOffset, C(this.options));
          let e2 = this.parseBlock(this.exifOffset, "exif");
          return this.interopOffset || (this.interopOffset = e2.get(Y)), this.makerNote = e2.get(z), this.userComment = e2.get(H), this.options.sanitize && (e2.delete(Y), e2.delete(z), e2.delete(H)), this.unpack(e2, 41728), this.unpack(e2, 41729), e2;
        }
        unpack(e2, t2) {
          let i2 = e2.get(t2);
          i2 && 1 === i2.length && e2.set(t2, i2[0]);
        }
        async parseGpsBlock() {
          if (this.gps)
            return;
          if (this.ifd0 || await this.parseIfd0Block(), void 0 === this.gpsOffset)
            return;
          let e2 = this.parseBlock(this.gpsOffset, "gps");
          return e2 && e2.has(2) && e2.has(4) && (e2.set("latitude", ke(...e2.get(2), e2.get(1))), e2.set("longitude", ke(...e2.get(4), e2.get(3)))), e2;
        }
        async parseInteropBlock() {
          if (!this.interop && (this.ifd0 || await this.parseIfd0Block(), void 0 !== this.interopOffset || this.exif || await this.parseExifBlock(), void 0 !== this.interopOffset))
            return this.parseBlock(this.interopOffset, "interop");
        }
        async parseThumbnailBlock(e2 = false) {
          if (!this.ifd1 && !this.ifd1Parsed && (!this.options.mergeOutput || e2))
            return this.findIfd1Offset(), this.ifd1Offset > 0 && (this.parseBlock(this.ifd1Offset, "ifd1"), this.ifd1Parsed = true), this.ifd1;
        }
        async extractThumbnail() {
          if (this.headerParsed || this.parseHeader(), this.ifd1Parsed || await this.parseThumbnailBlock(true), void 0 === this.ifd1)
            return;
          let e2 = this.ifd1.get(513), t2 = this.ifd1.get(514);
          return this.chunk.getUint8Array(e2, t2);
        }
        get image() {
          return this.ifd0;
        }
        get thumbnail() {
          return this.ifd1;
        }
        createOutput() {
          let e2, t2, i2, n2 = {};
          for (t2 of Q)
            if (e2 = this[t2], !g(e2))
              if (i2 = this.canTranslate ? this.translateBlock(e2, t2) : Object.fromEntries(e2), this.options.mergeOutput) {
                if ("ifd1" === t2)
                  continue;
                Object.assign(n2, i2);
              } else
                n2[t2] = i2;
          return this.makerNote && (n2.makerNote = this.makerNote), this.userComment && (n2.userComment = this.userComment), n2;
        }
        assignToOutput(e2, t2) {
          if (this.globalOptions.mergeOutput)
            Object.assign(e2, t2);
          else
            for (let [i2, n2] of Object.entries(t2))
              this.assignObjectToOutput(e2, i2, n2);
        }
      }
      __name(Ie, "Ie");
      function ke(e2, t2, i2, n2) {
        var s2 = e2 + t2 / 60 + i2 / 3600;
        return "S" !== n2 && "W" !== n2 || (s2 *= -1), s2;
      }
      __name(ke, "ke");
      f(Ie, "type", "tiff"), f(Ie, "headerLength", 10), A.set("tiff", Ie);
      var we = Object.freeze({ __proto__: null, default: de, Exifr: ce, fileParsers: T, segmentParsers: A, fileReaders: D, tagKeys: N, tagValues: G, tagRevivers: V, createDictionary: B, extendDictionary: E, fetchUrlAsArrayBuffer: L, readBlobAsArrayBuffer: U, chunkedProps: $, otherSegments: J, segments: q, tiffBlocks: Q, segmentsAndBlocks: Z, tiffExtractables: ee, inheritables: te, allFormatters: ie, Options: oe, parse: fe });
      const Te = { ifd0: false, ifd1: false, exif: false, gps: false, interop: false, sanitize: false, reviveValues: true, translateKeys: false, translateValues: false, mergeOutput: false }, Ae = Object.assign({}, Te, { firstChunkSize: 4e4, gps: [1, 2, 3, 4] });
      async function De(e2) {
        let t2 = new ce(Ae);
        await t2.read(e2);
        let i2 = await t2.parse();
        if (i2 && i2.gps) {
          let { latitude: e3, longitude: t3 } = i2.gps;
          return { latitude: e3, longitude: t3 };
        }
      }
      __name(De, "De");
      const Oe = Object.assign({}, Te, { tiff: false, ifd1: true, mergeOutput: false });
      async function xe(e2) {
        let t2 = new ce(Oe);
        await t2.read(e2);
        let i2 = await t2.extractThumbnail();
        return i2 && o ? r.from(i2) : i2;
      }
      __name(xe, "xe");
      async function ve(e2) {
        let t2 = await this.thumbnail(e2);
        if (void 0 !== t2) {
          let e3 = new Blob([t2]);
          return URL.createObjectURL(e3);
        }
      }
      __name(ve, "ve");
      const Me = Object.assign({}, Te, { firstChunkSize: 4e4, ifd0: [274] });
      async function Re(e2) {
        let t2 = new ce(Me);
        await t2.read(e2);
        let i2 = await t2.parse();
        if (i2 && i2.ifd0)
          return i2.ifd0[274];
      }
      __name(Re, "Re");
      const Le = Object.freeze({ 1: { dimensionSwapped: false, scaleX: 1, scaleY: 1, deg: 0, rad: 0 }, 2: { dimensionSwapped: false, scaleX: -1, scaleY: 1, deg: 0, rad: 0 }, 3: { dimensionSwapped: false, scaleX: 1, scaleY: 1, deg: 180, rad: 180 * Math.PI / 180 }, 4: { dimensionSwapped: false, scaleX: -1, scaleY: 1, deg: 180, rad: 180 * Math.PI / 180 }, 5: { dimensionSwapped: true, scaleX: 1, scaleY: -1, deg: 90, rad: 90 * Math.PI / 180 }, 6: { dimensionSwapped: true, scaleX: 1, scaleY: 1, deg: 90, rad: 90 * Math.PI / 180 }, 7: { dimensionSwapped: true, scaleX: 1, scaleY: -1, deg: 270, rad: 270 * Math.PI / 180 }, 8: { dimensionSwapped: true, scaleX: 1, scaleY: 1, deg: 270, rad: 270 * Math.PI / 180 } });
      if (e.rotateCanvas = true, e.rotateCss = true, "object" == typeof navigator) {
        let t2 = navigator.userAgent;
        if (t2.includes("iPad") || t2.includes("iPhone")) {
          let i2 = t2.match(/OS (\d+)_(\d+)/);
          if (i2) {
            let [, t3, n2] = i2, s2 = Number(t3) + 0.1 * Number(n2);
            e.rotateCanvas = s2 < 13.4, e.rotateCss = false;
          }
        } else if (t2.includes("OS X 10")) {
          let [, i2] = t2.match(/OS X 10[_.](\d+)/);
          e.rotateCanvas = e.rotateCss = Number(i2) < 15;
        }
        if (t2.includes("Chrome/")) {
          let [, i2] = t2.match(/Chrome\/(\d+)/);
          e.rotateCanvas = e.rotateCss = Number(i2) < 81;
        } else if (t2.includes("Firefox/")) {
          let [, i2] = t2.match(/Firefox\/(\d+)/);
          e.rotateCanvas = e.rotateCss = Number(i2) < 77;
        }
      }
      async function Ue(t2) {
        let i2 = await Re(t2);
        return Object.assign({ canvas: e.rotateCanvas, css: e.rotateCss }, Le[i2]);
      }
      __name(Ue, "Ue");
      class Fe extends I {
        constructor(...e2) {
          super(...e2), f(this, "ranges", new Be()), 0 !== this.byteLength && this.ranges.add(0, this.byteLength);
        }
        _tryExtend(e2, t2, i2) {
          if (0 === e2 && 0 === this.byteLength && i2) {
            let e3 = new DataView(i2.buffer || i2, i2.byteOffset, i2.byteLength);
            this._swapDataView(e3);
          } else {
            let i3 = e2 + t2;
            if (i3 > this.byteLength) {
              let { dataView: e3 } = this._extend(i3);
              this._swapDataView(e3);
            }
          }
        }
        _extend(e2) {
          let t2;
          t2 = o ? r.allocUnsafe(e2) : new Uint8Array(e2);
          let i2 = new DataView(t2.buffer, t2.byteOffset, t2.byteLength);
          return t2.set(new Uint8Array(this.buffer, this.byteOffset, this.byteLength), 0), { uintView: t2, dataView: i2 };
        }
        subarray(e2, t2, i2 = false) {
          return t2 = t2 || this._lengthToEnd(e2), i2 && this._tryExtend(e2, t2), this.ranges.add(e2, t2), super.subarray(e2, t2);
        }
        set(e2, t2, i2 = false) {
          i2 && this._tryExtend(t2, e2.byteLength, e2);
          let n2 = super.set(e2, t2);
          return this.ranges.add(t2, n2.byteLength), n2;
        }
        async ensureChunk(e2, t2) {
          this.chunked && (this.ranges.available(e2, t2) || await this.readChunk(e2, t2));
        }
        available(e2, t2) {
          return this.ranges.available(e2, t2);
        }
      }
      __name(Fe, "Fe");
      class Be {
        constructor() {
          f(this, "list", []);
        }
        get length() {
          return this.list.length;
        }
        add(e2, t2, i2 = 0) {
          let n2 = e2 + t2, s2 = this.list.filter((t3) => Ee(e2, t3.offset, n2) || Ee(e2, t3.end, n2));
          if (s2.length > 0) {
            e2 = Math.min(e2, ...s2.map((e3) => e3.offset)), n2 = Math.max(n2, ...s2.map((e3) => e3.end)), t2 = n2 - e2;
            let i3 = s2.shift();
            i3.offset = e2, i3.length = t2, i3.end = n2, this.list = this.list.filter((e3) => !s2.includes(e3));
          } else
            this.list.push({ offset: e2, length: t2, end: n2 });
        }
        available(e2, t2) {
          let i2 = e2 + t2;
          return this.list.some((t3) => t3.offset <= e2 && i2 <= t3.end);
        }
      }
      __name(Be, "Be");
      function Ee(e2, t2, i2) {
        return e2 <= t2 && t2 <= i2;
      }
      __name(Ee, "Ee");
      class Ne extends Fe {
        constructor(e2, t2) {
          super(0), f(this, "chunksRead", 0), this.input = e2, this.options = t2;
        }
        async readWhole() {
          this.chunked = false, await this.readChunk(this.nextChunkOffset);
        }
        async readChunked() {
          this.chunked = true, await this.readChunk(0, this.options.firstChunkSize);
        }
        async readNextChunk(e2 = this.nextChunkOffset) {
          if (this.fullyRead)
            return this.chunksRead++, false;
          let t2 = this.options.chunkSize, i2 = await this.readChunk(e2, t2);
          return !!i2 && i2.byteLength === t2;
        }
        async readChunk(e2, t2) {
          if (this.chunksRead++, 0 !== (t2 = this.safeWrapAddress(e2, t2)))
            return this._readChunk(e2, t2);
        }
        safeWrapAddress(e2, t2) {
          return void 0 !== this.size && e2 + t2 > this.size ? Math.max(0, this.size - e2) : t2;
        }
        get nextChunkOffset() {
          if (0 !== this.ranges.list.length)
            return this.ranges.list[0].length;
        }
        get canReadNextChunk() {
          return this.chunksRead < this.options.chunkLimit;
        }
        get fullyRead() {
          return void 0 !== this.size && this.nextChunkOffset === this.size;
        }
        read() {
          return this.options.chunked ? this.readChunked() : this.readWhole();
        }
        close() {
        }
      }
      __name(Ne, "Ne");
      D.set("blob", class extends Ne {
        async readWhole() {
          this.chunked = false;
          let e2 = await U(this.input);
          this._swapArrayBuffer(e2);
        }
        readChunked() {
          return this.chunked = true, this.size = this.input.size, super.readChunked();
        }
        async _readChunk(e2, t2) {
          let i2 = t2 ? e2 + t2 : void 0, n2 = this.input.slice(e2, i2), s2 = await U(n2);
          return this.set(s2, e2, true);
        }
      });
      var Ge = Object.freeze({ __proto__: null, default: we, Exifr: ce, fileParsers: T, segmentParsers: A, fileReaders: D, tagKeys: N, tagValues: G, tagRevivers: V, createDictionary: B, extendDictionary: E, fetchUrlAsArrayBuffer: L, readBlobAsArrayBuffer: U, chunkedProps: $, otherSegments: J, segments: q, tiffBlocks: Q, segmentsAndBlocks: Z, tiffExtractables: ee, inheritables: te, allFormatters: ie, Options: oe, parse: fe, gpsOnlyOptions: Ae, gps: De, thumbnailOnlyOptions: Oe, thumbnail: xe, thumbnailUrl: ve, orientationOnlyOptions: Me, orientation: Re, rotations: Le, get rotateCanvas() {
        return e.rotateCanvas;
      }, get rotateCss() {
        return e.rotateCss;
      }, rotation: Ue });
      D.set("url", class extends Ne {
        async readWhole() {
          this.chunked = false;
          let e2 = await L(this.input);
          e2 instanceof ArrayBuffer ? this._swapArrayBuffer(e2) : e2 instanceof Uint8Array && this._swapBuffer(e2);
        }
        async _readChunk(e2, t2) {
          let i2 = t2 ? e2 + t2 - 1 : void 0, n2 = this.options.httpHeaders || {};
          (e2 || i2) && (n2.range = `bytes=${[e2, i2].join("-")}`);
          let s2 = await u(this.input, { headers: n2 }), r2 = await s2.arrayBuffer(), a2 = r2.byteLength;
          if (416 !== s2.status)
            return a2 !== t2 && (this.size = e2 + a2), this.set(r2, e2, true);
        }
      });
      I.prototype.getUint64 = function(e2) {
        let t2 = this.getUint32(e2), i2 = this.getUint32(e2 + 4);
        return t2 < 1048575 ? t2 << 32 | i2 : void 0 !== typeof a ? (console.warn("Using BigInt because of type 64uint but JS can only handle 53b numbers."), a(t2) << a(32) | a(i2)) : void m("Trying to read 64b value but JS can only handle 53b numbers.");
      };
      class Ve extends pe {
        parseBoxes(e2 = 0) {
          let t2 = [];
          for (; e2 < this.file.byteLength - 4; ) {
            let i2 = this.parseBoxHead(e2);
            if (t2.push(i2), 0 === i2.length)
              break;
            e2 += i2.length;
          }
          return t2;
        }
        parseSubBoxes(e2) {
          e2.boxes = this.parseBoxes(e2.start);
        }
        findBox(e2, t2) {
          return void 0 === e2.boxes && this.parseSubBoxes(e2), e2.boxes.find((e3) => e3.kind === t2);
        }
        parseBoxHead(e2) {
          let t2 = this.file.getUint32(e2), i2 = this.file.getString(e2 + 4, 4), n2 = e2 + 8;
          return 1 === t2 && (t2 = this.file.getUint64(e2 + 8), n2 += 8), { offset: e2, length: t2, kind: i2, start: n2 };
        }
        parseBoxFullHead(e2) {
          if (void 0 !== e2.version)
            return;
          let t2 = this.file.getUint32(e2.start);
          e2.version = t2 >> 24, e2.start += 4;
        }
      }
      __name(Ve, "Ve");
      class ze extends Ve {
        static canHandle(e2, t2) {
          if (0 !== t2)
            return false;
          let i2 = e2.getUint16(2);
          if (i2 > 50)
            return false;
          let n2 = 16, s2 = [];
          for (; n2 < i2; )
            s2.push(e2.getString(n2, 4)), n2 += 4;
          return s2.includes(this.type);
        }
        async parse() {
          let e2 = this.file.getUint32(0), t2 = this.parseBoxHead(e2);
          for (; "meta" !== t2.kind; )
            e2 += t2.length, await this.file.ensureChunk(e2, 16), t2 = this.parseBoxHead(e2);
          await this.file.ensureChunk(t2.offset, t2.length), this.parseBoxFullHead(t2), this.parseSubBoxes(t2), this.options.icc.enabled && await this.findIcc(t2), this.options.tiff.enabled && await this.findExif(t2);
        }
        async registerSegment(e2, t2, i2) {
          await this.file.ensureChunk(t2, i2);
          let n2 = this.file.subarray(t2, i2);
          this.createParser(e2, n2);
        }
        async findIcc(e2) {
          let t2 = this.findBox(e2, "iprp");
          if (void 0 === t2)
            return;
          let i2 = this.findBox(t2, "ipco");
          if (void 0 === i2)
            return;
          let n2 = this.findBox(i2, "colr");
          void 0 !== n2 && await this.registerSegment("icc", n2.offset + 12, n2.length);
        }
        async findExif(e2) {
          let t2 = this.findBox(e2, "iinf");
          if (void 0 === t2)
            return;
          let i2 = this.findBox(e2, "iloc");
          if (void 0 === i2)
            return;
          let n2 = this.findExifLocIdInIinf(t2), s2 = this.findExtentInIloc(i2, n2);
          if (void 0 === s2)
            return;
          let [r2, a2] = s2;
          await this.file.ensureChunk(r2, a2);
          let o2 = 4 + this.file.getUint32(r2);
          r2 += o2, a2 -= o2, await this.registerSegment("tiff", r2, a2);
        }
        findExifLocIdInIinf(e2) {
          this.parseBoxFullHead(e2);
          let t2, i2, n2, s2, r2 = e2.start, a2 = this.file.getUint16(r2);
          for (r2 += 2; a2--; ) {
            if (t2 = this.parseBoxHead(r2), this.parseBoxFullHead(t2), i2 = t2.start, t2.version >= 2 && (n2 = 3 === t2.version ? 4 : 2, s2 = this.file.getString(i2 + n2 + 2, 4), "Exif" === s2))
              return this.file.getUintBytes(i2, n2);
            r2 += t2.length;
          }
        }
        get8bits(e2) {
          let t2 = this.file.getUint8(e2);
          return [t2 >> 4, 15 & t2];
        }
        findExtentInIloc(e2, t2) {
          this.parseBoxFullHead(e2);
          let i2 = e2.start, [n2, s2] = this.get8bits(i2++), [r2, a2] = this.get8bits(i2++), o2 = 2 === e2.version ? 4 : 2, l2 = 1 === e2.version || 2 === e2.version ? 2 : 0, h2 = a2 + n2 + s2, u2 = 2 === e2.version ? 4 : 2, c2 = this.file.getUintBytes(i2, u2);
          for (i2 += u2; c2--; ) {
            let e3 = this.file.getUintBytes(i2, o2);
            i2 += o2 + l2 + 2 + r2;
            let u3 = this.file.getUint16(i2);
            if (i2 += 2, e3 === t2)
              return u3 > 1 && console.warn("ILOC box has more than one extent but we're only processing one\nPlease create an issue at https://github.com/MikeKovarik/exifr with this file"), [this.file.getUintBytes(i2 + a2, n2), this.file.getUintBytes(i2 + a2 + n2, s2)];
            i2 += u3 * h2;
          }
        }
      }
      __name(ze, "ze");
      class He extends ze {
      }
      __name(He, "He");
      f(He, "type", "heic");
      class je extends ze {
      }
      __name(je, "je");
      f(je, "type", "avif"), T.set("heic", He), T.set("avif", je), B(N, ["ifd0", "ifd1"], [[256, "ImageWidth"], [257, "ImageHeight"], [258, "BitsPerSample"], [259, "Compression"], [262, "PhotometricInterpretation"], [270, "ImageDescription"], [271, "Make"], [272, "Model"], [273, "StripOffsets"], [274, "Orientation"], [277, "SamplesPerPixel"], [278, "RowsPerStrip"], [279, "StripByteCounts"], [282, "XResolution"], [283, "YResolution"], [284, "PlanarConfiguration"], [296, "ResolutionUnit"], [301, "TransferFunction"], [305, "Software"], [306, "ModifyDate"], [315, "Artist"], [316, "HostComputer"], [317, "Predictor"], [318, "WhitePoint"], [319, "PrimaryChromaticities"], [513, "ThumbnailOffset"], [514, "ThumbnailLength"], [529, "YCbCrCoefficients"], [530, "YCbCrSubSampling"], [531, "YCbCrPositioning"], [532, "ReferenceBlackWhite"], [700, "ApplicationNotes"], [33432, "Copyright"], [33723, "IPTC"], [34665, "ExifIFD"], [34675, "ICC"], [34853, "GpsIFD"], [330, "SubIFD"], [40965, "InteropIFD"], [40091, "XPTitle"], [40092, "XPComment"], [40093, "XPAuthor"], [40094, "XPKeywords"], [40095, "XPSubject"]]), B(N, "exif", [[33434, "ExposureTime"], [33437, "FNumber"], [34850, "ExposureProgram"], [34852, "SpectralSensitivity"], [34855, "ISO"], [34858, "TimeZoneOffset"], [34859, "SelfTimerMode"], [34864, "SensitivityType"], [34865, "StandardOutputSensitivity"], [34866, "RecommendedExposureIndex"], [34867, "ISOSpeed"], [34868, "ISOSpeedLatitudeyyy"], [34869, "ISOSpeedLatitudezzz"], [36864, "ExifVersion"], [36867, "DateTimeOriginal"], [36868, "CreateDate"], [36873, "GooglePlusUploadCode"], [36880, "OffsetTime"], [36881, "OffsetTimeOriginal"], [36882, "OffsetTimeDigitized"], [37121, "ComponentsConfiguration"], [37122, "CompressedBitsPerPixel"], [37377, "ShutterSpeedValue"], [37378, "ApertureValue"], [37379, "BrightnessValue"], [37380, "ExposureCompensation"], [37381, "MaxApertureValue"], [37382, "SubjectDistance"], [37383, "MeteringMode"], [37384, "LightSource"], [37385, "Flash"], [37386, "FocalLength"], [37393, "ImageNumber"], [37394, "SecurityClassification"], [37395, "ImageHistory"], [37396, "SubjectArea"], [37500, "MakerNote"], [37510, "UserComment"], [37520, "SubSecTime"], [37521, "SubSecTimeOriginal"], [37522, "SubSecTimeDigitized"], [37888, "AmbientTemperature"], [37889, "Humidity"], [37890, "Pressure"], [37891, "WaterDepth"], [37892, "Acceleration"], [37893, "CameraElevationAngle"], [40960, "FlashpixVersion"], [40961, "ColorSpace"], [40962, "ExifImageWidth"], [40963, "ExifImageHeight"], [40964, "RelatedSoundFile"], [41483, "FlashEnergy"], [41486, "FocalPlaneXResolution"], [41487, "FocalPlaneYResolution"], [41488, "FocalPlaneResolutionUnit"], [41492, "SubjectLocation"], [41493, "ExposureIndex"], [41495, "SensingMethod"], [41728, "FileSource"], [41729, "SceneType"], [41730, "CFAPattern"], [41985, "CustomRendered"], [41986, "ExposureMode"], [41987, "WhiteBalance"], [41988, "DigitalZoomRatio"], [41989, "FocalLengthIn35mmFormat"], [41990, "SceneCaptureType"], [41991, "GainControl"], [41992, "Contrast"], [41993, "Saturation"], [41994, "Sharpness"], [41996, "SubjectDistanceRange"], [42016, "ImageUniqueID"], [42032, "OwnerName"], [42033, "SerialNumber"], [42034, "LensInfo"], [42035, "LensMake"], [42036, "LensModel"], [42037, "LensSerialNumber"], [42080, "CompositeImage"], [42081, "CompositeImageCount"], [42082, "CompositeImageExposureTimes"], [42240, "Gamma"], [59932, "Padding"], [59933, "OffsetSchema"], [65e3, "OwnerName"], [65001, "SerialNumber"], [65002, "Lens"], [65100, "RawFile"], [65101, "Converter"], [65102, "WhiteBalance"], [65105, "Exposure"], [65106, "Shadows"], [65107, "Brightness"], [65108, "Contrast"], [65109, "Saturation"], [65110, "Sharpness"], [65111, "Smoothness"], [65112, "MoireFilter"], [40965, "InteropIFD"]]), B(N, "gps", [[0, "GPSVersionID"], [1, "GPSLatitudeRef"], [2, "GPSLatitude"], [3, "GPSLongitudeRef"], [4, "GPSLongitude"], [5, "GPSAltitudeRef"], [6, "GPSAltitude"], [7, "GPSTimeStamp"], [8, "GPSSatellites"], [9, "GPSStatus"], [10, "GPSMeasureMode"], [11, "GPSDOP"], [12, "GPSSpeedRef"], [13, "GPSSpeed"], [14, "GPSTrackRef"], [15, "GPSTrack"], [16, "GPSImgDirectionRef"], [17, "GPSImgDirection"], [18, "GPSMapDatum"], [19, "GPSDestLatitudeRef"], [20, "GPSDestLatitude"], [21, "GPSDestLongitudeRef"], [22, "GPSDestLongitude"], [23, "GPSDestBearingRef"], [24, "GPSDestBearing"], [25, "GPSDestDistanceRef"], [26, "GPSDestDistance"], [27, "GPSProcessingMethod"], [28, "GPSAreaInformation"], [29, "GPSDateStamp"], [30, "GPSDifferential"], [31, "GPSHPositioningError"]]), B(G, ["ifd0", "ifd1"], [[274, { 1: "Horizontal (normal)", 2: "Mirror horizontal", 3: "Rotate 180", 4: "Mirror vertical", 5: "Mirror horizontal and rotate 270 CW", 6: "Rotate 90 CW", 7: "Mirror horizontal and rotate 90 CW", 8: "Rotate 270 CW" }], [296, { 1: "None", 2: "inches", 3: "cm" }]]);
      let We = B(G, "exif", [[34850, { 0: "Not defined", 1: "Manual", 2: "Normal program", 3: "Aperture priority", 4: "Shutter priority", 5: "Creative program", 6: "Action program", 7: "Portrait mode", 8: "Landscape mode" }], [37121, { 0: "-", 1: "Y", 2: "Cb", 3: "Cr", 4: "R", 5: "G", 6: "B" }], [37383, { 0: "Unknown", 1: "Average", 2: "CenterWeightedAverage", 3: "Spot", 4: "MultiSpot", 5: "Pattern", 6: "Partial", 255: "Other" }], [37384, { 0: "Unknown", 1: "Daylight", 2: "Fluorescent", 3: "Tungsten (incandescent light)", 4: "Flash", 9: "Fine weather", 10: "Cloudy weather", 11: "Shade", 12: "Daylight fluorescent (D 5700 - 7100K)", 13: "Day white fluorescent (N 4600 - 5400K)", 14: "Cool white fluorescent (W 3900 - 4500K)", 15: "White fluorescent (WW 3200 - 3700K)", 17: "Standard light A", 18: "Standard light B", 19: "Standard light C", 20: "D55", 21: "D65", 22: "D75", 23: "D50", 24: "ISO studio tungsten", 255: "Other" }], [37385, { 0: "Flash did not fire", 1: "Flash fired", 5: "Strobe return light not detected", 7: "Strobe return light detected", 9: "Flash fired, compulsory flash mode", 13: "Flash fired, compulsory flash mode, return light not detected", 15: "Flash fired, compulsory flash mode, return light detected", 16: "Flash did not fire, compulsory flash mode", 24: "Flash did not fire, auto mode", 25: "Flash fired, auto mode", 29: "Flash fired, auto mode, return light not detected", 31: "Flash fired, auto mode, return light detected", 32: "No flash function", 65: "Flash fired, red-eye reduction mode", 69: "Flash fired, red-eye reduction mode, return light not detected", 71: "Flash fired, red-eye reduction mode, return light detected", 73: "Flash fired, compulsory flash mode, red-eye reduction mode", 77: "Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected", 79: "Flash fired, compulsory flash mode, red-eye reduction mode, return light detected", 89: "Flash fired, auto mode, red-eye reduction mode", 93: "Flash fired, auto mode, return light not detected, red-eye reduction mode", 95: "Flash fired, auto mode, return light detected, red-eye reduction mode" }], [41495, { 1: "Not defined", 2: "One-chip color area sensor", 3: "Two-chip color area sensor", 4: "Three-chip color area sensor", 5: "Color sequential area sensor", 7: "Trilinear sensor", 8: "Color sequential linear sensor" }], [41728, { 1: "Film Scanner", 2: "Reflection Print Scanner", 3: "Digital Camera" }], [41729, { 1: "Directly photographed" }], [41985, { 0: "Normal", 1: "Custom", 2: "HDR (no original saved)", 3: "HDR (original saved)", 4: "Original (for HDR)", 6: "Panorama", 7: "Portrait HDR", 8: "Portrait" }], [41986, { 0: "Auto", 1: "Manual", 2: "Auto bracket" }], [41987, { 0: "Auto", 1: "Manual" }], [41990, { 0: "Standard", 1: "Landscape", 2: "Portrait", 3: "Night", 4: "Other" }], [41991, { 0: "None", 1: "Low gain up", 2: "High gain up", 3: "Low gain down", 4: "High gain down" }], [41996, { 0: "Unknown", 1: "Macro", 2: "Close", 3: "Distant" }], [42080, { 0: "Unknown", 1: "Not a Composite Image", 2: "General Composite Image", 3: "Composite Image Captured While Shooting" }]]);
      const Ke = { 1: "No absolute unit of measurement", 2: "Inch", 3: "Centimeter" };
      We.set(37392, Ke), We.set(41488, Ke);
      const Xe = { 0: "Normal", 1: "Low", 2: "High" };
      function _e(e2) {
        return "object" == typeof e2 && void 0 !== e2.length ? e2[0] : e2;
      }
      __name(_e, "_e");
      function Ye(e2) {
        let t2 = Array.from(e2).slice(1);
        return t2[1] > 15 && (t2 = t2.map((e3) => String.fromCharCode(e3))), "0" !== t2[2] && 0 !== t2[2] || t2.pop(), t2.join(".");
      }
      __name(Ye, "Ye");
      function $e(e2) {
        if ("string" == typeof e2) {
          var [t2, i2, n2, s2, r2, a2] = e2.trim().split(/[-: ]/g).map(Number), o2 = new Date(t2, i2 - 1, n2);
          return Number.isNaN(s2) || Number.isNaN(r2) || Number.isNaN(a2) || (o2.setHours(s2), o2.setMinutes(r2), o2.setSeconds(a2)), Number.isNaN(+o2) ? e2 : o2;
        }
      }
      __name($e, "$e");
      function Je(e2) {
        if ("string" == typeof e2)
          return e2;
        let t2 = [];
        if (0 === e2[1] && 0 === e2[e2.length - 1])
          for (let i2 = 0; i2 < e2.length; i2 += 2)
            t2.push(qe(e2[i2 + 1], e2[i2]));
        else
          for (let i2 = 0; i2 < e2.length; i2 += 2)
            t2.push(qe(e2[i2], e2[i2 + 1]));
        return S(String.fromCodePoint(...t2));
      }
      __name(Je, "Je");
      function qe(e2, t2) {
        return e2 << 8 | t2;
      }
      __name(qe, "qe");
      We.set(41992, Xe), We.set(41993, Xe), We.set(41994, Xe), B(V, ["ifd0", "ifd1"], [[50827, function(e2) {
        return "string" != typeof e2 ? P(e2) : e2;
      }], [306, $e], [40091, Je], [40092, Je], [40093, Je], [40094, Je], [40095, Je]]), B(V, "exif", [[40960, Ye], [36864, Ye], [36867, $e], [36868, $e], [40962, _e], [40963, _e]]), B(V, "gps", [[0, (e2) => Array.from(e2).join(".")], [7, (e2) => Array.from(e2).join(":")]]);
      const Qe = "http://ns.adobe.com/", Ze = "http://ns.adobe.com/xmp/extension/";
      class et extends ge {
        static canHandle(e2, t2) {
          return 225 === e2.getUint8(t2 + 1) && 1752462448 === e2.getUint32(t2 + 4) && e2.getString(t2 + 4, Qe.length) === Qe;
        }
        static headerLength(e2, t2) {
          return e2.getString(t2 + 4, Ze.length) === Ze ? 79 : 4 + "http://ns.adobe.com/xap/1.0/".length + 1;
        }
        static findPosition(e2, t2) {
          let i2 = super.findPosition(e2, t2);
          return i2.multiSegment = i2.extended = 79 === i2.headerLength, i2.multiSegment ? (i2.chunkCount = e2.getUint8(t2 + 72), i2.chunkNumber = e2.getUint8(t2 + 76), 0 !== e2.getUint8(t2 + 77) && i2.chunkNumber++) : (i2.chunkCount = 1 / 0, i2.chunkNumber = -1), i2;
        }
        static handleMultiSegments(e2) {
          return e2.map((e3) => e3.chunk.getString()).join("");
        }
        normalizeInput(e2) {
          return "string" == typeof e2 ? e2 : I.from(e2).getString();
        }
        parse(e2 = this.chunk) {
          if (!this.localOptions.parse)
            return e2;
          e2 = function(e3) {
            let t3 = {}, i3 = {};
            for (let e4 of ut)
              t3[e4] = [], i3[e4] = 0;
            return e3.replace(ct, (e4, n3, s2) => {
              if ("<" === n3) {
                let n4 = ++i3[s2];
                return t3[s2].push(n4), `${e4}#${n4}`;
              }
              return `${e4}#${t3[s2].pop()}`;
            });
          }(e2);
          let t2 = nt.findAll(e2, "rdf", "Description");
          0 === t2.length && t2.push(new nt("rdf", "Description", void 0, e2));
          let i2, n2 = {};
          for (let e3 of t2)
            for (let t3 of e3.properties)
              i2 = ot(t3.ns, n2), st(t3, i2);
          return function(e3) {
            let t3;
            for (let i3 in e3)
              t3 = e3[i3] = d(e3[i3]), void 0 === t3 && delete e3[i3];
            return d(e3);
          }(n2);
        }
        assignToOutput(e2, t2) {
          if (this.localOptions.parse)
            for (let [i2, n2] of Object.entries(t2))
              switch (i2) {
                case "tiff":
                  this.assignObjectToOutput(e2, "ifd0", n2);
                  break;
                case "exif":
                  this.assignObjectToOutput(e2, "exif", n2);
                  break;
                case "xmlns":
                  break;
                default:
                  this.assignObjectToOutput(e2, i2, n2);
              }
          else
            e2.xmp = t2;
        }
      }
      __name(et, "et");
      f(et, "type", "xmp"), f(et, "multiSegment", true), A.set("xmp", et);
      class tt {
        static findAll(e2) {
          return lt(e2, /([a-zA-Z0-9-]+):([a-zA-Z0-9-]+)=("[^"]*"|'[^']*')/gm).map(tt.unpackMatch);
        }
        static unpackMatch(e2) {
          let t2 = e2[1], i2 = e2[2], n2 = e2[3].slice(1, -1);
          return n2 = ht(n2), new tt(t2, i2, n2);
        }
        constructor(e2, t2, i2) {
          this.ns = e2, this.name = t2, this.value = i2;
        }
        serialize() {
          return this.value;
        }
      }
      __name(tt, "tt");
      const it = "[\\w\\d-]+";
      class nt {
        static findAll(e2, t2, i2) {
          if (void 0 !== t2 || void 0 !== i2) {
            t2 = t2 || it, i2 = i2 || it;
            var n2 = new RegExp(`<(${t2}):(${i2})(#\\d+)?((\\s+?[\\w\\d-:]+=("[^"]*"|'[^']*'))*\\s*)(\\/>|>([\\s\\S]*?)<\\/\\1:\\2\\3>)`, "gm");
          } else
            n2 = /<([\w\d-]+):([\w\d-]+)(#\d+)?((\s+?[\w\d-:]+=("[^"]*"|'[^']*'))*\s*)(\/>|>([\s\S]*?)<\/\1:\2\3>)/gm;
          return lt(e2, n2).map(nt.unpackMatch);
        }
        static unpackMatch(e2) {
          let t2 = e2[1], i2 = e2[2], n2 = e2[4], s2 = e2[8];
          return new nt(t2, i2, n2, s2);
        }
        constructor(e2, t2, i2, n2) {
          this.ns = e2, this.name = t2, this.attrString = i2, this.innerXml = n2, this.attrs = tt.findAll(i2), this.children = nt.findAll(n2), this.value = 0 === this.children.length ? ht(n2) : void 0, this.properties = [...this.attrs, ...this.children];
        }
        get isPrimitive() {
          return void 0 !== this.value && 0 === this.attrs.length && 0 === this.children.length;
        }
        get isListContainer() {
          return 1 === this.children.length && this.children[0].isList;
        }
        get isList() {
          let { ns: e2, name: t2 } = this;
          return "rdf" === e2 && ("Seq" === t2 || "Bag" === t2 || "Alt" === t2);
        }
        get isListItem() {
          return "rdf" === this.ns && "li" === this.name;
        }
        serialize() {
          if (0 === this.properties.length && void 0 === this.value)
            return;
          if (this.isPrimitive)
            return this.value;
          if (this.isListContainer)
            return this.children[0].serialize();
          if (this.isList)
            return at(this.children.map(rt));
          if (this.isListItem && 1 === this.children.length && 0 === this.attrs.length)
            return this.children[0].serialize();
          let e2 = {};
          for (let t2 of this.properties)
            st(t2, e2);
          return void 0 !== this.value && (e2.value = this.value), d(e2);
        }
      }
      __name(nt, "nt");
      function st(e2, t2) {
        let i2 = e2.serialize();
        void 0 !== i2 && (t2[e2.name] = i2);
      }
      __name(st, "st");
      var rt = /* @__PURE__ */ __name((e2) => e2.serialize(), "rt"), at = /* @__PURE__ */ __name((e2) => 1 === e2.length ? e2[0] : e2, "at"), ot = /* @__PURE__ */ __name((e2, t2) => t2[e2] ? t2[e2] : t2[e2] = {}, "ot");
      function lt(e2, t2) {
        let i2, n2 = [];
        if (!e2)
          return n2;
        for (; null !== (i2 = t2.exec(e2)); )
          n2.push(i2);
        return n2;
      }
      __name(lt, "lt");
      function ht(e2) {
        if (function(e3) {
          return null == e3 || "null" === e3 || "undefined" === e3 || "" === e3 || "" === e3.trim();
        }(e2))
          return;
        let t2 = Number(e2);
        if (!Number.isNaN(t2))
          return t2;
        let i2 = e2.toLowerCase();
        return "true" === i2 || "false" !== i2 && e2.trim();
      }
      __name(ht, "ht");
      const ut = ["rdf:li", "rdf:Seq", "rdf:Bag", "rdf:Alt", "rdf:Description"], ct = new RegExp(`(<|\\/)(${ut.join("|")})`, "g");
      var ft = Object.freeze({ __proto__: null, default: Ge, Exifr: ce, fileParsers: T, segmentParsers: A, fileReaders: D, tagKeys: N, tagValues: G, tagRevivers: V, createDictionary: B, extendDictionary: E, fetchUrlAsArrayBuffer: L, readBlobAsArrayBuffer: U, chunkedProps: $, otherSegments: J, segments: q, tiffBlocks: Q, segmentsAndBlocks: Z, tiffExtractables: ee, inheritables: te, allFormatters: ie, Options: oe, parse: fe, gpsOnlyOptions: Ae, gps: De, thumbnailOnlyOptions: Oe, thumbnail: xe, thumbnailUrl: ve, orientationOnlyOptions: Me, orientation: Re, rotations: Le, get rotateCanvas() {
        return e.rotateCanvas;
      }, get rotateCss() {
        return e.rotateCss;
      }, rotation: Ue });
      const dt = ["xmp", "icc", "iptc", "tiff"], pt = /* @__PURE__ */ __name(() => {
      }, "pt");
      async function gt(e2, t2, i2) {
        let n2 = i2[e2];
        return n2.enabled = true, n2.parse = true, A.get(e2).parse(t2, n2);
      }
      __name(gt, "gt");
      let mt = h("fs", (e2) => e2.promises);
      D.set("fs", class extends Ne {
        async readWhole() {
          this.chunked = false, this.fs = await mt;
          let e2 = await this.fs.readFile(this.input);
          this._swapBuffer(e2);
        }
        async readChunked() {
          this.chunked = true, this.fs = await mt, await this.open(), await this.readChunk(0, this.options.firstChunkSize);
        }
        async open() {
          void 0 === this.fh && (this.fh = await this.fs.open(this.input, "r"), this.size = (await this.fh.stat(this.input)).size);
        }
        async _readChunk(e2, t2) {
          void 0 === this.fh && await this.open(), e2 + t2 > this.size && (t2 = this.size - e2);
          var i2 = this.subarray(e2, t2, true);
          return await this.fh.read(i2.dataView, 0, t2, e2), i2;
        }
        async close() {
          if (this.fh) {
            let e2 = this.fh;
            this.fh = void 0, await e2.close();
          }
        }
      });
      D.set("base64", class extends Ne {
        constructor(...e2) {
          super(...e2), this.input = this.input.replace(/^data:([^;]+);base64,/gim, ""), this.size = this.input.length / 4 * 3, this.input.endsWith("==") ? this.size -= 2 : this.input.endsWith("=") && (this.size -= 1);
        }
        async _readChunk(e2, t2) {
          let i2, n2, s2 = this.input;
          void 0 === e2 ? (e2 = 0, i2 = 0, n2 = 0) : (i2 = 4 * Math.floor(e2 / 3), n2 = e2 - i2 / 4 * 3), void 0 === t2 && (t2 = this.size);
          let a2 = e2 + t2, l2 = i2 + 4 * Math.ceil(a2 / 3);
          s2 = s2.slice(i2, l2);
          let h2 = Math.min(t2, this.size - e2);
          if (o) {
            let t3 = r.from(s2, "base64").slice(n2, n2 + h2);
            return this.set(t3, e2, true);
          }
          {
            let t3 = this.subarray(e2, h2, true), i3 = atob(s2), r2 = t3.toUint8();
            for (let e3 = 0; e3 < h2; e3++)
              r2[e3] = i3.charCodeAt(n2 + e3);
            return t3;
          }
        }
      });
      class St extends pe {
        static canHandle(e2, t2) {
          return 18761 === t2 || 19789 === t2;
        }
        extendOptions(e2) {
          let { ifd0: t2, xmp: i2, iptc: n2, icc: s2 } = e2;
          i2.enabled && t2.deps.add(j), n2.enabled && t2.deps.add(W), s2.enabled && t2.deps.add(K), t2.finalizeFilters();
        }
        async parse() {
          let { tiff: e2, xmp: t2, iptc: i2, icc: n2 } = this.options;
          if (e2.enabled || t2.enabled || i2.enabled || n2.enabled) {
            let e3 = Math.max(C(this.options), this.options.chunkSize);
            await this.file.ensureChunk(0, e3), this.createParser("tiff", this.file), this.parsers.tiff.parseHeader(), await this.parsers.tiff.parseIfd0Block(), this.adaptTiffPropAsSegment("xmp"), this.adaptTiffPropAsSegment("iptc"), this.adaptTiffPropAsSegment("icc");
          }
        }
        adaptTiffPropAsSegment(e2) {
          if (this.parsers.tiff[e2]) {
            let t2 = this.parsers.tiff[e2];
            this.injectSegment(e2, t2);
          }
        }
      }
      __name(St, "St");
      f(St, "type", "tiff"), T.set("tiff", St);
      let Ct = h("zlib");
      const yt = "XML:com.adobe.xmp", bt = "ihdr", Pt = "iccp", It = "text", kt = "itxt", wt = [bt, Pt, It, kt, "exif"];
      class Tt extends pe {
        constructor(...e2) {
          super(...e2), f(this, "catchError", (e3) => this.errors.push(e3)), f(this, "metaChunks", []), f(this, "unknownChunks", []);
        }
        static canHandle(e2, t2) {
          return 35152 === t2 && 2303741511 === e2.getUint32(0) && 218765834 === e2.getUint32(4);
        }
        async parse() {
          let { file: e2 } = this;
          await this.findPngChunksInRange("\x89PNG\r\n\n".length, e2.byteLength), await this.readSegments(this.metaChunks), this.findIhdr(), this.parseTextChunks(), await this.findExif().catch(this.catchError), await this.findXmp().catch(this.catchError), await this.findIcc().catch(this.catchError);
        }
        async findPngChunksInRange(e2, t2) {
          let { file: i2 } = this;
          for (; e2 < t2; ) {
            let t3 = i2.getUint32(e2), n2 = i2.getUint32(e2 + 4), s2 = i2.getString(e2 + 4, 4).toLowerCase(), r2 = t3 + 4 + 4 + 4, a2 = { type: s2, offset: e2, length: r2, start: e2 + 4 + 4, size: t3, marker: n2 };
            wt.includes(s2) ? this.metaChunks.push(a2) : this.unknownChunks.push(a2), e2 += r2;
          }
        }
        parseTextChunks() {
          let e2 = this.metaChunks.filter((e3) => e3.type === It);
          for (let t2 of e2) {
            let [e3, i2] = this.file.getString(t2.start, t2.size).split("\0");
            this.injectKeyValToIhdr(e3, i2);
          }
        }
        injectKeyValToIhdr(e2, t2) {
          let i2 = this.parsers.ihdr;
          i2 && i2.raw.set(e2, t2);
        }
        findIhdr() {
          let e2 = this.metaChunks.find((e3) => e3.type === bt);
          e2 && false !== this.options.ihdr.enabled && this.createParser(bt, e2.chunk);
        }
        async findExif() {
          let e2 = this.metaChunks.find((e3) => "exif" === e3.type);
          e2 && this.injectSegment("tiff", e2.chunk);
        }
        async findXmp() {
          let e2 = this.metaChunks.filter((e3) => e3.type === kt);
          for (let t2 of e2) {
            t2.chunk.getString(0, yt.length) === yt && this.injectSegment("xmp", t2.chunk);
          }
        }
        async findIcc() {
          let e2 = this.metaChunks.find((e3) => e3.type === Pt);
          if (!e2)
            return;
          let { chunk: t2 } = e2, i2 = t2.getUint8Array(0, 81), n2 = 0;
          for (; n2 < 80 && 0 !== i2[n2]; )
            n2++;
          let r2 = n2 + 2, a2 = t2.getString(0, n2);
          if (this.injectKeyValToIhdr("ProfileName", a2), s) {
            let e3 = await Ct, i3 = t2.getUint8Array(r2);
            i3 = e3.inflateSync(i3), this.injectSegment("icc", i3);
          }
        }
      }
      __name(Tt, "Tt");
      f(Tt, "type", "png"), T.set("png", Tt), B(N, "interop", [[1, "InteropIndex"], [2, "InteropVersion"], [4096, "RelatedImageFileFormat"], [4097, "RelatedImageWidth"], [4098, "RelatedImageHeight"]]), E(N, "ifd0", [[11, "ProcessingSoftware"], [254, "SubfileType"], [255, "OldSubfileType"], [263, "Thresholding"], [264, "CellWidth"], [265, "CellLength"], [266, "FillOrder"], [269, "DocumentName"], [280, "MinSampleValue"], [281, "MaxSampleValue"], [285, "PageName"], [286, "XPosition"], [287, "YPosition"], [290, "GrayResponseUnit"], [297, "PageNumber"], [321, "HalftoneHints"], [322, "TileWidth"], [323, "TileLength"], [332, "InkSet"], [337, "TargetPrinter"], [18246, "Rating"], [18249, "RatingPercent"], [33550, "PixelScale"], [34264, "ModelTransform"], [34377, "PhotoshopSettings"], [50706, "DNGVersion"], [50707, "DNGBackwardVersion"], [50708, "UniqueCameraModel"], [50709, "LocalizedCameraModel"], [50736, "DNGLensInfo"], [50739, "ShadowScale"], [50740, "DNGPrivateData"], [33920, "IntergraphMatrix"], [33922, "ModelTiePoint"], [34118, "SEMInfo"], [34735, "GeoTiffDirectory"], [34736, "GeoTiffDoubleParams"], [34737, "GeoTiffAsciiParams"], [50341, "PrintIM"], [50721, "ColorMatrix1"], [50722, "ColorMatrix2"], [50723, "CameraCalibration1"], [50724, "CameraCalibration2"], [50725, "ReductionMatrix1"], [50726, "ReductionMatrix2"], [50727, "AnalogBalance"], [50728, "AsShotNeutral"], [50729, "AsShotWhiteXY"], [50730, "BaselineExposure"], [50731, "BaselineNoise"], [50732, "BaselineSharpness"], [50734, "LinearResponseLimit"], [50735, "CameraSerialNumber"], [50741, "MakerNoteSafety"], [50778, "CalibrationIlluminant1"], [50779, "CalibrationIlluminant2"], [50781, "RawDataUniqueID"], [50827, "OriginalRawFileName"], [50828, "OriginalRawFileData"], [50831, "AsShotICCProfile"], [50832, "AsShotPreProfileMatrix"], [50833, "CurrentICCProfile"], [50834, "CurrentPreProfileMatrix"], [50879, "ColorimetricReference"], [50885, "SRawType"], [50898, "PanasonicTitle"], [50899, "PanasonicTitle2"], [50931, "CameraCalibrationSig"], [50932, "ProfileCalibrationSig"], [50933, "ProfileIFD"], [50934, "AsShotProfileName"], [50936, "ProfileName"], [50937, "ProfileHueSatMapDims"], [50938, "ProfileHueSatMapData1"], [50939, "ProfileHueSatMapData2"], [50940, "ProfileToneCurve"], [50941, "ProfileEmbedPolicy"], [50942, "ProfileCopyright"], [50964, "ForwardMatrix1"], [50965, "ForwardMatrix2"], [50966, "PreviewApplicationName"], [50967, "PreviewApplicationVersion"], [50968, "PreviewSettingsName"], [50969, "PreviewSettingsDigest"], [50970, "PreviewColorSpace"], [50971, "PreviewDateTime"], [50972, "RawImageDigest"], [50973, "OriginalRawFileDigest"], [50981, "ProfileLookTableDims"], [50982, "ProfileLookTableData"], [51043, "TimeCodes"], [51044, "FrameRate"], [51058, "TStop"], [51081, "ReelName"], [51089, "OriginalDefaultFinalSize"], [51090, "OriginalBestQualitySize"], [51091, "OriginalDefaultCropSize"], [51105, "CameraLabel"], [51107, "ProfileHueSatMapEncoding"], [51108, "ProfileLookTableEncoding"], [51109, "BaselineExposureOffset"], [51110, "DefaultBlackRender"], [51111, "NewRawImageDigest"], [51112, "RawToPreviewGain"]]);
      let At = [[273, "StripOffsets"], [279, "StripByteCounts"], [288, "FreeOffsets"], [289, "FreeByteCounts"], [291, "GrayResponseCurve"], [292, "T4Options"], [293, "T6Options"], [300, "ColorResponseUnit"], [320, "ColorMap"], [324, "TileOffsets"], [325, "TileByteCounts"], [326, "BadFaxLines"], [327, "CleanFaxData"], [328, "ConsecutiveBadFaxLines"], [330, "SubIFD"], [333, "InkNames"], [334, "NumberofInks"], [336, "DotRange"], [338, "ExtraSamples"], [339, "SampleFormat"], [340, "SMinSampleValue"], [341, "SMaxSampleValue"], [342, "TransferRange"], [343, "ClipPath"], [344, "XClipPathUnits"], [345, "YClipPathUnits"], [346, "Indexed"], [347, "JPEGTables"], [351, "OPIProxy"], [400, "GlobalParametersIFD"], [401, "ProfileType"], [402, "FaxProfile"], [403, "CodingMethods"], [404, "VersionYear"], [405, "ModeNumber"], [433, "Decode"], [434, "DefaultImageColor"], [435, "T82Options"], [437, "JPEGTables"], [512, "JPEGProc"], [515, "JPEGRestartInterval"], [517, "JPEGLosslessPredictors"], [518, "JPEGPointTransforms"], [519, "JPEGQTables"], [520, "JPEGDCTables"], [521, "JPEGACTables"], [559, "StripRowCounts"], [999, "USPTOMiscellaneous"], [18247, "XP_DIP_XML"], [18248, "StitchInfo"], [28672, "SonyRawFileType"], [28688, "SonyToneCurve"], [28721, "VignettingCorrection"], [28722, "VignettingCorrParams"], [28724, "ChromaticAberrationCorrection"], [28725, "ChromaticAberrationCorrParams"], [28726, "DistortionCorrection"], [28727, "DistortionCorrParams"], [29895, "SonyCropTopLeft"], [29896, "SonyCropSize"], [32781, "ImageID"], [32931, "WangTag1"], [32932, "WangAnnotation"], [32933, "WangTag3"], [32934, "WangTag4"], [32953, "ImageReferencePoints"], [32954, "RegionXformTackPoint"], [32955, "WarpQuadrilateral"], [32956, "AffineTransformMat"], [32995, "Matteing"], [32996, "DataType"], [32997, "ImageDepth"], [32998, "TileDepth"], [33300, "ImageFullWidth"], [33301, "ImageFullHeight"], [33302, "TextureFormat"], [33303, "WrapModes"], [33304, "FovCot"], [33305, "MatrixWorldToScreen"], [33306, "MatrixWorldToCamera"], [33405, "Model2"], [33421, "CFARepeatPatternDim"], [33422, "CFAPattern2"], [33423, "BatteryLevel"], [33424, "KodakIFD"], [33445, "MDFileTag"], [33446, "MDScalePixel"], [33447, "MDColorTable"], [33448, "MDLabName"], [33449, "MDSampleInfo"], [33450, "MDPrepDate"], [33451, "MDPrepTime"], [33452, "MDFileUnits"], [33589, "AdventScale"], [33590, "AdventRevision"], [33628, "UIC1Tag"], [33629, "UIC2Tag"], [33630, "UIC3Tag"], [33631, "UIC4Tag"], [33918, "IntergraphPacketData"], [33919, "IntergraphFlagRegisters"], [33921, "INGRReserved"], [34016, "Site"], [34017, "ColorSequence"], [34018, "IT8Header"], [34019, "RasterPadding"], [34020, "BitsPerRunLength"], [34021, "BitsPerExtendedRunLength"], [34022, "ColorTable"], [34023, "ImageColorIndicator"], [34024, "BackgroundColorIndicator"], [34025, "ImageColorValue"], [34026, "BackgroundColorValue"], [34027, "PixelIntensityRange"], [34028, "TransparencyIndicator"], [34029, "ColorCharacterization"], [34030, "HCUsage"], [34031, "TrapIndicator"], [34032, "CMYKEquivalent"], [34152, "AFCP_IPTC"], [34232, "PixelMagicJBIGOptions"], [34263, "JPLCartoIFD"], [34306, "WB_GRGBLevels"], [34310, "LeafData"], [34687, "TIFF_FXExtensions"], [34688, "MultiProfiles"], [34689, "SharedData"], [34690, "T88Options"], [34732, "ImageLayer"], [34750, "JBIGOptions"], [34856, "Opto-ElectricConvFactor"], [34857, "Interlace"], [34908, "FaxRecvParams"], [34909, "FaxSubAddress"], [34910, "FaxRecvTime"], [34929, "FedexEDR"], [34954, "LeafSubIFD"], [37387, "FlashEnergy"], [37388, "SpatialFrequencyResponse"], [37389, "Noise"], [37390, "FocalPlaneXResolution"], [37391, "FocalPlaneYResolution"], [37392, "FocalPlaneResolutionUnit"], [37397, "ExposureIndex"], [37398, "TIFF-EPStandardID"], [37399, "SensingMethod"], [37434, "CIP3DataFile"], [37435, "CIP3Sheet"], [37436, "CIP3Side"], [37439, "StoNits"], [37679, "MSDocumentText"], [37680, "MSPropertySetStorage"], [37681, "MSDocumentTextPosition"], [37724, "ImageSourceData"], [40965, "InteropIFD"], [40976, "SamsungRawPointersOffset"], [40977, "SamsungRawPointersLength"], [41217, "SamsungRawByteOrder"], [41218, "SamsungRawUnknown"], [41484, "SpatialFrequencyResponse"], [41485, "Noise"], [41489, "ImageNumber"], [41490, "SecurityClassification"], [41491, "ImageHistory"], [41494, "TIFF-EPStandardID"], [41995, "DeviceSettingDescription"], [42112, "GDALMetadata"], [42113, "GDALNoData"], [44992, "ExpandSoftware"], [44993, "ExpandLens"], [44994, "ExpandFilm"], [44995, "ExpandFilterLens"], [44996, "ExpandScanner"], [44997, "ExpandFlashLamp"], [46275, "HasselbladRawImage"], [48129, "PixelFormat"], [48130, "Transformation"], [48131, "Uncompressed"], [48132, "ImageType"], [48256, "ImageWidth"], [48257, "ImageHeight"], [48258, "WidthResolution"], [48259, "HeightResolution"], [48320, "ImageOffset"], [48321, "ImageByteCount"], [48322, "AlphaOffset"], [48323, "AlphaByteCount"], [48324, "ImageDataDiscard"], [48325, "AlphaDataDiscard"], [50215, "OceScanjobDesc"], [50216, "OceApplicationSelector"], [50217, "OceIDNumber"], [50218, "OceImageLogic"], [50255, "Annotations"], [50459, "HasselbladExif"], [50547, "OriginalFileName"], [50560, "USPTOOriginalContentType"], [50656, "CR2CFAPattern"], [50710, "CFAPlaneColor"], [50711, "CFALayout"], [50712, "LinearizationTable"], [50713, "BlackLevelRepeatDim"], [50714, "BlackLevel"], [50715, "BlackLevelDeltaH"], [50716, "BlackLevelDeltaV"], [50717, "WhiteLevel"], [50718, "DefaultScale"], [50719, "DefaultCropOrigin"], [50720, "DefaultCropSize"], [50733, "BayerGreenSplit"], [50737, "ChromaBlurRadius"], [50738, "AntiAliasStrength"], [50752, "RawImageSegmentation"], [50780, "BestQualityScale"], [50784, "AliasLayerMetadata"], [50829, "ActiveArea"], [50830, "MaskedAreas"], [50935, "NoiseReductionApplied"], [50974, "SubTileBlockSize"], [50975, "RowInterleaveFactor"], [51008, "OpcodeList1"], [51009, "OpcodeList2"], [51022, "OpcodeList3"], [51041, "NoiseProfile"], [51114, "CacheVersion"], [51125, "DefaultUserCrop"], [51157, "NikonNEFInfo"], [65024, "KdcIFD"]];
      E(N, "ifd0", At), E(N, "exif", At), B(G, "gps", [[23, { M: "Magnetic North", T: "True North" }], [25, { K: "Kilometers", M: "Miles", N: "Nautical Miles" }]]);
      class Dt extends ge {
        static canHandle(e2, t2) {
          return 224 === e2.getUint8(t2 + 1) && 1246120262 === e2.getUint32(t2 + 4) && 0 === e2.getUint8(t2 + 8);
        }
        parse() {
          return this.parseTags(), this.translate(), this.output;
        }
        parseTags() {
          this.raw = /* @__PURE__ */ new Map([[0, this.chunk.getUint16(0)], [2, this.chunk.getUint8(2)], [3, this.chunk.getUint16(3)], [5, this.chunk.getUint16(5)], [7, this.chunk.getUint8(7)], [8, this.chunk.getUint8(8)]]);
        }
      }
      __name(Dt, "Dt");
      f(Dt, "type", "jfif"), f(Dt, "headerLength", 9), A.set("jfif", Dt), B(N, "jfif", [[0, "JFIFVersion"], [2, "ResolutionUnit"], [3, "XResolution"], [5, "YResolution"], [7, "ThumbnailWidth"], [8, "ThumbnailHeight"]]);
      class Ot extends ge {
        parse() {
          return this.parseTags(), this.translate(), this.output;
        }
        parseTags() {
          this.raw = new Map([[0, this.chunk.getUint32(0)], [4, this.chunk.getUint32(4)], [8, this.chunk.getUint8(8)], [9, this.chunk.getUint8(9)], [10, this.chunk.getUint8(10)], [11, this.chunk.getUint8(11)], [12, this.chunk.getUint8(12)], ...Array.from(this.raw)]);
        }
      }
      __name(Ot, "Ot");
      f(Ot, "type", "ihdr"), A.set("ihdr", Ot), B(N, "ihdr", [[0, "ImageWidth"], [4, "ImageHeight"], [8, "BitDepth"], [9, "ColorType"], [10, "Compression"], [11, "Filter"], [12, "Interlace"]]), B(G, "ihdr", [[9, { 0: "Grayscale", 2: "RGB", 3: "Palette", 4: "Grayscale with Alpha", 6: "RGB with Alpha", DEFAULT: "Unknown" }], [10, { 0: "Deflate/Inflate", DEFAULT: "Unknown" }], [11, { 0: "Adaptive", DEFAULT: "Unknown" }], [12, { 0: "Noninterlaced", 1: "Adam7 Interlace", DEFAULT: "Unknown" }]]);
      const xt = "\0\0\0\0";
      class vt extends ge {
        static canHandle(e2, t2) {
          return 226 === e2.getUint8(t2 + 1) && 1229144927 === e2.getUint32(t2 + 4);
        }
        static findPosition(e2, t2) {
          let i2 = super.findPosition(e2, t2);
          return i2.chunkNumber = e2.getUint8(t2 + 16), i2.chunkCount = e2.getUint8(t2 + 17), i2.multiSegment = i2.chunkCount > 1, i2;
        }
        static handleMultiSegments(e2) {
          return function(e3) {
            let t2 = function(e4) {
              let t3 = e4[0].constructor, i2 = 0;
              for (let t4 of e4)
                i2 += t4.length;
              let n2 = new t3(i2), s2 = 0;
              for (let t4 of e4)
                n2.set(t4, s2), s2 += t4.length;
              return n2;
            }(e3.map((e4) => e4.chunk.toUint8()));
            return new I(t2);
          }(e2);
        }
        parse() {
          return this.raw = /* @__PURE__ */ new Map(), this.parseHeader(), this.parseTags(), this.translate(), this.output;
        }
        parseHeader() {
          let { raw: e2 } = this;
          this.chunk.byteLength < 84 && m("ICC header is too short");
          for (let [t2, i2] of Object.entries(Mt)) {
            t2 = parseInt(t2, 10);
            let n2 = i2(this.chunk, t2);
            n2 !== xt && e2.set(t2, n2);
          }
        }
        parseTags() {
          let e2, t2, i2, n2, s2, { raw: r2 } = this, a2 = this.chunk.getUint32(128), o2 = 132, l2 = this.chunk.byteLength;
          for (; a2--; ) {
            if (e2 = this.chunk.getString(o2, 4), t2 = this.chunk.getUint32(o2 + 4), i2 = this.chunk.getUint32(o2 + 8), n2 = this.chunk.getString(t2, 4), t2 + i2 > l2)
              return void console.warn("reached the end of the first ICC chunk. Enable options.tiff.multiSegment to read all ICC segments.");
            s2 = this.parseTag(n2, t2, i2), void 0 !== s2 && s2 !== xt && r2.set(e2, s2), o2 += 12;
          }
        }
        parseTag(e2, t2, i2) {
          switch (e2) {
            case "desc":
              return this.parseDesc(t2);
            case "mluc":
              return this.parseMluc(t2);
            case "text":
              return this.parseText(t2, i2);
            case "sig ":
              return this.parseSig(t2);
          }
          if (!(t2 + i2 > this.chunk.byteLength))
            return this.chunk.getUint8Array(t2, i2);
        }
        parseDesc(e2) {
          let t2 = this.chunk.getUint32(e2 + 8) - 1;
          return S(this.chunk.getString(e2 + 12, t2));
        }
        parseText(e2, t2) {
          return S(this.chunk.getString(e2 + 8, t2 - 8));
        }
        parseSig(e2) {
          return S(this.chunk.getString(e2 + 8, 4));
        }
        parseMluc(e2) {
          let { chunk: t2 } = this, i2 = t2.getUint32(e2 + 8), n2 = t2.getUint32(e2 + 12), s2 = e2 + 16, r2 = [];
          for (let a2 = 0; a2 < i2; a2++) {
            let i3 = t2.getString(s2 + 0, 2), a3 = t2.getString(s2 + 2, 2), o2 = t2.getUint32(s2 + 4), l2 = t2.getUint32(s2 + 8) + e2, h2 = S(t2.getUnicodeString(l2, o2));
            r2.push({ lang: i3, country: a3, text: h2 }), s2 += n2;
          }
          return 1 === i2 ? r2[0].text : r2;
        }
        translateValue(e2, t2) {
          return "string" == typeof e2 ? t2[e2] || t2[e2.toLowerCase()] || e2 : t2[e2] || e2;
        }
      }
      __name(vt, "vt");
      f(vt, "type", "icc"), f(vt, "multiSegment", true), f(vt, "headerLength", 18);
      const Mt = { 4: Rt, 8: function(e2, t2) {
        return [e2.getUint8(t2), e2.getUint8(t2 + 1) >> 4, e2.getUint8(t2 + 1) % 16].map((e3) => e3.toString(10)).join(".");
      }, 12: Rt, 16: Rt, 20: Rt, 24: function(e2, t2) {
        const i2 = e2.getUint16(t2), n2 = e2.getUint16(t2 + 2) - 1, s2 = e2.getUint16(t2 + 4), r2 = e2.getUint16(t2 + 6), a2 = e2.getUint16(t2 + 8), o2 = e2.getUint16(t2 + 10);
        return new Date(Date.UTC(i2, n2, s2, r2, a2, o2));
      }, 36: Rt, 40: Rt, 48: Rt, 52: Rt, 64: (e2, t2) => e2.getUint32(t2), 80: Rt };
      function Rt(e2, t2) {
        return S(e2.getString(t2, 4));
      }
      __name(Rt, "Rt");
      A.set("icc", vt), B(N, "icc", [[4, "ProfileCMMType"], [8, "ProfileVersion"], [12, "ProfileClass"], [16, "ColorSpaceData"], [20, "ProfileConnectionSpace"], [24, "ProfileDateTime"], [36, "ProfileFileSignature"], [40, "PrimaryPlatform"], [44, "CMMFlags"], [48, "DeviceManufacturer"], [52, "DeviceModel"], [56, "DeviceAttributes"], [64, "RenderingIntent"], [68, "ConnectionSpaceIlluminant"], [80, "ProfileCreator"], [84, "ProfileID"], ["Header", "ProfileHeader"], ["MS00", "WCSProfiles"], ["bTRC", "BlueTRC"], ["bXYZ", "BlueMatrixColumn"], ["bfd", "UCRBG"], ["bkpt", "MediaBlackPoint"], ["calt", "CalibrationDateTime"], ["chad", "ChromaticAdaptation"], ["chrm", "Chromaticity"], ["ciis", "ColorimetricIntentImageState"], ["clot", "ColorantTableOut"], ["clro", "ColorantOrder"], ["clrt", "ColorantTable"], ["cprt", "ProfileCopyright"], ["crdi", "CRDInfo"], ["desc", "ProfileDescription"], ["devs", "DeviceSettings"], ["dmdd", "DeviceModelDesc"], ["dmnd", "DeviceMfgDesc"], ["dscm", "ProfileDescriptionML"], ["fpce", "FocalPlaneColorimetryEstimates"], ["gTRC", "GreenTRC"], ["gXYZ", "GreenMatrixColumn"], ["gamt", "Gamut"], ["kTRC", "GrayTRC"], ["lumi", "Luminance"], ["meas", "Measurement"], ["meta", "Metadata"], ["mmod", "MakeAndModel"], ["ncl2", "NamedColor2"], ["ncol", "NamedColor"], ["ndin", "NativeDisplayInfo"], ["pre0", "Preview0"], ["pre1", "Preview1"], ["pre2", "Preview2"], ["ps2i", "PS2RenderingIntent"], ["ps2s", "PostScript2CSA"], ["psd0", "PostScript2CRD0"], ["psd1", "PostScript2CRD1"], ["psd2", "PostScript2CRD2"], ["psd3", "PostScript2CRD3"], ["pseq", "ProfileSequenceDesc"], ["psid", "ProfileSequenceIdentifier"], ["psvm", "PS2CRDVMSize"], ["rTRC", "RedTRC"], ["rXYZ", "RedMatrixColumn"], ["resp", "OutputResponse"], ["rhoc", "ReflectionHardcopyOrigColorimetry"], ["rig0", "PerceptualRenderingIntentGamut"], ["rig2", "SaturationRenderingIntentGamut"], ["rpoc", "ReflectionPrintOutputColorimetry"], ["sape", "SceneAppearanceEstimates"], ["scoe", "SceneColorimetryEstimates"], ["scrd", "ScreeningDesc"], ["scrn", "Screening"], ["targ", "CharTarget"], ["tech", "Technology"], ["vcgt", "VideoCardGamma"], ["view", "ViewingConditions"], ["vued", "ViewingCondDesc"], ["wtpt", "MediaWhitePoint"]]);
      const Lt = { "4d2p": "Erdt Systems", AAMA: "Aamazing Technologies", ACER: "Acer", ACLT: "Acolyte Color Research", ACTI: "Actix Sytems", ADAR: "Adara Technology", ADBE: "Adobe", ADI: "ADI Systems", AGFA: "Agfa Graphics", ALMD: "Alps Electric", ALPS: "Alps Electric", ALWN: "Alwan Color Expertise", AMTI: "Amiable Technologies", AOC: "AOC International", APAG: "Apago", APPL: "Apple Computer", AST: "AST", "AT&T": "AT&T", BAEL: "BARBIERI electronic", BRCO: "Barco NV", BRKP: "Breakpoint", BROT: "Brother", BULL: "Bull", BUS: "Bus Computer Systems", "C-IT": "C-Itoh", CAMR: "Intel", CANO: "Canon", CARR: "Carroll Touch", CASI: "Casio", CBUS: "Colorbus PL", CEL: "Crossfield", CELx: "Crossfield", CGS: "CGS Publishing Technologies International", CHM: "Rochester Robotics", CIGL: "Colour Imaging Group, London", CITI: "Citizen", CL00: "Candela", CLIQ: "Color IQ", CMCO: "Chromaco", CMiX: "CHROMiX", COLO: "Colorgraphic Communications", COMP: "Compaq", COMp: "Compeq/Focus Technology", CONR: "Conrac Display Products", CORD: "Cordata Technologies", CPQ: "Compaq", CPRO: "ColorPro", CRN: "Cornerstone", CTX: "CTX International", CVIS: "ColorVision", CWC: "Fujitsu Laboratories", DARI: "Darius Technology", DATA: "Dataproducts", DCP: "Dry Creek Photo", DCRC: "Digital Contents Resource Center, Chung-Ang University", DELL: "Dell Computer", DIC: "Dainippon Ink and Chemicals", DICO: "Diconix", DIGI: "Digital", "DL&C": "Digital Light & Color", DPLG: "Doppelganger", DS: "Dainippon Screen", DSOL: "DOOSOL", DUPN: "DuPont", EPSO: "Epson", ESKO: "Esko-Graphics", ETRI: "Electronics and Telecommunications Research Institute", EVER: "Everex Systems", EXAC: "ExactCODE", Eizo: "Eizo", FALC: "Falco Data Products", FF: "Fuji Photo Film", FFEI: "FujiFilm Electronic Imaging", FNRD: "Fnord Software", FORA: "Fora", FORE: "Forefront Technology", FP: "Fujitsu", FPA: "WayTech Development", FUJI: "Fujitsu", FX: "Fuji Xerox", GCC: "GCC Technologies", GGSL: "Global Graphics Software", GMB: "Gretagmacbeth", GMG: "GMG", GOLD: "GoldStar Technology", GOOG: "Google", GPRT: "Giantprint", GTMB: "Gretagmacbeth", GVC: "WayTech Development", GW2K: "Sony", HCI: "HCI", HDM: "Heidelberger Druckmaschinen", HERM: "Hermes", HITA: "Hitachi America", HP: "Hewlett-Packard", HTC: "Hitachi", HiTi: "HiTi Digital", IBM: "IBM", IDNT: "Scitex", IEC: "Hewlett-Packard", IIYA: "Iiyama North America", IKEG: "Ikegami Electronics", IMAG: "Image Systems", IMI: "Ingram Micro", INTC: "Intel", INTL: "N/A (INTL)", INTR: "Intra Electronics", IOCO: "Iocomm International Technology", IPS: "InfoPrint Solutions Company", IRIS: "Scitex", ISL: "Ichikawa Soft Laboratory", ITNL: "N/A (ITNL)", IVM: "IVM", IWAT: "Iwatsu Electric", Idnt: "Scitex", Inca: "Inca Digital Printers", Iris: "Scitex", JPEG: "Joint Photographic Experts Group", JSFT: "Jetsoft Development", JVC: "JVC Information Products", KART: "Scitex", KFC: "KFC Computek Components", KLH: "KLH Computers", KMHD: "Konica Minolta", KNCA: "Konica", KODA: "Kodak", KYOC: "Kyocera", Kart: "Scitex", LCAG: "Leica", LCCD: "Leeds Colour", LDAK: "Left Dakota", LEAD: "Leading Technology", LEXM: "Lexmark International", LINK: "Link Computer", LINO: "Linotronic", LITE: "Lite-On", Leaf: "Leaf", Lino: "Linotronic", MAGC: "Mag Computronic", MAGI: "MAG Innovision", MANN: "Mannesmann", MICN: "Micron Technology", MICR: "Microtek", MICV: "Microvitec", MINO: "Minolta", MITS: "Mitsubishi Electronics America", MITs: "Mitsuba", MNLT: "Minolta", MODG: "Modgraph", MONI: "Monitronix", MONS: "Monaco Systems", MORS: "Morse Technology", MOTI: "Motive Systems", MSFT: "Microsoft", MUTO: "MUTOH INDUSTRIES", Mits: "Mitsubishi Electric", NANA: "NANAO", NEC: "NEC", NEXP: "NexPress Solutions", NISS: "Nissei Sangyo America", NKON: "Nikon", NONE: "none", OCE: "Oce Technologies", OCEC: "OceColor", OKI: "Oki", OKID: "Okidata", OKIP: "Okidata", OLIV: "Olivetti", OLYM: "Olympus", ONYX: "Onyx Graphics", OPTI: "Optiquest", PACK: "Packard Bell", PANA: "Matsushita Electric Industrial", PANT: "Pantone", PBN: "Packard Bell", PFU: "PFU", PHIL: "Philips Consumer Electronics", PNTX: "HOYA", POne: "Phase One A/S", PREM: "Premier Computer Innovations", PRIN: "Princeton Graphic Systems", PRIP: "Princeton Publishing Labs", QLUX: "Hong Kong", QMS: "QMS", QPCD: "QPcard AB", QUAD: "QuadLaser", QUME: "Qume", RADI: "Radius", RDDx: "Integrated Color Solutions", RDG: "Roland DG", REDM: "REDMS Group", RELI: "Relisys", RGMS: "Rolf Gierling Multitools", RICO: "Ricoh", RNLD: "Edmund Ronald", ROYA: "Royal", RPC: "Ricoh Printing Systems", RTL: "Royal Information Electronics", SAMP: "Sampo", SAMS: "Samsung", SANT: "Jaime Santana Pomares", SCIT: "Scitex", SCRN: "Dainippon Screen", SDP: "Scitex", SEC: "Samsung", SEIK: "Seiko Instruments", SEIk: "Seikosha", SGUY: "ScanGuy.com", SHAR: "Sharp Laboratories", SICC: "International Color Consortium", SONY: "Sony", SPCL: "SpectraCal", STAR: "Star", STC: "Sampo Technology", Scit: "Scitex", Sdp: "Scitex", Sony: "Sony", TALO: "Talon Technology", TAND: "Tandy", TATU: "Tatung", TAXA: "TAXAN America", TDS: "Tokyo Denshi Sekei", TECO: "TECO Information Systems", TEGR: "Tegra", TEKT: "Tektronix", TI: "Texas Instruments", TMKR: "TypeMaker", TOSB: "Toshiba", TOSH: "Toshiba", TOTK: "TOTOKU ELECTRIC", TRIU: "Triumph", TSBT: "Toshiba", TTX: "TTX Computer Products", TVM: "TVM Professional Monitor", TW: "TW Casper", ULSX: "Ulead Systems", UNIS: "Unisys", UTZF: "Utz Fehlau & Sohn", VARI: "Varityper", VIEW: "Viewsonic", VISL: "Visual communication", VIVO: "Vivo Mobile Communication", WANG: "Wang", WLBR: "Wilbur Imaging", WTG2: "Ware To Go", WYSE: "WYSE Technology", XERX: "Xerox", XRIT: "X-Rite", ZRAN: "Zoran", Zebr: "Zebra Technologies", appl: "Apple Computer", bICC: "basICColor", berg: "bergdesign", ceyd: "Integrated Color Solutions", clsp: "MacDermid ColorSpan", ds: "Dainippon Screen", dupn: "DuPont", ffei: "FujiFilm Electronic Imaging", flux: "FluxData", iris: "Scitex", kart: "Scitex", lcms: "Little CMS", lino: "Linotronic", none: "none", ob4d: "Erdt Systems", obic: "Medigraph", quby: "Qubyx Sarl", scit: "Scitex", scrn: "Dainippon Screen", sdp: "Scitex", siwi: "SIWI GRAFIKA", yxym: "YxyMaster" }, Ut = { scnr: "Scanner", mntr: "Monitor", prtr: "Printer", link: "Device Link", abst: "Abstract", spac: "Color Space Conversion Profile", nmcl: "Named Color", cenc: "ColorEncodingSpace profile", mid: "MultiplexIdentification profile", mlnk: "MultiplexLink profile", mvis: "MultiplexVisualization profile", nkpf: "Nikon Input Device Profile (NON-STANDARD!)" };
      B(G, "icc", [[4, Lt], [12, Ut], [40, Object.assign({}, Lt, Ut)], [48, Lt], [80, Lt], [64, { 0: "Perceptual", 1: "Relative Colorimetric", 2: "Saturation", 3: "Absolute Colorimetric" }], ["tech", { amd: "Active Matrix Display", crt: "Cathode Ray Tube Display", kpcd: "Photo CD", pmd: "Passive Matrix Display", dcam: "Digital Camera", dcpj: "Digital Cinema Projector", dmpc: "Digital Motion Picture Camera", dsub: "Dye Sublimation Printer", epho: "Electrophotographic Printer", esta: "Electrostatic Printer", flex: "Flexography", fprn: "Film Writer", fscn: "Film Scanner", grav: "Gravure", ijet: "Ink Jet Printer", imgs: "Photo Image Setter", mpfr: "Motion Picture Film Recorder", mpfs: "Motion Picture Film Scanner", offs: "Offset Lithography", pjtv: "Projection Television", rpho: "Photographic Paper Printer", rscn: "Reflective Scanner", silk: "Silkscreen", twax: "Thermal Wax Printer", vidc: "Video Camera", vidm: "Video Monitor" }]]);
      class Ft extends ge {
        static canHandle(e2, t2, i2) {
          return 237 === e2.getUint8(t2 + 1) && "Photoshop" === e2.getString(t2 + 4, 9) && void 0 !== this.containsIptc8bim(e2, t2, i2);
        }
        static headerLength(e2, t2, i2) {
          let n2, s2 = this.containsIptc8bim(e2, t2, i2);
          if (void 0 !== s2)
            return n2 = e2.getUint8(t2 + s2 + 7), n2 % 2 != 0 && (n2 += 1), 0 === n2 && (n2 = 4), s2 + 8 + n2;
        }
        static containsIptc8bim(e2, t2, i2) {
          for (let n2 = 0; n2 < i2; n2++)
            if (this.isIptcSegmentHead(e2, t2 + n2))
              return n2;
        }
        static isIptcSegmentHead(e2, t2) {
          return 56 === e2.getUint8(t2) && 943868237 === e2.getUint32(t2) && 1028 === e2.getUint16(t2 + 4);
        }
        parse() {
          let { raw: e2 } = this, t2 = this.chunk.byteLength - 1, i2 = false;
          for (let n2 = 0; n2 < t2; n2++)
            if (28 === this.chunk.getUint8(n2) && 2 === this.chunk.getUint8(n2 + 1)) {
              i2 = true;
              let t3 = this.chunk.getUint16(n2 + 3), s2 = this.chunk.getUint8(n2 + 2), r2 = this.chunk.getLatin1String(n2 + 5, t3);
              e2.set(s2, this.pluralizeValue(e2.get(s2), r2)), n2 += 4 + t3;
            } else if (i2)
              break;
          return this.translate(), this.output;
        }
        pluralizeValue(e2, t2) {
          return void 0 !== e2 ? e2 instanceof Array ? (e2.push(t2), e2) : [e2, t2] : t2;
        }
      }
      __name(Ft, "Ft");
      f(Ft, "type", "iptc"), f(Ft, "translateValues", false), f(Ft, "reviveValues", false), A.set("iptc", Ft), B(N, "iptc", [[0, "ApplicationRecordVersion"], [3, "ObjectTypeReference"], [4, "ObjectAttributeReference"], [5, "ObjectName"], [7, "EditStatus"], [8, "EditorialUpdate"], [10, "Urgency"], [12, "SubjectReference"], [15, "Category"], [20, "SupplementalCategories"], [22, "FixtureIdentifier"], [25, "Keywords"], [26, "ContentLocationCode"], [27, "ContentLocationName"], [30, "ReleaseDate"], [35, "ReleaseTime"], [37, "ExpirationDate"], [38, "ExpirationTime"], [40, "SpecialInstructions"], [42, "ActionAdvised"], [45, "ReferenceService"], [47, "ReferenceDate"], [50, "ReferenceNumber"], [55, "DateCreated"], [60, "TimeCreated"], [62, "DigitalCreationDate"], [63, "DigitalCreationTime"], [65, "OriginatingProgram"], [70, "ProgramVersion"], [75, "ObjectCycle"], [80, "Byline"], [85, "BylineTitle"], [90, "City"], [92, "Sublocation"], [95, "State"], [100, "CountryCode"], [101, "Country"], [103, "OriginalTransmissionReference"], [105, "Headline"], [110, "Credit"], [115, "Source"], [116, "CopyrightNotice"], [118, "Contact"], [120, "Caption"], [121, "LocalCaption"], [122, "Writer"], [125, "RasterizedCaption"], [130, "ImageType"], [131, "ImageOrientation"], [135, "LanguageIdentifier"], [150, "AudioType"], [151, "AudioSamplingRate"], [152, "AudioSamplingResolution"], [153, "AudioDuration"], [154, "AudioOutcue"], [184, "JobID"], [185, "MasterDocumentID"], [186, "ShortDocumentID"], [187, "UniqueDocumentID"], [188, "OwnerID"], [200, "ObjectPreviewFileFormat"], [201, "ObjectPreviewFileVersion"], [202, "ObjectPreviewData"], [221, "Prefs"], [225, "ClassifyState"], [228, "SimilarityIndex"], [230, "DocumentNotes"], [231, "DocumentHistory"], [232, "ExifCameraInfo"], [255, "CatalogSets"]]), B(G, "iptc", [[10, { 0: "0 (reserved)", 1: "1 (most urgent)", 2: "2", 3: "3", 4: "4", 5: "5 (normal urgency)", 6: "6", 7: "7", 8: "8 (least urgent)", 9: "9 (user-defined priority)" }], [75, { a: "Morning", b: "Both Morning and Evening", p: "Evening" }], [131, { L: "Landscape", P: "Portrait", S: "Square" }]]), e.Exifr = ce, e.Options = oe, e.allFormatters = ie, e.chunkedProps = $, e.createDictionary = B, e.default = ft, e.extendDictionary = E, e.fetchUrlAsArrayBuffer = L, e.fileParsers = T, e.fileReaders = D, e.gps = De, e.gpsOnlyOptions = Ae, e.inheritables = te, e.orientation = Re, e.orientationOnlyOptions = Me, e.otherSegments = J, e.parse = fe, e.readBlobAsArrayBuffer = U, e.rotation = Ue, e.rotations = Le, e.segmentParsers = A, e.segments = q, e.segmentsAndBlocks = Z, e.sidecar = async function(e2, t2, i2) {
        let n2 = new oe(t2);
        n2.chunked = false, void 0 === i2 && "string" == typeof e2 && (i2 = function(e3) {
          let t3 = e3.toLowerCase().split(".").pop();
          if (function(e4) {
            return "exif" === e4 || "tiff" === e4 || "tif" === e4;
          }(t3))
            return "tiff";
          if (dt.includes(t3))
            return t3;
        }(e2));
        let s2 = await x(e2, n2);
        if (i2) {
          if (dt.includes(i2))
            return gt(i2, s2, n2);
          m("Invalid segment type");
        } else {
          if (function(e3) {
            let t3 = e3.getString(0, 50).trim();
            return t3.includes("<?xpacket") || t3.includes("<x:");
          }(s2))
            return gt("xmp", s2, n2);
          for (let [e3] of A) {
            if (!dt.includes(e3))
              continue;
            let t3 = await gt(e3, s2, n2).catch(pt);
            if (t3)
              return t3;
          }
          m("Unknown file format");
        }
      }, e.tagKeys = N, e.tagRevivers = V, e.tagValues = G, e.thumbnail = xe, e.thumbnailOnlyOptions = Oe, e.thumbnailUrl = ve, e.tiffBlocks = Q, e.tiffExtractables = ee, Object.defineProperty(e, "__esModule", { value: true });
    });
  }
});

// node_modules/flight-recorder-manufacturers/manufacturers.json
var require_manufacturers = __commonJS({
  "node_modules/flight-recorder-manufacturers/manufacturers.json"(exports, module2) {
    module2.exports = [
      { name: "Aircotec", long: "ACT", short: "I" },
      { name: "Cambridge Aero Instruments", long: "CAM", short: "C" },
      { name: "ClearNav Instruments", long: "CNI", short: null },
      { name: "Data Swan/DSX", long: "DSX", short: "D" },
      { name: "EW Avionics", long: "EWA", short: "E" },
      { name: "Filser", long: "FIL", short: "F" },
      { name: "Flarm", long: "FLA", short: "G" },
      { name: "Flytech", long: "FLY", short: null },
      { name: "Garrecht", long: "GCS", short: "A" },
      { name: "IMI Gliding Equipment", long: "IMI", short: "M" },
      { name: "Logstream", long: "LGS", short: null },
      { name: "LX Navigation", long: "LXN", short: "L" },
      { name: "LXNAV", long: "LXV", short: "V" },
      { name: "Naviter", long: "NAV", short: null },
      { name: "New Technologies", long: "NTE", short: "N" },
      { name: "Nielsen Kellerman", long: "NKL", short: "K" },
      { name: "Peschges", long: "PES", short: "P" },
      { name: "PressFinish Electronics", long: "PFE", short: null },
      { name: "Print Technik", long: "PRT", short: "R" },
      { name: "Scheffel", long: "SCH", short: "H" },
      { name: "Streamline Data Instruments", long: "SDI", short: "S" },
      { name: "Triadis Engineering GmbH", long: "TRI", short: "T" },
      { name: "Zander", long: "ZAN", short: "Z" },
      { name: "XCSoar", long: "XCS", short: null },
      { name: "LK8000", long: "XLK", short: null },
      { name: "GpsDump", long: "XGD", short: null },
      { name: "SeeYou Recorder", long: "XCM", short: null },
      { name: "Flyskyhy", long: "XFH", short: null },
      { name: "XCTrack", long: "XCT", short: null },
      { name: "Flymaster Live", long: "XFM", short: null },
      { name: "XCTracer", long: "XTR", short: null },
      { name: "SkyBean", long: "XSB", short: null },
      { name: "leGPSBip", long: "XSD", short: null },
      { name: "Logfly", long: "XLF", short: null },
      { name: "Loctome", long: "XLM", short: null }
    ];
  }
});

// node_modules/flight-recorder-manufacturers/lookup.js
var require_lookup = __commonJS({
  "node_modules/flight-recorder-manufacturers/lookup.js"(exports, module2) {
    var MANUFACTURERS = require_manufacturers();
    module2.exports = /* @__PURE__ */ __name(function lookup(id) {
      let short = id.length === 1;
      id = id.toUpperCase();
      let manufacturers = MANUFACTURERS.filter((it) => it[short ? "short" : "long"] === id);
      return manufacturers.length !== 0 ? manufacturers[0].name : id;
    }, "lookup");
  }
});

// node_modules/igc-parser/index.js
var require_igc_parser = __commonJS({
  "node_modules/igc-parser/index.js"(exports, module2) {
    "use strict";
    var lookupManufacturer = require_lookup();
    var ONE_HOUR = 60 * 60 * 1e3;
    var ONE_DAY = 24 * 60 * 60 * 1e3;
    var RE_A = /^A(\w{3})(\w{3,}?)(?:FLIGHT:(\d+)|\:(.+))?$/;
    var RE_HFDTE = /^HFDTE(?:DATE:)?(\d{2})(\d{2})(\d{2})(?:,?(\d{2}))?/;
    var RE_PLT_HEADER = /^H(\w)PLT(?:.{0,}?:(.*)|(.*))$/;
    var RE_CM2_HEADER = /^H(\w)CM2(?:.{0,}?:(.*)|(.*))$/;
    var RE_GTY_HEADER = /^H(\w)GTY(?:.{0,}?:(.*)|(.*))$/;
    var RE_GID_HEADER = /^H(\w)GID(?:.{0,}?:(.*)|(.*))$/;
    var RE_CID_HEADER = /^H(\w)CID(?:.{0,}?:(.*)|(.*))$/;
    var RE_CCL_HEADER = /^H(\w)CCL(?:.{0,}?:(.*)|(.*))$/;
    var RE_SIT_HEADER = /^H(\w)SIT(?:.{0,}?:(.*)|(.*))$/;
    var RE_FTY_HEADER = /^H(\w)FTY(?:.{0,}?:(.*)|(.*))$/;
    var RE_RFW_HEADER = /^H(\w)RFW(?:.{0,}?:(.*)|(.*))$/;
    var RE_RHW_HEADER = /^H(\w)RHW(?:.{0,}?:(.*)|(.*))$/;
    var RE_B = /^B(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{3})([NS])(\d{3})(\d{2})(\d{3})([EW])([AV])(-\d{4}|\d{5})(-\d{4}|\d{5})/;
    var RE_K = /^K(\d{2})(\d{2})(\d{2})/;
    var RE_IJ = /^[IJ](\d{2})(?:\d{2}\d{2}[A-Z]{3})+/;
    var RE_TASK = /^C(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{4})([-\d]{2})(.*)/;
    var RE_TASKPOINT = /^C(\d{2})(\d{2})(\d{3})([NS])(\d{3})(\d{2})(\d{3})([EW])(.*)/;
    var VALID_DATA_SOURCES = ["F", "O", "P"];
    var IGCParser2 = (
      /** @class */
      function() {
        function IGCParser3(options) {
          if (options === void 0) {
            options = {};
          }
          this._result = {
            numFlight: null,
            pilot: null,
            copilot: null,
            gliderType: null,
            registration: null,
            callsign: null,
            competitionClass: null,
            loggerType: null,
            firmwareVersion: null,
            hardwareVersion: null,
            task: null,
            fixes: [],
            dataRecords: [],
            security: null,
            errors: []
          };
          this.fixExtensions = [];
          this.dataExtensions = [];
          this.lineNumber = 0;
          this.prevTimestamp = null;
          this.options = options;
        }
        __name(IGCParser3, "IGCParser");
        IGCParser3.parse = function(str, options) {
          if (options === void 0) {
            options = {};
          }
          var parser = new IGCParser3(options);
          var errors = [];
          for (var _i = 0, _a = str.split("\n"); _i < _a.length; _i++) {
            var line = _a[_i];
            try {
              parser.processLine(line.trim());
            } catch (error) {
              if (options.lenient) {
                errors.push(error);
              } else {
                throw error;
              }
            }
          }
          var result = parser.result;
          result.errors = errors;
          return result;
        };
        Object.defineProperty(IGCParser3.prototype, "result", {
          get: function() {
            if (!this._result.loggerManufacturer) {
              throw new Error("Missing A record");
            }
            if (!this._result.date) {
              throw new Error("Missing HFDTE record");
            }
            return this._result;
          },
          enumerable: false,
          configurable: true
        });
        IGCParser3.prototype.processLine = function(line) {
          this.lineNumber += 1;
          var recordType = line[0];
          if (recordType === "B") {
            var fix = this.parseBRecord(line);
            this.prevTimestamp = fix.timestamp;
            this._result.fixes.push(fix);
          } else if (recordType === "K") {
            var data = this.parseKRecord(line);
            this.prevTimestamp = data.timestamp;
            this._result.dataRecords.push(data);
          } else if (recordType === "H") {
            this.processHeader(line);
          } else if (recordType === "C") {
            this.processTaskLine(line);
          } else if (recordType === "A") {
            var record = this.parseARecord(line);
            this._result.loggerId = record.loggerId;
            this._result.loggerManufacturer = record.manufacturer;
            if (record.numFlight !== null) {
              this._result.numFlight = record.numFlight;
            }
          } else if (recordType === "I") {
            this.fixExtensions = this.parseIJRecord(line);
          } else if (recordType === "J") {
            this.dataExtensions = this.parseIJRecord(line);
          } else if (recordType === "G") {
            this._result.security = (this._result.security || "") + line.slice(1);
          }
        };
        IGCParser3.prototype.processHeader = function(line) {
          var headerType = line.slice(2, 5);
          if (headerType === "DTE") {
            var record = this.parseDateHeader(line);
            this._result.date = record.date;
            if (record.numFlight !== null) {
              this._result.numFlight = record.numFlight;
            }
          } else if (headerType === "PLT") {
            this._result.pilot = this.parsePilot(line);
          } else if (headerType === "CM2") {
            this._result.copilot = this.parseCopilot(line);
          } else if (headerType === "GTY") {
            this._result.gliderType = this.parseGliderType(line);
          } else if (headerType === "GID") {
            this._result.registration = this.parseRegistration(line);
          } else if (headerType === "CID") {
            this._result.callsign = this.parseCallsign(line);
          } else if (headerType === "CCL") {
            this._result.competitionClass = this.parseCompetitionClass(line);
          } else if (headerType === "SIT") {
            this._result.site = this.parseSite(line);
          } else if (headerType === "FTY") {
            this._result.loggerType = this.parseLoggerType(line);
          } else if (headerType === "RFW") {
            this._result.firmwareVersion = this.parseFirmwareVersion(line);
          } else if (headerType === "RHW") {
            this._result.hardwareVersion = this.parseHardwareVersion(line);
          }
        };
        IGCParser3.prototype.parseARecord = function(line) {
          var match = line.match(RE_A);
          if (match) {
            var manufacturer = lookupManufacturer(match[1]);
            var loggerId = match[2];
            var numFlight = match[3] ? parseInt(match[3], 10) : null;
            var additionalData = match[4] || null;
            return { manufacturer, loggerId, numFlight, additionalData };
          }
          match = line.match(/^A(\w{3})(.+)?$/);
          if (match) {
            var manufacturer = lookupManufacturer(match[1]);
            var additionalData = match[2] ? match[2].trim() : null;
            return { manufacturer, loggerId: null, numFlight: null, additionalData };
          }
          throw new Error("Invalid A record at line " + this.lineNumber + ": " + line);
        };
        IGCParser3.prototype.parseDateHeader = function(line) {
          var match = line.match(RE_HFDTE);
          if (!match) {
            throw new Error("Invalid DTE header at line " + this.lineNumber + ": " + line);
          }
          var lastCentury = match[3][0] === "8" || match[3][0] === "9";
          var date = (lastCentury ? "19" : "20") + match[3] + "-" + match[2] + "-" + match[1];
          var numFlight = match[4] ? parseInt(match[4], 10) : null;
          return { date, numFlight };
        };
        IGCParser3.prototype.parseTextHeader = function(headerType, regex, line, underscoreReplacement) {
          if (underscoreReplacement === void 0) {
            underscoreReplacement = " ";
          }
          var match = line.match(regex);
          if (!match) {
            throw new Error("Invalid " + headerType + " header at line " + this.lineNumber + ": " + line);
          }
          var dataSource = match[1];
          if (VALID_DATA_SOURCES.indexOf(dataSource) === -1 && !this.options.lenient) {
            throw new Error("Invalid data source at line " + this.lineNumber + ": " + dataSource);
          }
          return (match[2] || match[3] || "").replace(/_/g, underscoreReplacement).trim();
        };
        IGCParser3.prototype.parsePilot = function(line) {
          return this.parseTextHeader("PLT", RE_PLT_HEADER, line);
        };
        IGCParser3.prototype.parseCopilot = function(line) {
          return this.parseTextHeader("CM2", RE_CM2_HEADER, line);
        };
        IGCParser3.prototype.parseGliderType = function(line) {
          return this.parseTextHeader("GTY", RE_GTY_HEADER, line);
        };
        IGCParser3.prototype.parseRegistration = function(line) {
          return this.parseTextHeader("GID", RE_GID_HEADER, line, "-");
        };
        IGCParser3.prototype.parseCallsign = function(line) {
          return this.parseTextHeader("GTY", RE_CID_HEADER, line);
        };
        IGCParser3.prototype.parseCompetitionClass = function(line) {
          return this.parseTextHeader("GID", RE_CCL_HEADER, line);
        };
        IGCParser3.prototype.parseSite = function(line) {
          return this.parseTextHeader("SIT", RE_SIT_HEADER, line);
        };
        IGCParser3.prototype.parseLoggerType = function(line) {
          return this.parseTextHeader("FTY", RE_FTY_HEADER, line);
        };
        IGCParser3.prototype.parseFirmwareVersion = function(line) {
          return this.parseTextHeader("RFW", RE_RFW_HEADER, line);
        };
        IGCParser3.prototype.parseHardwareVersion = function(line) {
          return this.parseTextHeader("RHW", RE_RHW_HEADER, line);
        };
        IGCParser3.prototype.processTaskLine = function(line) {
          if (!this._result.task) {
            this._result.task = this.parseTask(line);
          } else {
            this._result.task.points.push(this.parseTaskPoint(line));
          }
        };
        IGCParser3.prototype.parseTask = function(line) {
          var match = line.match(RE_TASK);
          if (!match) {
            throw new Error("Invalid task declaration at line " + this.lineNumber + ": " + line);
          }
          var lastCentury = match[3][0] === "8" || match[3][0] === "9";
          var declarationDate = (lastCentury ? "19" : "20") + match[3] + "-" + match[2] + "-" + match[1];
          var declarationTime = match[4] + ":" + match[5] + ":" + match[6];
          var declarationTimestamp = Date.parse(declarationDate + "T" + declarationTime + "Z");
          var flightDate = null;
          if (match[7] !== "00" || match[8] !== "00" || match[9] !== "00") {
            lastCentury = match[9][0] === "8" || match[9][0] === "9";
            flightDate = (lastCentury ? "19" : "20") + match[9] + "-" + match[8] + "-" + match[7];
          }
          var taskNumber = match[10] !== "0000" ? parseInt(match[10], 10) : null;
          var numTurnpoints = parseInt(match[11], 10);
          var comment = match[12] || null;
          return {
            declarationDate,
            declarationTime,
            declarationTimestamp,
            flightDate,
            taskNumber,
            numTurnpoints,
            comment,
            points: []
          };
        };
        IGCParser3.prototype.parseTaskPoint = function(line) {
          var match = line.match(RE_TASKPOINT);
          if (!match) {
            throw new Error("Invalid task point declaration at line " + this.lineNumber + ": " + line);
          }
          var latitude = IGCParser3.parseLatitude(match[1], match[2], match[3], match[4]);
          var longitude = IGCParser3.parseLongitude(match[5], match[6], match[7], match[8]);
          var name = match[9] || null;
          return { latitude, longitude, name };
        };
        IGCParser3.prototype.parseBRecord = function(line) {
          if (!this._result.date) {
            throw new Error("Missing HFDTE record before first B record");
          }
          var match = line.match(RE_B);
          if (!match) {
            throw new Error("Invalid B record at line " + this.lineNumber + ": " + line);
          }
          var time = match[1] + ":" + match[2] + ":" + match[3];
          var timestamp = this.calcTimestamp(time);
          var latitude = IGCParser3.parseLatitude(match[4], match[5], match[6], match[7]);
          var longitude = IGCParser3.parseLongitude(match[8], match[9], match[10], match[11]);
          var valid = match[12] === "A";
          var pressureAltitude = match[13] === "00000" ? null : parseInt(match[13], 10);
          var gpsAltitude = match[14] === "00000" ? null : parseInt(match[14], 10);
          var extensions = {};
          if (this.fixExtensions) {
            for (var _i = 0, _a = this.fixExtensions; _i < _a.length; _i++) {
              var _b = _a[_i], code = _b.code, start = _b.start, length = _b.length;
              extensions[code] = line.slice(start, start + length);
            }
          }
          var enl = null;
          if (extensions["ENL"]) {
            var enlLength = this.fixExtensions.filter(function(it) {
              return it.code === "ENL";
            })[0].length;
            var enlMax = Math.pow(10, enlLength);
            enl = parseInt(extensions["ENL"], 10) / enlMax;
          }
          var fixAccuracy = extensions["FXA"] ? parseInt(extensions["FXA"], 10) : null;
          return {
            timestamp,
            time,
            latitude,
            longitude,
            valid,
            pressureAltitude,
            gpsAltitude,
            extensions,
            enl,
            fixAccuracy
          };
        };
        IGCParser3.prototype.parseKRecord = function(line) {
          if (!this._result.date) {
            throw new Error("Missing HFDTE record before first K record");
          }
          if (!this.dataExtensions) {
            throw new Error("Missing J record before first K record");
          }
          var match = line.match(RE_K);
          if (!match) {
            throw new Error("Invalid K record at line " + this.lineNumber + ": " + line);
          }
          var time = match[1] + ":" + match[2] + ":" + match[3];
          var timestamp = this.calcTimestamp(time);
          var extensions = {};
          if (this.dataExtensions) {
            for (var _i = 0, _a = this.dataExtensions; _i < _a.length; _i++) {
              var _b = _a[_i], code = _b.code, start = _b.start, length = _b.length;
              extensions[code] = line.slice(start, start + length);
            }
          }
          return { timestamp, time, extensions };
        };
        IGCParser3.prototype.parseIJRecord = function(line) {
          var match = line.match(RE_IJ);
          if (!match) {
            throw new Error("Invalid " + line[0] + " record at line " + this.lineNumber + ": " + line);
          }
          var num = parseInt(match[1], 10);
          if (line.length < 3 + num * 7) {
            throw new Error("Invalid " + line[0] + " record at line " + this.lineNumber + ": " + line);
          }
          var extensions = new Array(num);
          for (var i = 0; i < num; i++) {
            var offset = 3 + i * 7;
            var start = parseInt(line.slice(offset, offset + 2), 10) - 1;
            var end = parseInt(line.slice(offset + 2, offset + 4), 10) - 1;
            var length = end - start + 1;
            var code = line.slice(offset + 4, offset + 7);
            extensions[i] = { start, length, code };
          }
          return extensions;
        };
        IGCParser3.parseLatitude = function(dd, mm, mmm, ns) {
          var degrees = parseInt(dd, 10) + parseFloat(mm + "." + mmm) / 60;
          return ns === "S" ? -degrees : degrees;
        };
        IGCParser3.parseLongitude = function(ddd, mm, mmm, ew) {
          var degrees = parseInt(ddd, 10) + parseFloat(mm + "." + mmm) / 60;
          return ew === "W" ? -degrees : degrees;
        };
        IGCParser3.prototype.calcTimestamp = function(time) {
          var timestamp = Date.parse(this._result.date + "T" + time + "Z");
          while (this.prevTimestamp && timestamp < this.prevTimestamp - ONE_HOUR) {
            timestamp += ONE_DAY;
          }
          return timestamp;
        };
        return IGCParser3;
      }()
    );
    module2.exports = IGCParser2;
  }
});

// igc2kmz/nodewrapper.ts
var nodewrapper_exports = {};
__export(nodewrapper_exports, {
  igc2Data: () => igc2Data,
  igc2kml: () => igc2kml,
  igc2kmz: () => igc2kmz
});
module.exports = __toCommonJS(nodewrapper_exports);
var import_fs = require("fs");
var import_promises = require("fs/promises");
var PImage = __toESM(require_pureimage_umd());
var import_base64_stream = __toESM(require_base64_stream());
var import_concat_stream = __toESM(require_concat_stream());

// assets/OpenSans-Regular.ttf
var OpenSans_Regular_default = "data:font/ttf;base64,AAEAAAASAQAABAAgR0RFRrTIsWAAAbBoAAABvkdQT1NbqnJwAAGyKAAAOXRHU1VCg+2ZlwAB65wAAA8GT1MvMpZAgywAAWucAAAAYFNUQVRe+0M1AAH6pAAAAF5jbWFwwzgfgAABa/wAAAP2Y3Z0ID0/LMgAAYIoAAAA/GZwZ23iGZ5aAAFv9AAAD5RnYXNwABUAIwABsFgAAAAQZ2x5Zrc6q6MAAAEsAAFPOGhlYWQbnTS6AAFZcAAAADZoaGVhDcgI9gABa3gAAAAkaG10eFPsQ1cAAVmoAAARzmxvY2GSTkCCAAFQhAAACOptYXhwB/sQpQABUGQAAAAgbmFtZamdzEYAAYMkAAAFxnBvc3QmrJycAAGI7AAAJ2pwcmVwhf176QABf4gAAAKfAAIAlv/kAYQFtgADAA8AFkAKAQEHBw0LcgICcgArKzIRM3wvMDFBIwMzAzQ2MzIWFRQGIyImAUVtLsndRDMyRUUyM0QBlgQg+rJGOztGRT8/AAACAIcDpgKpBbYAAwAHABC2BQGABAMCcgArMhrNMjAxQQMjAyEDIwMBOyZpJQIiJWklBbb98AIQ/fACEAACADQAAAT2BbYAGwAfADlAGwEcHA4AHx8ZFRUSEg8ECAgLCw4OChcTAgYKCAA/Mz8zEjkvMxEzETPOMhEzETMyETMRMxEzMDFBAyEVIQMjEyEDIxMhNSETITUhEzMDIRMzAyEVASETIQPUQQEb/sxVh1X+z1KFT/76AR9D/uoBLVOJUwEzU4RTAQn85AExQv7PA4P+rH/+UAGw/lABsH8BVH0Btv5KAbb+Sn3+rAFUAAMAf/+JBBcGEgAkACwANQAoQBQbLi4oLAkcLQ0GARQSESUICCMAAQAvzTMzETMvzTMSFzkzETMwMUU1JiYnNRYWFxEuAjU0NjY3NTMVFhYXByYmJxEeAhUUBgcVETY2NTQmJicnEQ4CFRQWFgIGc9FCRdhphK1WYbB2emuwSzREnlCGtVzWwXt5L2pbektmMy1ld9ICJB2iIDACAbglX4piZpFSBq2rAykgixsmB/5LJ1iCZ5KzE9oBbgxfTjhINRjQAYcFLkozO083AAUAZv/sBjcFywALABcAGwAnADMAIkARKBwuIg1yGgwSBgAbGwwABXIAKzIyLxDMMj8rMswyMDFBMhYVFAYjIiY1NDYXIgYVFBYzMjY1NCYlASMBEzIWFRQGIyImNTQ2FyIGFRQWMzI2NTQmAY+Wm5abkJmSl1FMTFFUUlEDSfzVkgMra5WclpuRmJGYUUxMUVRSUQXL79ra8/Pa2u93qamprKypqKpi+koFtv3L79rZ8/PZ2u94qKmpq6mrqKkAAAMAb//sBckFzQAlADAAPAArQBkHHjcDABIwDwgmBQsLAC0WC3IQCnIxAANyACsyKysyETkvFzkSFzkwMUEyFhYVFAYHATY2NzMGBgcBIycOAiMiJiY1NDY2Ny4CNTQ2NhMOAhUUFjMyNjcBIgYVFBYXNjY1NCYCb2ydVamCAZY3RhioIGVMASXhtUCTs3OMznFOkGQvVDRbpxlObzuehIi/Q/6gW3FSTH1xaQXNS4xjgrRK/nZAqWOE3lT+4bE7WTFcsoFqmHY4NGt7SmSOTPz1LVhuTnWNWkAEK19VTIBORYFXT2IAAQCHA6YBOwW2AAMACrMBAwJyACvNMDFBAyMDATsmaSUFtv3wAhAAAAEAUv68Ah4FtgAQAAqzDQQCcgArLzAxUzQSEjczBgIVFBISFyMmAgJSQYZmn5GSQYFfnWaGQQIxqQFAASJ6vv4w9aD+yf7ggHgBGwE8AAEAPv68AgoFtgARAAqzDQJyBQAvKzAxQRQCAgcjNhISNTQCAiczFhISAgpBhWedYIFBQoFhn2eFQQIzp/7D/uR3fwEiATegowE8ASR/e/7f/sEAAAEAWQKGBAoGFAAOABtAEAUJBwQKCwMNAQIMCwYIgAAALxrNMhc5MDFBAyUXBRMHAwMnEyU3BQMCiyYBixr+hvSitaao8v6IHAGFJwYU/nNzryf+u1kBZP6cWQFFJ69zAY0AAQBnAOYEKATAAAsADrQKCQkFBgAvMzMRMzAxQSEVIREjESE1IREzAowBnP5kif5kAZyJAxaI/lgBqIgBqgABAFP++AF6AO4ACgAMswWAAQAALzIazTAxZRcOAgcjPgI3AW0NEjdBIXwVKCEK7hdJpqdJULGtSAAAAQBSAdwCQgJwAAMACLEBAAAvMjAxUzUhFVIB8AHclJQAAAEAlv/kAYQA6QALAAqzAwkLcgArMjAxdzQ2MzIWFRQGIyImlkQxM0ZGMzFEaEY7O0ZFPz8AAAEAFQAAAtkFtgADAAu0AwJyAQgAPyswMUEBIwEC2f3gpAIhBbb6SgW2AAIAZ//sBCsFzQAQACAAELcdDQVyFQUNcgArMisyMDFBFAIGBiMiJgI1NBI2MzIWEgUUEhYzMjYSNTQCJiMiBgIEKzZ0uIGj1Wlf1K6l1mj84z6LcXGLPz6Kc3OKPQLdsv7owmWyAVHu6gFRtbP+r+zM/vCHhgEQzckBD4mJ/vEAAQC5AAACzwW2AA0AFUAKCwoKBgwEcgAMcgArKzIyLzMwMWEjETQ2NjcGBgcHJwEzAs+iAQMDHzYop1cBjIoEDDtVRyUgLSGGcQExAAEAZQAABCMFywAdABdACwoSBXIbAhwcAQxyACsyETMzKzIwMWEhNQE+AjU0JiMiBgcnPgIzMhYWFRQGBgcBFSEEI/xCAYdtlU6TeGmiVVk6iZ1Zh8RrXKZv/sIC64sBjW6sp2R8g0hCcDFMLF6ueHTHw23+wwcAAAEAXP/sBBoFywAuAB9ADwUEHBwbGwwkLAVyEwwNcgArMisyETkvMxI5OTAxQRQGBgcVFhYVFAYGIyImJzUWFjMyNjU0JiYjIzUzMjY2NTQmIyIGBgcnNjYzMhYD7UyIXK6vd/W/dMVaW9ZkyLJjuYKSk3emV5R/ToBwOFRQ5pLg4ARhYpBbEggWtJJ/xG8lK5wtM5+KX3U3jkZ/V295IDglcj5azAACACwAAARsBb4ACgAWAB9ADwYWCQkFAQECEgcEcgIMcgArKzIROS8zMxEzMzAxQSMRIxEhNQEzETMhETQ+AjcjBgYHAQRs26L9PQK4rdv+gwIEAwEIEzEZ/j0BU/6tAVOMA9/8KwHeN1lNRiIoWSP9gQABAIT/7AQdBbYAIQAjQBEaGRkWFh8AAAgeGwRyDwgNcgArMisyETkvMzMRMxEzMDFBMhYWFRQGBiMiJic1FhYzMjY2NTQmIyIGBycTIRUhAzY2AjOV3HmC9KpyxENJ0GJvp12zwT6UMFQ4Atf9tyUmeAN+ZcCJltl1KCieLDRHkW6SnxQMNwKumP5HCBEAAgB0/+wEMAXLACIAMQAfQA8SESkpFhYGIx4Ncg0GBXIAKzIrMhI5LzMRMzMwMVM0PgMzMhYXFSYmIyIGAgczPgIzMhYWFRQGBiMiLgIBMjY1NCYjIgYGFRQeAnQlWJjjny1oIiVfMLrVXgcLH2CJW4C/aXDPj2u0hUoB7IikkpNklFInUHoCcYT82aRdCQqPDQyi/uutMlEwaMaNl9x3UqLx/qeusJCoU35BQoh0RgABAF0AAAQsBbYABgATQAkFAgIDBHIADHIAKysyETMwMWEBITUhFQEBIgJY/OMDz/2sBR6YgPrKAAMAZ//sBCkFywAfAC4APAAaQA4rGAg2BAAjEA1yLwAFcgArMisyERc5MDFBMhYWFRQGBgceAhUUBgYjIiYmNTQ2NjcuAjU0NjYDFBYzMjY1NCYmJycOAgEiBhUUFhYXPgI1NCYCSH/Eb02CT16XWHfWkJvZcVaOVEl5R3HFwp6gmKZMjF8kXIFEATx2lkl+Tkx2RJUFy1CbcVmFYycrbJJke7NgXa97ZZVsJShmiVtvm1H7p3CRkXZJb1gkDSZddgODcWpMaUsgIE1qSmpwAAACAGf/6wQlBcsAIgAxAB9ADxESKSkWFgYjHgVyDQYNcgArMisyETkvMxEzMzAxQRQOAyMiJic1FhYzMjYSNyMOAiMiJiY1NDY2MzIeAgEiBhUUFjMyNjY1NC4CBCUlWZjlnytuIyVkMLvWXgYMHmGKXH+9aXPQjWy0hUn+EoWljpRmlVEnUHoDR4X82qRdCwqQDQ+hARWtMFExaMaMl914UqPwAViur5GoUn5CQohzRwAAAgCW/+QBhARiAAsAFwAQtxUPB3IDCQtyACsyKzIwMXc0NjMyFhUUBiMiJhE0NjMyFhUUBiMiJpZEMTNGRjMxREQxM0ZGMzFEaEY7O0ZFPz8DvEg7O0hEPj4AAgBB/vgBgARiAAoAFgAStxQOB3IBBYAKAC8azTkrMjAxZRcOAgcjPgI3AzQ2MzIWFRQGIyImAVwOEjhBIH4VKCMKGUQxNURENTFE7hdIp6dJT7GuSALxSDs7SEQ+PgAAAQBnAPMEKQTYAAYAErcCBQEDBAMGAAAvMs4yFzkwMWUBNQEVAQEEKfw+A8L88gMO8wGqXwHclP6P/rMAAgBzAcEEHQPhAAMABwAMswEABAUALzPOMjAxUzUhFQE1IRVzA6r8VgOqA1qHh/5nh4cAAAEAZwDzBCkE2AAGABK3BQEEAwIDAAYALzPOMhc5MDFTAQE1ARUBZwMP/PEDwvw+AYYBSwFzlP4kX/5WAAIAH//kAzwFywAfACsAF0ALHx8jIykLcgwTA3IAKzIrMhEzLzAxQTU0NjY3PgI1NCYjIgYHJzY2MzIWFRQGBgcOAhUVAzQ2MzIWFRQGIyImASAeS0NOWyiGemOaRzpSwHbB1DxuS0JGGrFCNDFFRTE0QgGWNFBzZDhBW1xBaG8yI4YrNr+nXYNtPThVWT4h/tJGOztGRT8/AAACAHb/Rwa3BbQAQQBPAClAE0lMTBYTJT4DcglFRR0FBQyALjUALzMazDIvMzIRMysyzDIyETMwMUEUDgIjIiYnIwYGIyImNTQ2NjMyFhcDBgYVFBYzMjY2NTQCJCMiBAYCFRQSBDMyNjcVBgYjIiQCNTQSNiQzMgQSARQWMzI2NxMmJiMiBgYGtytYg1ldbgsJJpNrnKlrw4VZqDIUAQJNN0NbMJr+8bCv/vG7YJEBGcp64llY2oPx/qq2d+EBQcnXAUu9++5qXnRtCAwdUy1nfzoC2l+1kVZsSk9nz6yGz3ceEv5tJScLbEtpsWy/AQ6Obsn+7KfM/uKVNiKCJS+1AVTuwQFE7oOx/rn+moV8ro8BBQkNYpwAAgAAAAAFDQW8AAcAEgAbQA0NAxICAgMFAnIHAwhyACsyKxE5LzMROTAxYQMhAyMBMwEBAy4CJw4CBwMEXbT9trOsAjyZAjj+aasGGxwJChcWCK4B0P4wBbz6RAJnAc0SUlgbKVFFGP4zAAMAyAAABLwFtgASABsAJQAfQA8JCBMTHBwAHRIIchsAAnIAKzIrMhI5LzMSOTkwMVMhIAQVFAYGBxUeAhUUBgYjIRMhMjY1NCYjIxERITI2NTQmJiPIAZ4BEgEUQXxbYJRUfeSc/gmqARi/k6+//AEww6JJo4gFtqTFVYdYEQoPUJBvh7pfA0N+eX1u/Y/93ZmCU3Y/AAEAff/sBMsFywAfABC3ABkDcgkQCXIAKzIrMjAxQSIOAhUUEhYzMjY3FQYGIyIkAjU0EjYkMzIWFwcmJgM5ecGHSHPlrGKtUlCwed/+1ZVdswEFqW/OU0RGpwU1U53ei7j+8ZQhGZQeHbkBUuamARPIbSwpkCAvAAIAyAAABVEFtgAKABQAELcQBgJyEQUIcgArMisyMDFBFAIEIyERITIEEgc0AiYjIxEzIAAFUbT+q/P+cwG53wFCr7OD/bf1zwEuAS8C6ff+tacFtqP+wfHFAQB9+20BKgAAAQDIAAAD9gW2AAsAGUAMBgkJAQUCAnIKAQhyACsyKzIROS8zMDFhIREhFSERIRUhESED9vzSAy79fAJf/aEChAW2lv4nlP3jAAABAMgAAAP2BbYACQAXQAsGCQkBBQICcgEIcgArKzIROS8zMDFhIxEhFSERIRUhAXKqAy79fAJd/aMFtpb96JUAAQB9/+wFOAXLACEAGUAMIQAABRQNA3IcBQlyACsyKzIROS8zMDFBIREGBiMiJAI1NBIkMzIWFwcmJiMiBgIVFBIWMzI2NxEhAzkB/3PzluT+x6KzAVPuetteQVHDaLP/h3b6xWOOOv6rAv79OycmtgFR6OMBUrstKZQjMpT+8rm3/vGWFxABwAAAAQDIAAAFHAW2AAsAGUAMCAMDBQsGAnIBBQhyACsyKzIROS8zMDFhIxEhESMRMxEhETMFHKr9AKqqAwCqArH9TwW2/ZECbwAAAQDIAAABcgW2AAMADLUBAnIACHIAKyswMXMRMxHIqgW2+koAAf9c/n8BagW2ABEADLQNAnIHAAAvMiswMUMiJic1FhYzMjY2NREzERQGBgsyTBsgSis4XjirW6f+fw4MkQoLLGpdBa76X4m0WQABAMgAAATmBbYADgAaQA4DAggOBAUNBgJyAQUIcgArMisyEhc5MDFhIwEHESMRMxE2NjcBMwEE5sn98Zyqqjl4OwGrx/26AseM/cUFtv0nQYFCAdX9hgAAAQDIAAAD+wW2AAUADrYBAnIDAAhyACsyKzAxcxEzESEVyKoCiQW2+uKYAAABAMgAAAZqBbYAFwAcQA8LDBUBBAgOCgJyFxAICHIAKzIyKzISFzkwMWEBIx4CFREjETMBMwEzESMRNDY2NyMBA0v+FQgEBgSe/AHPBwHW+qgEBgMI/g8FDil2i0j8ZAW2+0AEwPpKA6hBg3Ur+vQAAQDIAAAFPwW2ABMAF0ALAgwJEwsCcgEJCHIAKzIrMhI5OTAxYSMBIx4CFREjETMBMy4CNREzBT/E/OMIAwgFnsMDGgcCBgWgBMwxfY1J/LgFtvs4I4GVQANPAAACAH3/7AW8Bc0AEQAgABC3HQ4DchYFCXIAKzIrMjAxQRQCBgYjIiYmAjU0EiQzMgQSBRQSFjMyNhI1EAIjIgYCBbxWqfqlqv2nU5QBLePZASmZ+3Rq26mq2Wjt+6rcawLdqf7rx2xsyAEWqeABUry6/q/luv7wlJQBELoBGwE/kv7zAAACAMgAAARmBbYADAAWABdACw8JCQsODAJyCwhyACsrMhE5LzMwMUEgBBUUDgIjIxEjEQUjETMyNjY1NCYCRgEbAQU9iN2gsqoBbsSfjLteugW23c5dp39J/cEFtpH9rDyHcJKPAAACAH3+pAW8Bc0AFgAlABlADCITA3IEBxsbBQoJcgArzDMSOTkrMjAxQRQCBgcBIwEiBiMiJiYCNTQSJDMyBBIFFBIWMzI2EjUQAiMiBgIFvGLBkAFY8/7lDRsNqv2nU5QBLePZASmZ+3Rq26mq2Wjt+6rcawLdtP7cyi7+lwFKAmzIARap4AFSvLr+r+W6/vCUlAEQugEbAT+S/vMAAAIAyAAABM4FtgAPABgAHUAOCBISDAwOEQ8CcgoOCHIAKzIrMhE5LzMSOTAxQTIWFhUUBgYHASMBIREjEQUjETMyNjU0JgJTtOt0VIhNAZHG/pr+0KoBgdfos6mzBbZZto10m2Aa/W8CYv2eBbaT/c+SjpV8AAABAGn/7AQBBcsALwAcQBAQABQsKBkGBCQdA3IMBAlyACsyKzISFzkwMUEUBgYjIiYmJzUWFjMyNjY1NCYmJy4DNTQ2NjMyFhcHJiYjIgYGFRQWFhceAgQBgeidU5R8L0vYdm6YT0KZhF2OYDF304l1x1M1T7FeXoFEQY92gbReAYWCt2AQHhajHzU7b05LZVMvIU9khFV1p1ksJZIhLDdkRU1mTysvaZcAAAEAEgAABFMFtgAHABNACQcDAwQCcgEIcgArKzIRMzAxYSMRITUhFSECiav+NARB/jYFIJaWAAEAuf/sBRoFtgATABC3EwkCcg4FCXIAKzIrMjAxQREUBgYjIAA1ETMRFBYzMjY2NREFGn38vv7x/uWrxcSGq1MFtvxOm/KLASb2A678TbrKYa9zA7QAAQAAAAAExQW2AA4AE0AJCQIOAwJyAghyACsrMhI5MDFBASMBMwEeAhc+AjcBBMX986v987IBVhUhGgoKGiIVAVQFtvpKBbb8PTpqYi4uY2s7A8AAAQAeAAAHRQW2ACkAG0AOCBckAw8pHhACcgIPCHIAKzIrMjIRFzkwMUEBIwEuAycOAwcBIwEzEx4DFz4DNwEzAR4DFz4CNxMHRf55q/7eDRcUDQMCCxEXDf7mq/58sesMFREOBgUQExcNAQevARIOGBMPBgcUGxDrBbb6SgPYKlVNOw8POkxWLPwpBbb8ay5ZVFAmJ1VYWi0Di/xuL1xXTyMxbHY/A5QAAQAGAAAEmAW2AAsAGkAOAgULCAQBCgYCcgEECHIAKzIrMhIXOTAxYSMBASMBATMBATMBBJjB/nX+b7UB5/47vQFtAW+0/jwChP18AvoCvP25Akf9RwABAAAAAAR5BbYACAAXQAwGAwADBAIHAnIECHIAKysyEhc5MDFBATMBESMRATMCPQGFt/4Zqv4YugLZAt38gf3JAi8DhwAAAQBOAAAERQW2AAkAGUAMBwQEBQJyAggIAQhyACsyETMrMhEzMDFhITUBITUhFQEhBEX8CQMT/QgDx/zsAymABJ6YgPtiAAEApv68AmsFtgAHAA61BQICcgYBAC8zKzIwMUEhESEVIREhAmv+OwHF/t0BI/68BvqI+hgAAAEAFQAAAtsFtgADAAy1AwJyAQhyACsrMDFTASMBuQIipf3fBbb6SgW2AAEAM/68AfkFtgAHAA61AAcDBAJyACsyLzMwMVchESE1IREhMwEj/t0Bxv46ugXoiPkGAAABAFACJQREBcEABgAOtQUEAAERcgArzTI5MDFTATMBIwEBUAG3YAHdlf6K/qwCJQOc/GQC6v0WAAH//P7NA4X/SAADAAixAQIALzMwMUEhNSEDhfx3A4n+zXsAAAEAUgTZAecGIQAMABK3CwQAgA8GAQYAL10azTk5MDFBHgIXFSMuAyc1ARgYR08hcSRVVEQTBiEucWsmGB1QWVEdFAAAAgBe/+wDywRaAB0AKAAjQBIHJSULHhMTAAsLcgQKchcAB3IAKzIrKxI5LzMRMxEzMDFBMhYVESMnIw4CIyImJjU0JCU3NTQmIyIGByc2NgEHBgYVFBYzMjY1AknEvnkgCC5kg19km1kBBAEKvXpvVpxGM0rAAUinzahyXpK6BFqwwf0XojxRKUaObaSwCAhDjnIyIn4mNv3CBwh2bF5aoqIAAgCv/+wEcwYUABYAJAAlQBQWAHIVCnISEx8fDwtyBQQXFwgHcgArMhEzMysyETMzKyswMUERFAYHMzY2MzISERQGBiMiJicjByMRASIGBhUVFBYzMjY1NCYBVQcCCS2qhM71cMyLgqctDSJ4AeZ3jD2KtpmZlwYU/ntDfiNKZv7j/ue5/oJhRpMGFP28XbuPCc/b4NDU1gABAHL/7AOSBFwAHQAQtw8IB3IXAAtyACsyKzIwMUUiJiY1NDY2MzIWFwcmJiMiBgYVFBYWMzI2NxUGBgJmlOJ+heqVUpkxMjKDOXKXS0mRbVeMOTeHFHr6vsf9eiEZixQgYr6LhbxjJRmUHB4AAAIAcv/sBDUGFAAXACQAJUAUEQpyEAByCwofHwYHchMUGBgAC3IAKzIRMzMrMhEzMysrMDFFIgIREBIzMhYWFzMmJjURMxEjJyMOAicyNjU1NCYjIgYVFBYCNdDz+M5Xgl4gDAQIpoYZBx9fgz+wkou3mZiXFAEcARgBGwEhLk0xH2wiAbf57JwxUC+KyMUe0eDry8rcAAIAcv/sBBMEXAAXAB8AGUAMGwYGAAkQC3IYAAdyACsyKzISOS8zMDFBMhYWFRUhFhYzMjY3FQYGIyImJjU0EjYXIgYHIS4CAlWMyGr9CwO6qWigVlOjb57rgnfZkYWeDwJEATt4BFx835VnwcomJZIlIoH6tbEBA4yIrpxilVMAAQAeAAADDgYfABgAG0AOBgUBARcGchMMAXIDCnIAKysyKzIRMzkwMUEhESMRIzU3NTQ2NjMyFhcHJiYjIgYVFSECl/7vpsLCUpxwP2koKyJVLF9bAREDxvw6A8ZQN0mKrVIWDoMLE3uDUAAAAwAf/hQELwReAC8APwBLAC1AFiIMQEAgBjk5KSkAGhcXRhMHcjAAD3IAKzIrMjIRMxE5LzMSOcYyETk5MDFBIiY1NDY3JiY1NDY3JiY1NDY2MzIWFhchFQcWFhUUBiMiJwYGFRQWFjMzMhYVFAQlMjY2NTQmJiMjIgYGFRQWEzI2NTQmIyIGFRQWAeHY6oN0Kz1DRVZrYrqEHTs2FAF4yh4o3sIuMDEzJ0o0wbO//tj+7YizWTx0VL5KbjuWtnd4endye3z+FKGRZ5IYFFA0PFsqI6dvdqdYBQkGaxknbkOkwQgbQisgJhGWkLbCgjdnR0JDFy5aQ1ldA2x4c3t7f3pweAABAK8AAARBBhQAGgAbQA4aAHIPGQpyBAUTEwkHcgArMhEzMysyKzAxQREUBgczPgIzMhYWFREjETQmIyIGBhURIxEBVQQFCyJphkuEsVmkfYF6kT+mBhT+LyhRIjpPKVSwjP02Ar+JiF20gv3DBhQAAgCgAAABaAXiAAMADwAQtwQKAwZyAgpyACsrzjIwMUERIxETMhYVFAYjIiY1NDYBVaZVKTs7KSs5OQRI+7gESAGaNTg3NjY3ODUAAAL/kP4UAWgF4gAQABwAE0AJFBoLBnIHAA9yACsyK84yMDFTIiYnNRYWMzI2NREzERQGBhM0NjMyFhUUBiMiJiszTBwfQChEVKZAhA85Kyk7OykrOf4UDwqHCgtMZAT5+wtkj0wHYTg1NTg3NjYAAQCvAAAEJAYUABIAIEATEgByDw4EBQsIBgoNDREKcgoGcgArKzIREhc5KzAxQREUBgczNjY3ATMBASMBBxEjEQFUBgIHFVEcAWzD/kcB2cj+fYWlBhT82ChzLBpmHwGE/iz9jAIHev5zBhQAAQCvAAABVgYUAAMADLUCAHIBCnIAKyswMWEjETMBVqenBhQAAQCvAAAGwgRcACcAKEAXHB0kJQQTEyEJAAdyIQdyGgZyDgUZCnIAKzIyKysrMhEzERczMDFBMhYVESMRNCYjIgYVESMRNCYmIyIGBhURIxEzFzM+AjMyFhczNjYFVbW4pHNxn5ClM2VNbYQ7poYZCSFkfEZ9qSYJNrwEXL3R/TICxoWFuLP9mwLGWXY7WrGB/bwESJs5TihdX19dAAABAK8AAARBBFwAFQAbQA4PBnIFDgpyEhEJCQAHcgArMhEzMysyKzAxQTIWFREjETQmIyIGFREjETMXMz4CArbDyKR9gbaUpoYZCSNshgRcv9P9NgK/iYjOxP3CBEieOk8pAAIAcv/sBGAEXAARACAAELceDgdyFgULcgArMisyMDFBFA4CIyIuAjU0NjYzMhYWBRQWFjMyNjY1NCYmIyIGBGBGhLt2breFSXrjnZbhffy+RpJzcpNGRpJ0q58CJofUkk1NktSHtP2Fhv2zhMJqasKEg79o4gACAK/+FgRzBFwAGAAoACVAFBIGchEOcgsMIiIHC3IVFBkZAAdyACsyETMzKzIRMzMrKzAxQTISERQGBiMiJiYnIxYWFREjETMXMz4CFyIGBgcVFBYWMzI2NjU0JgKyzfRwy4pXhF4fDAMJp4kWCCBchT5yi0ACPY13ZohDlwRc/ub+5bv+gi5OLiduKf4+BjKiMlMxjFivhCCLwGRuxYDC5QACAHH+FgQ0BFwAFgAkACVAFBYOchUGchMSHx8PB3IEBRcXCAtyACsyETMzKzIRMzMrKzAxQRE0NjcjBgYjIgIRNDY2MzIWFzM3MxEBMjY2NzU0JiMiBhUUFgOOBAULLqqGyfRwzYmDpi8IGYT+GXSMQQKQs5qWlv4WAdYnZiVMZgEcARq5/oNnSp35zgJgV7CDI9Tb68nJ3wAAAQCvAAADJgRcABUAGUANDwZyDgpyEhEHBwAHcgArMhEzMysrMDFBMhYXByYmIyIOAhURIxEzFzM+AgKhIUgcFRtCHUJ1WDKnihIHImB/BFwHBpoHCDVji1X9tARIyj1lPAABAGf/7AN0BFwAKgAaQA4OEicWBAQgGQdyCwQLcgArMisyEhc5MDFBFAYGIyImJzUWFjMyNjU0JiYnLgI1NDYzMhYXByYmIyIGFRQWFhceAgN0acOHc6g/Q7phjoAzeGppmVPht2OtSzhEmlBzezl+Z2eWUQEsaY9IJCGZITZcTy1FQScoT3Jbi5UnIYUdKExCM0I6JyZRcwAAAQAg/+wCqwVGABgAHUAODhINFRUQDxIGcgAHC3IAKzIrMs0zETMSOTAxZTI2NxUGBiMiJiY1ESM1NzczFSEVIREUFgIRKVYbHWcxV45VnJ1CZAFB/r9fdA4KgQ0SPZKBAopRQe7+gv17Z2YAAQCj/+wEOARIABcAG0AOFw0GcgMEEhIIC3IBCnIAKysyETMzKzIwMUERIycjDgIjIiYmNREzERQWMzI2NjURBDiIGAkibIdMgrBZqHx/epFABEj7uJo5TidUsIoCzv0+iYdcs4ICQQABAAAAAAP/BEgADQAVQAoHBgAMAQZyAApyACsrMhI5OTAxYQEzExYWFzM2NjcTMwEBoP5gsvEZNAoHDDgX8bL+XwRI/WlEpDIypUMCl/u4AAEAGAACBhsESgAqABtADhUiBgMOKR0PBnIqDgpyACsyKzIyEhc5MDFlAy4DJyMOAwcDIwEzEx4CFzM+AzcTMxMeAhczPgI3EzMBBCvDDRcTDwUHBA4TFg7Mu/7SrJ4QHRUFCAYPExYLyrPDDx0YBQgEFh0QoKn+0QICfilPST8XFz9KUSn9hQRI/aM8dWcmGUZPTyMCe/2GMGhhJiJkeD4CXfu4AAABACcAAAQJBEgACwAcQA8JBgADBAEICAsKcgUBBnIAKzIrMhESFzkwMUEBMwEBMwEBIwEBIwG0/oW+ASEBILz+hQGQvv7N/su8AjECF/5aAab96f3PAb/+QQABAAL+EwQCBEgAHQAaQA4GHRwNBAAYEQ9yDAAGcgArMisyEhc5MDFTMxMeAhczNjY3EzMBDgIjIiYnNRYWMzI2Njc3ArLyFSQcCAcONB7ls/4jJmWQZi9IGhY/Ij5bQhg8BEj9hDhnXiwyo1UCe/sXZZZRCweFBQgvWj6aAAABAFAAAANvBEgACQAZQAwHBAQFBnICCAgBCnIAKzIRMysyETMwMWEhNQEhNSEVASEDb/zhAln9zQLs/a8CXm4DWIJ7/LQAAQA5/rwCvgW2ACUAHUANHB0KCgkJABQTAnIlAAAvMisyEjkvMxI5OTAxQS4CNRE0JiYjNT4CNRE0NjYzFQ4CFREUBgcVFhYVERQWFhcCvnyzXzhuUVFuOGSzd0ppN2pucGg2aUv+vAFHjmsBMkdXKIoBJ1ZHATRrjUaIAipWRP7TaH4UDBN+af7NRFUoAQAAAQHs/hACdwYVAAMACLEAAgAvLzAxQTMRIwHsi4sGFff7AAEAQ/68AsgFtgAlAB1ADQoJHBwdHQASEwJyAQAALzIrMhI5LzMSOTkwMVM1PgI1ETQ2NzUmJjURNCYmJzUeAhURFBYWMxUiBgYVERQGBkNKaDdrbW9pNmhLfLJfOG9RUW84ZLL+vIoCKVVEAS9pfhMMFH5oATBFVikBiAFGjWz+0EhXKIooVkb+ymqORwABAGcCUQQpA1MAGQAdQAwUExMDCheABwYGEBcALzMzLzMaEM0yMi8zMDFBJiYjIgYHNTY2MzIWFxYWMzI2NxUGBiMiJgIqR2IvOX8zMntJPnVYSWAtO34yMHpKPHYCkiAZRDSVNTYbJh8aRDSTNDkaAAACAJb+igGEBFwAAwAPABO3AAAHBw0HcgIALysyETN9LzAxUzMTIxMUBiMiJjU0NjMyFtRvLsveRTIyRUUyMkUCqfvhBU9GOztGRD8/AAABALn/7APdBcsAIwAUtxoYEBciCAABAC/NMzMvM80zMDFBFRYWFwcmJiMiBgYVFBYWMzI2NxUGBgcVIzUuAjU0NjY3NQLQTY0zMDeFOHOYS0qTbliIPjd3UIB9tmJktnsFy6UDIBeLFR9gv4+OuVsiGpEbIALHzBJ96rS374ESrQAAAQBEAAAERAXJACMAJUASFxMTFh4LCx0ODgAWDHIHAAVyACsyKxI5LzMzETMRMxEzMDFBMhYXByYmIyIGFREhFSEVFAYGByEVITU+AjU1IzUzETQ2NgKub7BGPD2VU3l+AaD+YChBJgMY/AA9XjXHx2W4BckvIoYdL4CO/uF/3lRvQxaYjQ5EeFvgfwExfK5dAAACAHkBBgQXBKEAIwAzAEpAIyEeHigVGBgoKBsWFxcgHxsPDAwwAwYGMDAJDg0NBAUJCRsMAD8zL84yMhEzETMRMxEzETMRMxDOMjIRMxEzETMRMxEzETMwMVM0NjcnNxc2NjMyFhc3FwcWFhUUBgcXBycGBiMiJicHJzcmJjcUFhYzMjY2NTQmJiMiBga3KSKJXIoxeEJAdDKLXIchKyclhVqLMHZAQnoviluIIimASX1MTn5KSn5NTX1JAtM/dzGNWoYjJycjhlqMMHdBQHkxilmGIicnJIdZizF3QE19SUp9TE5+S0t+AAABAB8AAARwBbYAFgAsQBUAFBQRCgcHDRADBgYREQwBFQRyDAwAPysyEjkvMxEzzjIyETMRMxEzMDFBATMBIRUhFSEVIREjESE1ITUhNSEBMwJIAXmv/lwBCP7FATv+xaL+xAE8/sQBBP5gsQLlAtH8/Xuue/7xAQ97rnsDAwACAez+EAJ3BhUAAwAHAAyzBAYDAAAvMi8zMDFBMxEjETMRIwHsi4uLiwYV/Pf+Dvz2AAIAev/3A48GHgA2AEUAGkAPLyEzHjxDAxcILCQQCQFyACsyLzMXOTAxUzQ2NyYmNTQ2MzIWFwcmJiMiBhUUFhYXHgIVFAYHFhYVFAYjIiYnNR4CMzI2NTQmJicuAjcUFhYXFzY2NTQmJicGBoxmQ0xWz8BxnkszRY1gfWw0eWVollFfPklR59FxqUAtdIBAm3csdW1pmFKPOoFqNjRVO459PmADKWV+HydvVXqOJx6AHCdEPik+OiUlV3RUaIYjJW1Qi5skH5AVJxhcPio+PSgnVHdsNVBFKBMdX0Y2VEomEGAAAAIBNgUQA2sF0gALABcADrQPFRUDCQAvMzMRMzAxQTQ2MzIWFRQGIyImJTQ2MzIWFRQGIyImATY0Jic1NScmNAGANCUmNjYmJTQFcjIuLjIxMTExMi4uMjExMQAAAwBk/+wGRAXLABMALgBCABtADSIbOQoDcigUgC8ACXIAKzIazDIrMswyMDFFIiQmAjU0EjYkMzIEFhIVFAIGBAMiJjU0NjYzMhYXByYmIyIGFRQWMzI2NxUGBgcyPgI1NC4CIyIOAhUUHgIDVKP+7ctvcMsBE6KdARHOdHDL/u2CysxhuYRCgjk4MmIvf4x/iTJzNDFoZ4XpsGRfrOuMjOutX16t6xRwygEToqMBE8pwccv+7qKi/u3KcAEm+dCFzXUgHXQaG7GaoKwaFXoWHMBgr+2Nhuq0ZWCv7Y2G67NlAAIARAMTAm4FxwAcACcAH0AOBiQkEh0ABQUJwBYAA3IAKzIazDIvETk5MhEzMDFBMhYVESMnBgYjIiYmNTQ2Njc3NTQmIyIGByc2NhMHBgYVFBYzMjY1AWiChFsXJ3JNQF8zRpBtcFU+N2cuKzSC1GJ8Wj41aF0Fx253/j5XKzksWkNEXDIEBC9FOB0YXxoh/pcEBEA6NTFjUwACAE8AegOrA8UABgANACRAEgsMDAUJCAgGDQMKAAcGAgEEBQAvM8wyFzkyETMRMxEzMDFTARcBAQcBJQEXAQEHAU8BVHf+4QEfd/6sAY4BWXX+4gEedf6nAiwBmUT+n/6fRQGXGwGZRP6f/p9FAZcAAQBnAQcEJAMWAAUADrQBAQQEBQAvMxEzLzAxQREjESE1BCSG/MkDFv3xAYeI//8AUgHcAkICcAYGABAAAAAEAGT/7AZEBcsADQAWACoAPgAjQBIMCA4DABYBNSEDcgoAgCsXCXIAKzIazDIrMswyERc5MDFBESEyFhUUBgcTIwMjEREzMjY1NCYjIxMiJCYCNTQSNiQzMgQWEhUUAgYEJzI+AjU0LgIjIg4CFRQeAgI/AQWjnGNA7aTPim9TX1hcbYSj/u3Lb3DLAROinQERznRwy/7tooXpsGRfrOuMjOutX16t6wEcA32DhGFxGf51AWT+nAHaUkZNRPvNcMoBE6KjARPKcHHL/u6iov7tynBmYK/tjYbqtGVgr+2NhuuzZQAB//oGFAQGBpMAAwAIsQIBAC8zMDFBITUhBAb79AQMBhR/AAACAHUDWwL4BcsADwAbABC2EADAFggDcgArMhrMMjAxQSImJjU0NjYzMhYWFRQGBicyNjU0JiMiBhUUFgG2YJBRT5BiX5FSUpFdYmJlX2ViYQNbTo1cXY1PT41dXI1Ocm1YXG1tXFhtAAIAZwAABCoExQADAA8AG0ALDgQNDQkHCgoBAQAALzIRMy8zMzMRMzMwMXM1IRUBIRUhESMRITUhETNnA8P+YgGc/mSJ/mQBnImHhwMbiP5YAaiIAaoAAQAyA1QCcwbTABoAErcCGRkAeAoRdwA/M+QyETMwMUEhNTc+AjU0JiMiBgcnNjYzMhYVFAYGBwchAnP9v+1SWCFOQj1nNUM8jFaClDdrTaoBmgNUaOhQZlIvQkcvKVkyPIFwRHJ0SaQAAAEAJQNFAo0G0wApABtADAYHHR0aGhQNeCMAdwA/MuQyOS8zEjk5MDFBMhYVFAYHFRYWFRQGIyImJzUWFjMyNjU0JiMjNTMyNjU0JiMiBgcnNjYBU4+SWT5RX6uyS4M9RIo+bGd3bHd3aGFVQEBvN0Q+jAbTfmJUahMGEGlTd5QaHnkgJFdLTEVqUkNBQCsjWS02AAABAFIE2QHnBiEADAAStwEIDIAPBgEGAC9dGs05OTAxQRUOAwcjNT4CNwHnFEVUVSRvIExIGAYhFB1RWVAdGCZrcS4AAAEAr/4UBEMESAAdACFAEREMCwQDGBgIC3IBCnIUAAZyACsyKysyETMzMzMvMDFBESMnIw4CIyImJyMeAhURIxEzERQWMzI2NjURBEOHGgkiXn1RVnkoCAMEAqamgIF8jj0ESPu4mDZNKTYuGEdZNf6xBjT9PIWJXbOBAkEAAAEAev78BF0GFAASABK2BgkJAxEFAAAvMi8zOS8zMDFBIxEjESMRBgYjIiYmNTQ2NjMhBF1v2HAfTiV9uGVuxoUCKv78Bq35UwNFCQlh2bS93F4A//8AlgJGAYQDSwYHABEAAAJiAAEAHP4UAasAAAAWABC1ExAKA8ASAC8azDI5OTAxQRQGIyImJzUWFjMyNjU0Jic3MwceAgGrlpEfOBETPB5LUGtTWW82MlEw/uJhbQcEaQQGLDQ3MgmwcAoqRgAAAQBMA1QB4QbBAA0AEkAJCwoMBwQCeA13AD/kFzkwMUERIxE0NjY3BgYHByclAeGHAgMCFTQdbUIBCwbB/JMCNiQ/PR0TKhNNXrkAAAIAQwMTAr0FyAAMABgAELYQAwMWCQNyACsyMi8zMDFBFAYjIiY1NDYzMhYWBRQWMzI2NTQmIyIGAr2tk4uvqpRhjU79/1xmZl1cZmVeBG+kuLOpprNRmm55fX15eHp4AAIATQB6A6kDxQAGAA0AGkAPAgkKDQcABgQDCwoFDAEIAC8zzDIXOTAxQQEnAQE3AQUBJwEBNwEDqf6ndAEe/uJ0AVn+b/6qdQEe/uJ1AVYCEv5oRQFiAWBE/mgb/mhFAWIBYET+aAAABABCAAAF2QW2AAMAEQAcACUANkAcFR4eGBgTIhsbFhIDAxIMcg0MDgkEBA8BAQ8EcgArMi8QzBc5KzIvEMw5LzkzMxEzETMwMWEBMwEDETQ2NjcGBgcHJyUzEQE1ITUBMxEzFSMVASE1NDY3BgYHAQcDbpD8kUYCAwIVNB1tQgELiQL1/m4BlYuAgP5nAQsCAws9FwW2+koCSgI2JD89HRMqFExeuPyU/bbNYgJE/cxyzQE/zyxuMRleIgADACwAAAXQBbYAAwASAC0AJkAUFCsrHCMTDHIODQ8KBAQQAQEQBHIAKzIvEMwXOSvMMjMRMzAxcwEzAQMRND4CNwYGBwcnJTMRATU3PgI1NCYjIgYHJzY2MzIWFRQGBgcHIRXQA2+P/JEmAQMDARYzHW1CAQuKAc7tUlgiUEE+ZjVCO41VgpQ4ak2qAZoFtvpKAkoCNhsxLi0WEyoUTF64/JT9tmjoUGZSL0JHLylZMjyBcERydEmkdwAEACEAAAYoBckAAwAtADgAQQA/QB8xOjo0NC8+NzcyLgMDLgxyJygUFBERCwQhGgEBIQVyACsyLzIQzDI5LzMSOTkrMi8QzDkvOTMzETMRMzAxYQEzAQMiJic1FhYzMjY1NCYjIzUzMjY1NCYjIgYHJzY2MzIWFRQGBxUWFhUUBgE1ITUBMxEzFSMVASE1NDY3BgYHAWQDb4/8kshKhD1Eiz5sZ3hsd3doYVVAQG44RD6NXo6SWD5QYKwDPP5uAZWLgID+aAEKAwMNPBcFtvpKAjobHnkhI1ZMTEVqUkNBQCsjWC42f2JTahMHEGhTd5X9xs1iAkT9zHLNAT/PLG4xGV4iAAIANf53A1IEXgAfACsAFkAJAAAjIykHcgwTAC8zKzIRM30vMDFBFRQGBgcOAhUUFjMyNjcXBgYjIiY1NDY2Nz4CNTUTFAYjIiY1NDYzMhYCUR5LQ05cJ4d5Y5pHOlK/d8HUPG9KQ0UasUE1MUVFMTVBAqw0T3RkOEFbXEFobzMihis2v6ddg209OFVZPiEBLkY7O0ZFPz///wAAAAAFDQeQBiYAJAAAAQcAQwEpAW8ACrMZBQJyACvOMDH//wAAAAAFDQeQBiYAJAAAAQcAdgHAAW8ACrMZBQJyACvOMDH//wAAAAAFDQePBiYAJAAAAQcBSgDnAW8ACrMfBQJyACvOMDH//wAAAAAFDQdMBiYAJAAAAQcBUQC7AW8ACrMkBQJyACvOMDH//wAAAAAFDQdBBiYAJAAAAQcAagA0AW8ADLQoHAUCcgArzs4wMf//AAAAAAUNBwoGJgAkAAAABwFPAVQAggAC//4AAAaBBbYADwATACtAFRMJCRADCg0DDQMNBQYCcg4BAQUIcgArMhEzKxE5OS8vETMRMzIRMzAxYSERIQMjASEVIREhFSERIQEhESMGgf0E/gfesAKvA9T9rgIr/dUCUvtNAbdzAdD+MAW2lv4nlP3jAdECt///AH3+FATLBcsGJgAmAAAABwB6AhYAAP//AMgAAAP2B5AGJgAoAAABBwBDARUBbwAKsxICAnIAK84wMf//AMgAAAP2B5AGJgAoAAABBwB2Aa0BbwAKsxICAnIAK84wMf//AMgAAAP2B48GJgAoAAABBwFKANMBbwAKsxICAnIAK84wMf//AMgAAAP2B0EGJgAoAAABBwBqACEBbwAMtCEVAgJyACvOzjAx////9AAAAYkHkAYmACwAAAEHAEP/ogFvAAqzCgECcgArzjAx//8AtAAAAkkHkAYmACwAAAEHAHYAYgFvAAqzCgECcgArzjAx////zgAAAm8HjwYmACwAAAEHAUr/fAFvAAqzCgECcgArzjAx//8ABgAAAjsHQQYmACwAAAEHAGr+0AFvAAy0DRkBAnIAK87OMDEAAgA6AAAFUQW2AA4AHAAfQA8MERELFBQJEA4CchUJCHIAKzIrMhE5LzMzETMwMUEyBBIVFAIEIyERIzUzEQUjESEVIREzIAARNAImAoHeAUOvtP6q9P6Cm5sBkukBdP6MwwEvAS6E/QW2o/7B6/f+tacCiZUCmJH9+ZX+CQEqASfFAQB9AP//AMgAAAU/B0wGJgAxAAABBwFRATwBbwAKsxQKAnIAK84wMf//AH3/7AW8B5AGJgAyAAABBwBDAcIBbwAKsycOA3IAK84wMf//AH3/7AW8B5AGJgAyAAABBwB2AlgBbwAKsygOA3IAK84wMf//AH3/7AW8B48GJgAyAAABBwFKAX8BbwAKsy0OA3IAK84wMf//AH3/7AW8B0wGJgAyAAABBwFRAVIBbwAKszIOA3IAK84wMf//AH3/7AW8B0EGJgAyAAABBwBqAMwBbwAMtDYqDgNyACvOzjAxAAEAhQEQBAoElgALACRAEwcJAQMICwIFCAoGAAAKCgYEBAYALzMvETMvMy8REhc5MDFBFwEBBwEBJwEBNwEDrF7+ngFhX/6c/qNjAWH+nmMBYASWYf6e/p5hAWD+oGEBYgFgY/6cAAMAff/CBbwF9wAaACUAMAA5QBwqHh4YGBUVLS0XFhIDch8pKQsLCAgiIgoJBQlyACvOMjMRMxEzETMRMyvOMjMRMxEzETMRMzAxQRQCBgYjIiYnByc3JgI1NBIkMzIWFzcXBxYSBzQmJwEWFjMyNhIlFBYXASYmIyIGAgW8Vqn6pXbASmZ0bltalAEt42u6S2Jzal1jszg3/V84kluq2Wj8JzQ0Ap42ilWq3GsC3an+68dsMzOQTJxkAR+y4AFSvDMui0+UYv7htobZTPxMKC2UARC6gtNNA64mKJL+8wD//wC5/+wFGgeQBiYAOAAAAQcAQwGPAW8ACrMaCQJyACvOMDH//wC5/+wFGgeQBiYAOAAAAQcAdgImAW8ACrMbCQJyACvOMDH//wC5/+wFGgePBiYAOAAAAQcBSgFNAW8ACrMhCQJyACvOMDH//wC5/+wFGgdBBiYAOAAAAQcAagCbAW8ADLQpHQkCcgArzs4wMf//AAAAAAR5B5AGJgA8AAABBwB2AXgBbwAKsxAHAnIAK84wMQACAMgAAARnBbYADgAYAB9ADw8GGAsGCwYLCAkCcggIcgArKxE5OS8vETMRMzAxQRQOAiMjESMRMxEzIAQBMzI2NjU0JiMjBGc8h9+jsKqq0QEiAQL9C56Qu1y3y8MDDl6nf0n+vwW2/wDd/fk9h2+TjQABAK//7ASdBh8APAAVQAsuOQFyNApyGhILcgArMisrMjAxQRQOAxUUFhYXHgIVFAYGIyImJzUeAjMyNjU0JiYnLgI1ND4DNTQmIyIGBhURIxE0NjYzMhYWBBo6VVU6HU9KSGo5XqlxYZA2JV1qNnRnJVVHU2IqOFRTOJFzTYBMpnTKgYHAawT0R2ZOQkEoHzA9MTBid1NwkkcjIJcVJhhjVDVOSy42WFk4QVlEQE84WFIrZ1v7WQSniaVKQ4X//wBe/+wDywYhBiYARAAAAQcAQwDcAAAACrMvAAdyACvOMDH//wBe/+wDywYhBiYARAAAAQcAdgF0AAAACrMvAAdyACvOMDH//wBe/+wDywYgBiYARAAAAQcBSgCaAAAACrM1AAdyACvOMDH//wBe/+wDywXdBiYARAAAAQYBUW0AAAqzOgAHcgArzjAx//8AXv/sA8sF0gYmAEQAAAEGAGroAAAMtD4yAAdyACvOzjAx//8AXv/sA8sGiAYmAEQAAAEHAU8BCgAAAA23AwIpAAEBgFYAKzQ0AAADAF7/7AZ9BFwAMQA9AEUAM0AaCRAQGEEGJSwHciEyBjIGADkYC3IvPj4AB3IAKzIRMysyEjk5Ly8zKzIRMxEzETMwMUEyFhYHFSEWFjMyNjcVBgYjIiYmJw4CIyImJjU0NjY3NzU0JiMiBgcnNjYzMhYXNjYBBwYGFRQWMzI2NjUBIgYHITYmJgTThb9mAf07BKacZJpRUp1lYJ95KC1vmGtknVpv36e6fmxRnUY0SsdkgaUnNa7+qZ3BoG1bWoxQAch5kgsCEQE2cARcfN6SacrDJiWSJSI3a05JbDtGjm1tl1MFCEeLcTEjfic1WmVbZv3ABwh2bF5aSJBsAh2poWOVUgD//wBy/hQDkgRcBiYARgAAAAcAegFeAAD//wBy/+wEEwYhBiYASAAAAQcAQwDqAAAACrMmAAdyACvOMDH//wBy/+wEEwYhBiYASAAAAQcAdgGBAAAACrMmAAdyACvOMDH//wBy/+wEEwYgBiYASAAAAQcBSgCoAAAACrMsAAdyACvOMDH//wBy/+wEEwXSBiYASAAAAQYAavYAAAy0NSkAB3IAK87OMDH////4AAABjQYhBiYDrwAAAQYAQ6YAAAqzCgIGcgArzjAx//8AjwAAAiQGIQYmA68AAAEGAHY9AAAKswoCBnIAK84wMf///7UAAAJWBiAGJgOvAAABBwFK/2MAAAAKsxACBnIAK84wMf///+cAAAIcBdIGJgOvAAABBwBq/rEAAAAMtBkNAgZyACvOzjAxAAIAcf/sBFsGHQAkADQAIUATJQQFJAMhBh4gHwkWFgAtDgtyAAAvKzISOS8XOTMwMUEWFhc3FwcWFhIVFAIGIyImJjU0NjYzMhYWFzcmJicFJzcmJicTIgYGFRQWFjMyNjU0LgIBt0SCOutIzF+PT3jin5LhfnbXkUt6XyAJIIlZ/vVH5ytgMfVzlEdHk3KroidQfQYdH0oriWZ3Wen+5KW+/vyEeN+Ymdx3GzYpA3nOUZpohR45Gf2VVKJ1aKBZ0MY+b1cy//8ArwAABEEF3QYmAFEAAAEHAVEArAAAAAqzJwAHcgArzjAx//8Acv/sBGAGIQYmAFIAAAEHAEMBDAAAAAqzJw4HcgArzjAx//8Acv/sBGAGIQYmAFIAAAEHAHYBpAAAAAqzJw4HcgArzjAx//8Acv/sBGAGIAYmAFIAAAEHAUoAygAAAAqzLQ4HcgArzjAx//8Acv/sBGAF3QYmAFIAAAEHAVEAngAAAAqzMg4HcgArzjAx//8Acv/sBGAF0gYmAFIAAAEGAGoYAAAMtCo2DgdyACvOzjAxAAMAZwD9BCoEpQADAA8AGwAUtwQKABYQAQEAAC8yEM4yEM4yMDFTNSEVASImNTQ2MzIWFRQGAyImNTQ2MzIWFRQGZwPD/h4uPj4uLD4+LC4+Pi4sPj4CjoiI/m85PUE0NEE9OQK+OT1ANDRAPTkAAwBy/70EYASFABgAIgAtADVAGh0mJhYWICAVFBAHciccHAoKBwcqKgkIBAtyACvOMjMRMxEzETMRMyvOMjMRMxEzETMwMUEUBgYjIiYnByc3JiY1EAAzMhYXNxcHFhYFFBYXASYmIyIGBTQmJwEWFjMyNjYEYHvjnU+HOVhtYT1DAQ/rToo4VXBhPET8vhkcAdQlYDqrnwKWGhr+LCNhOXKTRgImtP+HJSV5S4RLzYIBDgEoKCZ3SYRJyn9SiTQCgBse4shPhjP9fxscasIA//8Ao//sBDgGIQYmAFgAAAEHAEMBGAAAAAqzHg0GcgArzjAx//8Ao//sBDgGIQYmAFgAAAEHAHYBrwAAAAqzHw0GcgArzjAx//8Ao//sBDgGIAYmAFgAAAEHAUoA1QAAAAqzHg0GcgArzjAx//8Ao//sBDgF0gYmAFgAAAEGAGojAAAMtC0hDQZyACvOzjAx//8AAv4TBAIGIQYmAFwAAAEHAHYBOwAAAAqzJQAGcgArzjAxAAIAr/4WBHMGFAAcACoAIUASFiAgGgdyEAByDw5yCScnBAtyACsyETMrKysyETMwMUEUBgYjIiYmJyMeAhURIxEzERQGBzM+AjMyEgM0JiMiBgcVFBYzMjY2BHNwyolYhF4gDAIGBKenBAIHIF2EWs30q5WcrJMCjrNnh0MCJ7v+gi5NLxJFSBj+Nwf+/jMfYh0xUTH+4v7r1NPFwiTQ32XC//8AAv4TBAIF0gYmAFwAAAEGAGqvAAAMtDMnAAZyACvOzjAx//8AAAAABQ0G0AYmACQAAAEHAUwBBwFvAAqzFQUCcgArzjAx//8AXv/sA8sFYQYmAEQAAAEHAUwAugAAAAqzKwAHcgArzjAx//8AAAAABQ0HVgYmACQAAAEHAU0BBAFvAAqzFwUCcgArzjAx//8AXv/sA8sF5wYmAEQAAAEHAU0AtwAAAAqzLQAHcgArzjAx//8AAP4+BQ0FvAYmACQAAAAHAVADcAAA//8AXv4+A/4EWgYmAEQAAAAHAVACYQAA//8Aff/sBMsHkAYmACYAAAEHAHYCQwFvAAqzJhkDcgArzjAx//8Acv/sA5IGIQYmAEYAAAEHAHYBgQAAAAqzJAgHcgArzjAx//8Aff/sBMsHjwYmACYAAAEHAUoBaQFvAAqzLBkDcgArzjAx//8Acv/sA5oGIAYmAEYAAAEHAUoApwAAAAqzKggHcgArzjAx//8Aff/sBMsHUQYmACYAAAEHAU4CVgFvAAqzJhkDcgArzjAx//8Acv/sA5IF4gYmAEYAAAEHAU4BkgAAAAqzJAgHcgArzjAx//8Aff/sBMsHjwYmACYAAAEHAUsBZgFvAAqzIBkDcgArzjAx//8Acv/sA5YGIAYmAEYAAAEHAUsAowAAAAqzHggHcgArzjAx//8AyAAABVEHjwYmACcAAAEHAUsBPgFvAAqzFQYCcgArzjAx//8Acv/sBXAGFAYmAEcAAAEHAjQC+wAAAAu2AjEPAAAAVgArNAD//wA6AAAFUQW2BgYAkgAAAAIAcv/sBNAGFAAfACwAKkAVFRISGA8PBhoKEwByJwoGBxsgIAALAD8yETM/MzMrPxE5LzMzETMwMUUiAhEQEjMyFhYXMyYmNTUhNSE1MxUzFSMRIycjDgInMjY1NTQmIyIGFRQWAjXQ8/jNV4JfIAwFB/5FAbumm5uIGAgfXoM9sJCKt5mXlhQBGwEVAR8BHC5OMB9sJIN9urp9+yOcMVAvisXEINLc5szK2///AMgAAAP2BtAGJgAoAAABBwFMAPQBbwAKsw4CAnIAK84wMf//AHL/7AQTBWEGJgBIAAABBwFMAMkAAAAKsyIAB3IAK84wMf//AMgAAAP2B1YGJgAoAAABBwFNAPABbwAKsxACAnIAK84wMf//AHL/7AQTBecGJgBIAAABBwFNAMYAAAAKsyQAB3IAK84wMf//AMgAAAP2B1EGJgAoAAABBwFOAb4BbwAKsxICAnIAK84wMf//AHL/7AQTBeIGJgBIAAABBwFOAZMAAAAKsyYAB3IAK84wMf//AMj+PgP2BbYGJgAoAAAABwFQAk8AAAADAHL+PgQTBFwAFQAtADUAKUAUIxIRER8fJjEcHBYDCiYLci4WB3IAKzIrzDISOS8zETMRMxEzMzAxRRQWMzI2NxUGBiMiJjU0NjY3Nw4CAzIWFhUVIRYWMzI2NxUGBiMiJiY1NBI2FyIGByEuAgMUMi0hMRAcOSdpZTpYLJdQWSO/jMhq/QsDuqlooFZTo2+e64J32ZGFng8CRAE7ePEvMQkEbAcLZFo6bV0hEUBjVQUifN+VZ8HKJiWSJSKB+rWxAQOMiK6cYpVTAP//AMgAAAP2B48GJgAoAAABBwFLANABbwAKswwCAnIAK84wMf//AHL/7AQTBiAGJgBIAAABBwFLAKQAAAAKsyAAB3IAK84wMf//AH3/7AU4B48GJgAqAAABBwFKAZ0BbwAKsy4NA3IAK84wMf//AB/+FAQvBiAGJgBKAAABBgFKbgAAC7YDUhMBAXtWACs0AP//AH3/7AU4B1YGJgAqAAABBwFNAboBbwAKsyYNA3IAK84wMf//AB/+FAQvBecGJgBKAAABBwFNAIcAAAALtgNQEwEBe1YAKzQA//8Aff/sBTgHUQYmACoAAAEHAU4CiQFvAAqzKA0DcgArzjAx//8AH/4UBC8F4gYmAEoAAAEHAU4BXAAAAAu2A1ITAQGWVgArNAD//wB9/jsFOAXLBiYAKgAAAAcEcQFCAAD//wAf/hQELwYgBCYCNh0AAwYASgAAAAqzBR8HcgArzjAx//8AyAAABRwHjwYmACsAAAEHAUoBVgFvAAqzGAYCcgArzjAx////twAABEEH7QYmAEsAAAEHAUr/ZQHNAAu2ASEaAQGSVgArNAAAAgAAAAAF5AW2ABMAFwAnQBMLBAcHDgEXEhQUAAkFAnIQAAhyACsyKzIROS8zzjIyMhEzMzAxcxEjNTM1MxUhNTMVMxUjESMRIRERITUhyMjIqgMAqsjIqv0AAwD9AAQ1ifj4+PiJ+8sCsf1PA0fuAAEAFAAABEEGFAAiACNAEiEeHgEEBA0iAHITHQpyFw0GcgArMisyKxI5LzMzETMwMUEVIRUhFRQGBzM+AjMyFhYVESMRNCYjIgYGFREjESM1MzUBVQG5/kcEBQsiaYdMg7BZpH2BepE/ppubBhS7fr0oTyI6TypVsYz9WgKbiYhds4L95gTbfrsA////rQAAApQHTAYmACwAAAEHAVH/WwFvAAu2AQQBAQGVVgArNAD///+JAAACcAXdBiYDrwAAAQcBUf83AAAACrMVAgZyACvOMDH////zAAACSgbQBiYALAAAAQcBTP+hAW8AC7YBBgEBAZRWACs0AP///9YAAAItBWEGJgOvAAABBgFMhAAACrMGAgZyACvOMDH////nAAACVQdWBiYALAAAAQcBTf+VAW8AC7YBCAEBAZJWACs0AP///9MAAAJBBecGJgOvAAABBgFNgQAACrMIAgZyACvOMDH//wBY/j4BowW2BiYALAAAAAYBUAYA//8AMf4+AXwF4gYmAEwAAAAGAVDfAP//AL0AAAGFB1EGJgAsAAABBwFOAGsBbwALtgEKAQEBwVYAKzQA//8AyP5/A6YFtgQmACwAAAAHAC0CPAAA//8AoP4UA20F4gQmAEwAAAAHAE0CBQAA////XP5/AmkHjwYmAC0AAAEHAUr/dgFvAAqzHgwCcgArzjAx////kP4UAlYGIAYmA7AAAAEHAUr/YwAAAAqzHQsGcgArzjAx//8AyP47BOYFtgYmAC4AAAAHBHEAqwAA//8Ar/47BCQGFAYmAE4AAAAGBHErAAABAK8AAAQkBEgAEgAbQA8FBA0BEQUHEggGcgMHCnIAKzIrMhIXOTAxQQEBIwEHESMRMxEUBgczNjY3AQQC/mEBwcb+kI+wsAcFBBQtEwGOBEj+HP2cAfl8/oMESP7iUp8vGzcZAdMA//8ApwAAA/sHkAYmAC8AAAEHAHYAVQFvAAqzDAECcgArzjAx//8AjwAAAiQH7gYmAE8AAAEHAHYAPQHNAAqzCwIAcgArzjAx//8AyP47A/sFtgYmAC8AAAAGBHFwAP//AIP+OwF9BhQGJgBPAAAABwRx/w8AAP//AMgAAAP7BbYGJgAvAAABBwI0AYP/ogALtgESAQAAAFYAKzQA//8ArwAAApkGFAYmAE8AAAEGAjQkAAALtgEQAgAAAFYAKzQA//8AyAAAA/sFtgYmAC8AAAAHAU4CVP1u//8ArwAAAnIGFAQmAE8AAAAHAU4BWP2WAAEAGgAAA/sFtgANABxAEQIBAwoEBwkICAAFAnILAAhyACsyKxIXOTAxcxEHJzcRMxElFwURIRXIa0OuqgEhRP6bAokCAj5xagMX/U2seNH+MpgAAAH/8gAAAhcGFAALABpAEAIBAwoECQcICAAFAHIACnIAKysSFzkwMXMRByc3ETMRNxcHEaRuRLKmh0bNAlRFcHMDIv1JXXCL/UH//wDIAAAFPweQBiYAMQAAAQcAdgI+AW8ACrMaCgJyACvOMDH//wCvAAAEQQYhBiYAUQAAAQcAdgGyAAAACrMdAAdyACvOMDH//wDI/jsFPwW2BiYAMQAAAAcEcQEQAAD//wCv/jsEQQRcBiYAUQAAAAcEcQCBAAD//wDIAAAFPwePBiYAMQAAAQcBSwFhAW8ACrMUCgJyACvOMDH//wCvAAAEQQYgBiYAUQAAAQcBSwDVAAAACrMWAAdyACvOMDH//wACAAAEwgW2BCcAUQCBAAAABgIG6AAAAQDI/n8FPwW2ACEAG0AOCxYMAxMdFQJyEwhyBwAALzIrKzISFzkwMUEiJic1FhYzMjY2NQEjHgIVESMRMwEzLgI1ETMRFAYGA8YyTxwgUC04Yj/8vwgDCAWewwMaBwMGBKBcqf5/Dg2PCQsqaFsEyimKnkj8zQW2+1stg5ZIAxf6VYawVgABAK/+FARDBFwAJAAhQBIXGBgODhwHchUGchQKcgcAD3IAKzIrKysyETMRMzAxQSImJzUWFjMyNjURNCYjIgYGFREjETMXMz4CMzIWFhURFAYGAyUxRBobOyQ+T3yAeZJBpoYbCSNphUuFsFk/fv4UDwqHCgtMZANyiYZcsoL9wARInjpPKVSwjPyHZI9MAP//AH3/7AW8BtAGJgAyAAABBwFMAZ8BbwAKsyMOA3IAK84wMf//AHL/7ARgBWEGJgBSAAABBwFMAOoAAAAKsyMOB3IAK84wMf//AH3/7AW8B1YGJgAyAAABBwFNAZwBbwAKsyUOA3IAK84wMf//AHL/7ARgBecGJgBSAAABBwFNAOcAAAAKsyUOB3IAK84wMf//AH3/7AW8B5AGJgAyAAABBwFSAdIBbwAMtCc0DgNyACvOzjAx//8Acv/sBGAGIQYmAFIAAAEHAVIBHQAAAAy0JzQOB3IAK87OMDEAAgB9/+4G6wXLABgAKAAtQBglIiIRCXIHCgoDCw4IcgYDAnImGRkAA3IAKzIRMysyKzISOS8zKzIRMzAxQTIWFyEVIREhFSERIRUhBgYjIiQCNTQSJBciDgIVFBIWMzI2NxEmJgMVNGEtAxT9pAI1/csCXPz1LGI04/7Vk5MBJ+2BvXs9a96qOGYoKWIFywoLlv4nlP3jlggKvAFT4uIBULqWUpzejLr+8ZMRDwR2EA4AAAMAcP/sByoEWgAkADMAOwAtQBYhJSU3BgYWNAAAHgdyEywsCRAQFgtyACsyETMyETMrMhEzETkvMzIRMzAxQTIWFhUVIRYWMzI2NxUGBiMiJicGBiMiJiY1NDY2MzIWFz4CBSIGFRQWFjMyNjY1NCYmJSIGByE0JiYFcovEaf0eBK+ka51TU55sktY+PNOMkd59eOCaiM46JnGS/UCml0ONcG+MQ0SNAqaAmA0CLjh1BFp73pVnysEmJZIlInp3dnuG/7Wz/IV8dExrOYrZ0YzBY2K9io7BYgKnoWOUUQD//wDIAAAEzgeQBiYANQAAAQcAdgG3AW8ACrMgDwJyACvOMDH//wCvAAADJgYhBiYAVQAAAQcAdgEhAAAACrMdDwZyACvOMDH//wDI/jsEzgW2BiYANQAAAAcEcQCnAAD//wB9/jsDJgRcBiYAVQAAAAcEcf8JAAD//wDIAAAEzgePBiYANQAAAQcBSwDaAW8ACrMZDwJyACvOMDH//wCVAAADNgYgBiYAVQAAAQYBS0MAAAqzFg8GcgArzjAx//8Aaf/sBAEHkAYmADYAAAEHAHYBggFvAAqzNx0DcgArzjAx//8AZ//sA3QGIQYmAFYAAAEHAHYBJAAAAAqzMhkHcgArzjAx//8Aaf/sBAEHjwYmADYAAAEHAUoAqQFvAAqzPR0DcgArzjAx//8AZ//sA3QGIAYmAFYAAAEGAUpKAAAKszcZB3IAK84wMf//AGn+FAQBBcsGJgA2AAAABwB6AS8AAP//AGf+FAN0BFwGJgBWAAAABwB6AQcAAP//AGn/7AQBB48GJgA2AAABBwFLAKUBbwAKszAdA3IAK84wMf//AGf/7AN0BiAGJgBWAAABBgFLRgAACrMrGQdyACvOMDH//wAS/jsEUwW2BiYANwAAAAYEcUAA//8AIP47AqsFRgYmAFcAAAAGBHG9AP//ABIAAARTB48GJgA3AAABBwFLAJEBbwAKswgEAnIAK84wMf//ACD/7AOsBhQGJgBXAAAABwI0ATcAAAABABIAAARTBbYADwAhQBAKBgYOAgILAwMABwJyAAhyACsrETkvMzMRMzIRMzAxYREhNSERITUhFSERIRUhEQHd/sUBO/41BEH+MwE5/scCoYwB8ZiY/g+M/V8AAAIAIP/sAqsFRgADABwAJUASEBkZFhITEwABgBUWBnIECwtyACsyK80azDIzETMRMxEzMDFTNSEVAzI2NxUGBiMiJiY1ESM1NzczFSEVIREUFjACX34pVhsdZzFXjlWcnUJkAUH+v18CPn9//jYOCoENEj2SgQKKUUHu/oL9e2dmAP//ALn/7AUaB0wGJgA4AAABBwFRASYBbwAKsxQJAnIAK84wMf//AKP/7AQ4Bd0GJgBYAAABBwFRAK0AAAAKsxgNBnIAK84wMf//ALn/7AUaBtAGJgA4AAABBwFMAW0BbwAKsxYJAnIAK84wMf//AKP/7AQ4BWEGJgBYAAABBwFMAPYAAAAKsxoNBnIAK84wMf//ALn/7AUaB1YGJgA4AAABBwFNAWoBbwAKsxgJAnIAK84wMf//AKP/7AQ4BecGJgBYAAABBwFNAPMAAAAKsxwNBnIAK84wMf//ALn/7AUaB/cGJgA4AAABBwFPAb0BbwANtwIBFBMBAZNWACs0NAD//wCj/+wEOAaIBiYAWAAAAQcBTwFGAAAADbcCARgXAQGSVgArNDQA//8Auf/sBRoHkAYmADgAAAEHAVIBoAFvAAy0GygJAnIAK87OMDH//wCj/+wETAYhBiYAWAAAAQcBUgEoAAAADLQfLA0GcgArzs4wMQACALn+PgUaBbYAFQApAB9ADykfAnISEREkJAMKChsJcgArMi8zMhEzETMrMjAxRRQWMzI2NxUGBiMiJjU0NjY3Nw4CAREUBgYjIAA1ETMRFBYzMjY2NREDsjMtITARHDknamRBXit2PFIqAWh9/L7+8f7lq8XEhqtT3j41CQRsBwtpZ0F+aB8SQ21hBmH8TpvyiwEm9gOu/E26ymGvcwO0AP//AKP+PgRKBEgGJgBYAAAABwFQAq0AAP//AB4AAAdFB48GJgA6AAABBwFKAhIBbwAKszcQAnIAK84wMf//ABgAAgYbBiAGJgBaAAABBwFKAX0AAAAKszcPBnIAK84wMf//AAAAAAR5B48GJgA8AAABBwFKAJ4BbwAKsxUHAnIAK84wMf//AAL+EwQCBiAGJgBcAAABBgFKYgAACrMkAAZyACvOMDH//wAAAAAEeQdBBiYAPAAAAQcAav/sAW8ADLQeEgcCcgArzs4wMf//AE4AAARFB5AGJgA9AAABBwB2AY0BbwAKsxEFAnIAK84wMf//AFAAAANvBiEGJgBdAAABBwB2ARoAAAAKsxEFBnIAK84wMf//AE4AAARFB1EGJgA9AAABBwFOAZ8BbwAKsxAFAnIAK84wMf//AFAAAANvBeIGJgBdAAABBwFOAS0AAAAKsxAFBnIAK84wMf//AE4AAARFB48GJgA9AAABBwFLAK8BbwAKswoFAnIAK84wMf//AFAAAANvBiAGJgBdAAABBgFLPQAACrMKBQZyACvOMDEAAQCvAAAC2QYfABAADrYACgFyBQpyACsrMjAxQSIGFREjETQ2NjMyFhcHJiYCElljp1igbT1hJyogUwWUcYT7YQSgialNFw6ECxMAAAEAvv4UBA4FywAlACNAECAhIQseDg4LCwAaEw9yBwAALzIrMhI5LzMRMxEzETMwMUEyFhcHJiYjIgYVFSEVIREUBgYjIiYnNRYWMzI2NREjNTc1NDY2A0E+aCcpIlIsXVcBFf7vTZRqKEkbH0EiWFLV1U+aBcsbDoILFWaDkoL8Mn+cRgwHiwgLX3kDzFA4i4ujRwAE//4AAAUSB6wAEgAeACoANwAmQBMTGQENHwQREQcSCA8IMDA3NyUHAC8zMy8zLz8/EjkvFzkzMDFjASYmNTQ2MzIWFRQGBwEjAyEDEyEDLgInDgMHEzI2NTQmIyIGFRQWAzU+AjczFQ4DBwICFjI6fGFhgzoyAhWxrv2hqOQB8bIKGRoLCBMSEQdDNkNDNjREQCAeQz4WyBE+TE8jBNYZX0Vlc3JlQ2AZ+ygBkv5uAioBrxhBSiMbODYvEQFDQDo5Pj45OUEBhxIiV1onEBhCR0MYAAUAXv/sA8sHqAAdACgANABBAE0ANEAaBiUlEx4eAAsLcgUKQ01NSUdHKTUvPBcAB3IAKzLeMswyMi8zMxEzPysROS8zMhEzMDFBMhYVESMnIw4CIyImJjU0JCU3NTQmIyIGByc2NgEHBgYVFBYzMjY1AyIGFRQWMzI2NTQmJzIWFhUUBiMiJjU0NgEVDgIHIzU+AjcCScS+eSAILmSDX2SbWQEEAQq9em9WnEYzSsABSKfNqHJekrrjNEQ/OTRCRDJAZTt/YWJ8fAGfF29/L3geRD4WBFqwwf0XojxRKUaObaSwCAhDjnIyIn4mNv3CBwh2bF5aoqIEakA3N0FBNzdAXzRfQmZzcmZkcgEoDBpNTRoPHEdJH/////4AAAaBB5AGJgCIAAABBwB2AxgBbwAKsxsGAnIAK84wMf//AF7/7AZ9BiEGJgCoAAABBwB2AroAAAAKs00sB3IAK84wMf//AH3/wgW8B5AGJgCaAAABBwB2AloBbwAKszgSA3IAK84wMf//AHL/vQRgBiEGJgC6AAABBwB2AaQAAAAKszUQB3IAK84wMf//AGn+OwQBBcsGJgA2AAAABgRxHQD//wBn/jsDdARcBiYAVgAAAAYEcfUAAAEAUgTZAvMGIAASABdACwkEDgMSgAYPDAEMAC9dMxrNFzkwMUEeAhcVIyYmJwYGByM1PgI3AfUZWmQndjZyNjZvNnImYVkaBiAtcWwnFiNmNzdlJBYobHAtAAEAUgTZAvMGIAASABtADAkADgQEDAaADwABAAAvXRrNMjIRMxE5MDFBLgInNTMWFhc2NjczFQ4CBwFMGlphJXI2czI2cjZ2J2RaGQTZLm5rJxklZzg4ZyUZJ2tuLgABAFIE2wKpBWEAAwAMtAMPAgECAC9dMzAxQRUhNQKp/akFYYaGAAEAUgTZAsAF5wAQABK3EAiADA8EAQQAL10zGswyMDFBDgIjIiYnMx4CMzI2NjcCwAdNiGCTlwhoBjJYPjdYOAcF51F5RJJ8ODoVFzs1AAEAUgUIARoF4gALAAy0AA8GAQYAL10zMDFTMhYVFAYjIiY1NDa2KTs7KSs5OQXiNTg3NjY3ODUAAgBSBNoCEAaIAAsAFwAOtBIGwAwAAC8yGswyMDFBIiY1NDYzMhYVFAYnMjY1NCYjIgYVFBYBL2F8e2JfgoBhNUNFMzJFPgTacmZkcnJiZ3NgQTc3QEA3N0EAAQBS/j4BnQAeABQADrQDCsASEQAvMxrMMjAxVxQWMzI2NxUGBiMiJjU0NjY3FwYG2zIuITARHDonaWU6WCxcRkvxLzEJBGwHC2RaOm1cHx5AcAAAAQBSBNwDOQXdABkAHUANFg0NBRGAGRkKDxEBEQAvXTMzLxoQzTIvMjAxUz4DMzIeAjMyNjczBgYjIi4CIyIGB1IGIjhNLy5UTEchMDUOYg1wXyxSTEkjMTQOBNw8XkIjJS8lO0B1iyUvJTs/AAACAFIE2QMkBiEADAAZAB9ADgEODgwZgAgGBhUPEwETAC9dMzMRMxrNMjIRMzAxQRUOAwcjNT4CNyMVDgMHIzU+AjcDJBE+TU8iYB5EQBWvET5NTyJgHkNAFgYhFBxRWVEdGCdrcC4UHFFZUR0YJ2twLgABAggE2QMZBnEADAAOtAgGgAEAAC8yGswyMDFBNT4DNzMVDgIHAggOHRkUBrMLOEYiBNkbJmBoZSoWL4qQOQAAAwEgBRADkAa0AAsAFwAjABdACRgeHhILgAYMEgAvM9wazBEzETMwMUEVDgIHIzU+AjcHMhYVFAYjIiY1NDYhMhYVFAYjIiY1NDYDHhQ/SiVRECMgCe4mMzMmJjMzAeMkNjYkKDExBrQUK2tvMBcqam8v4i4yMTExMTIuLjIxMTExMi7//wAAAAAFDQYEBiYAJAAAAAcBU/4T/5P//wCWA10BhARiBgcAEQAAA3n////+AAAEmQYEBCcAKACjAAAABwFT/fb/k/////4AAAW/BgQEJwArAKMAAAAHAVP99v+T/////gAAAhkGBAQnACwApwAAAAcBU/32/5P////+/+wGEQYEBCYAMlUAAAcBU/32/5P////+AAAFrgYEBCcAPAE1AAAABwFT/fb/k/////IAAAY4BgYEJgF1RgAABwFT/er/lf///9X/7AKTBrQGJgGFAAABBwFU/rUAAAAQQAkDAgEvEAEBr1YAKzQ0NP//AAAAAAUNBbwGBgAkAAD//wDIAAAEvAW2BgYAJQAAAAEAyAAAA/0FtgAFAA62AgUCcgQIcgArKzIwMUEVIREjEQP9/XWqBbaY+uIFtgACACUAAAR9BbYABQAQABlADAsDBQJyAQQQEAMIcgArMhI5OSsROTAxQQEVITUJAi4CJw4CBwECpQHY+6gB1wHF/u4UJB4LDBwhE/7qBbb6sGZoBU764AMgPHJqLy9pbjn82AD//wDIAAAD9gW2BgYAKAAA//8ATgAABEUFtgYGAD0AAP//AMgAAAUcBbYGBgArAAAAAwB9/+wFvAXNAAMAFQAkABlADAMCAgkhEgNyGgkJcgArMisyETkvMzAxQRUhNQUUAgYGIyImJgI1NBIkMzIEEgUUEhYzMjYSNRACIyIGAgRV/Y0D2lap+qWq/adTlAEt49kBKZn7dGrbqarZaO37qtxrAzGUlFSp/uvHbGzIARap4AFSvLr+r+W6/vCUlAEQugEbAT+S/vMA//8AyAAAAXIFtgYGACwAAP//AMgAAATmBbYGBgAuAAAAAQAAAAAE0QW2AA4AE0AJBwIOAnICDQhyACsyKxE5MDFBASMBLgInDgIHASMBAsACEbP+rxUmIA0KHiYV/rK0Ag8FtvpKA7U9cmkvL2lxPPxJBbb//wDIAAAGagW2BgYAMAAA//8AyAAABT8FtgYGADEAAAADAEMAAAQkBbYAAwAHAAsAGUAMBQQEAAgJAnIBAAhyACsyKzIROS8zMDFzNSEVATUhFQE1IRVDA+H8mgLr/MMDj5aWArKVlQJulpb//wB9/+wFvAXNBgYAMgAAAAEAyAAABQkFtgAHABC3BgECcgQACHIAKzIrMjAxcxEhESMRIRHIBEGo/REFtvpKBSD64P//AMgAAARmBbYGBgAzAAAAAQBIAAAEWgW2ABIAJ0ATAwsLBwcMAgAEAnIBDQ0QEAAIcgArMhEzETMrEjk5MxEzETMwMXM1AQE1IRUhIiImJwEBMjYzIRVIAer+IgPL/eYfXVgYAdf+FEuWTwImjAJwAi2NmAEB/d79lgKWAP//ABIAAARTBbYGBgA3AAD//wAAAAAEeQW2BgYAPAAAAAMAaf/sBfUFywAYACEAKgAhQBAiAQEZFxgDciMKCiENDAlyACvNMjIRMyvNMjIRMzAxQRUWBBYVFA4CBxUjNS4DNTQ+Ajc1EQ4CFRQWFhcTET4CNTQmJgOD6AESeECQ8bGotfKOPUKT8K2mx1hhyZuooMheWMcFy7QEkPKZaMSdXwPh4QNinsJkb8OVVwO0/rwEY7B4frdlBQMu/NIFaLh8ea9hAP//AAYAAASYBbYGBgA7AAAAAQBvAAAF7gW2AB0AH0APGBUVBgkJCB0XDwJyCAhyACsrMjISOS8zMxEzMDFBERQOAiMRIxEiLgI1ETMRFBYWFxEzET4CNREF7j2P8LOms++MPKpexpymn8ZcBbb+H27Ck1X+QwG9VpTBawHj/iGErVUBA2b8mgFWrIEB4gAAAQBPAAAF8gXNACcAH0APABQDciAcHB8fCAsLCghyACsyETMyETMRMysyMDFBIgYGFRQWFhcVITUhLgI1NBIkMzIEEhUUAgYHIRUhNT4CNTQmJgMfpdlqR5x//bYBd1qTVp4BK9PXASycVZJbAXb9toGcR2zbBTd96KGO8c9biJZEwv+cygEpo6H+2Mud/wDDQ5aIWtDzjKLofAD//wAGAAACOwdBBiYALAAAAQcAav7QAW8ADLQNGQECcgArzs4wMf//AAAAAAR5B0EGJgA8AAABBwBq/+wBbwAMtB4SBwJyACvOzjAx//8Acv/sBMcGcQYmAX0AAAEGAVMjAAAKszQUB3IAK84wMf//AFn/7AOMBnEGJgGBAAABBgFTygAACrMtHwdyACvOMDH//wCv/hQEQQZxBiYBgwAAAQYBU0IAAAqzGAAHcgArzjAx//8AqP/sApMGcQYmAYUAAAEHAVP+rwAAAAqzERAGcgArzjAx//8Ao//sBG8GtAYmAZEAAAEGAVQjAAAOtR42KgUGcgArzs7OMDEAAgBy/+wExwRcAA0AMwAnQBQbBnIXGBgICBQHciQsLDAAAA4LcgArMhEzMhEzKzIRMxEzKzAxZTI2NjU1NCYjIgYVFBYXIgIREBIzMhYXMzY2NzMOAhURFBYzMjY3FQ4CIyImJyMOAgJPc4tAi7OblpODzPb23XqjNAwIIBaEDxcNMiUQJQoKJCsWTF8TDR9Zg3ZauY0Q0tje1NLWigEcARgBFQEnWFYmVCAujqBL/lFGOAcEegYLCExkMFAwAAIAr/4UBKYGHwAYADAAKUAVCAcpKSoqABQPchIeISEPC3IZAAFyACsyKzIRMzkrEjkvMxI5OTAxQTIWFhUUBgcVFhYVFAYGIyImJxEjETQ2NhciBgYVERYWMzI2NTQmJiMjNTMyNjU0JgKWiNF3npW2vXfenXWkRad93IpXkFVJnmmzp1micG5boZigBh9XrYGTrxkIFci5i8NmKCP93AY1otBkiz+UgfyOKDCilGyNRI2agoCCAAABAAn+FAQLBEgAFwAVQAoRCgYXCwZyBg9yACsrMhI5OTAxQQEOAhUjNDY2NwEzEx4CFzM+AjcTBAv+bCAtGLQbLx7+Q63yFSwjBwgHISgR4gRI+9lUvrRHPK+9UgQ6/akzfHEkIXR7LAJfAAACAHD/7ARdBhYAJAAzABxAECIOHiUxKQYALRYLcgcAAHIAKzIrMhIXOTAxQTIWFwcmJiMiBhUUFhYXHgIVFAYGIyImJjU0NjY3LgI1NDYTDgIVFBYWMzI2NjU0JgKLiMZSSE6qZ2FdNnpkeq1cfeOakuGAbsN+T3M/0LZatXhOkmZrlU6PBhZDKYMsOlg+NFFUN0OUt3mh33RrzZGCxYglLWF2TIyR/UkWX6yKXpBQVKFzjrIAAAEAWf/sA4wEXAAsAB9ADxcYLCwCAhEmHwdyChELcgArMisyETkvMxI5OTAxQRUjIgYGFRQWFjMyNjcVBgYjIiY1NDY3NSYmNTQ2NjMyFhcHJiYjIgYVFBYzAs6Sao1GTYZVcK1EPrB8596PZF5ua7x4dKhRPkOPXn+Aq5ICgIgsWEJEVCY0IJMgKbWIenkcChx7YV6BQyclhR8oVFBdUQABAHL+cQOiBhQAKQAbQAwVGRkaGiYMAxsAcgMALysSOTkzETMRMzAxRRQGByM+AjU0JiYnLgI1ND4CNw4CIyE1IRUGAgYGFRQWFhceAgOgTTKlITojJGtsg7FZYKrggAxbfkL++wLy0v+FLlKdcGiAO1pYnEErYFwkIDMqExdrt4aX/uPadAEDA4p9sv7o4r5XdH4+FxQ/WQAAAQCv/hQEQQRcABcAG0APEQZyEApyBQ9yEwoKAAdyACsyETMrKyswMUEyFhYVESMRNCYjIgYGFREjETMXMz4CAraCsFmkfIJ4kUGmhhkJI2yGBFxUsY37SgSriYhcs4P9wgRInjpPKQADAHH/7ARJBiEADQAUABsAGUAMGBISBBULAXIOBAtyACsyKzIROS8zMDFBFAIGIyICETQSNjMyEgEyEhMhEhITIgIDIQICBElk2rH672TYrfv0/hGknAf9eAWWpqCXCgKGCpoDCPz+nLwBogF5/AFju/5j+/ABMQEx/tL+zAUk/uP+5QEbAR0AAQCo/+wCkwRIABAADrYQBnIECwtyACsyKzAxQREUFjMyNjcVBgYjIiYmNREBTE9VK14aHGozWopOBEj8+WdmDwiBDRE7k4MDC///AK8AAAQkBEgGBgD5AAAAAf/0/+wESgYhAC0AHkARAhEBKAQNFh4LcgUNAXIACnIAKysyKzISFzkwMWMBJyYmIyIGBzU+AjMyFhYXAR4CMzI2NxUOAiMiJiYnAy4DJyMGBgcBDAHZOSJPViQ3FRIqLxhlfFUpAWkOHSQXDyMKDiMnFzBGMxWiDB0cFgYHEjkg/vgEOKFbYggFhwUHBUaScvwLJjAXBwN8BgsGIEg6AckkU1RMHEOaTP2f//8Ar/4UBEMESAYGAHcAAAABAAAAAAQBBEgAEQAVQAoHBgARCnIMAAZyACsyKxE5OTAxUTMTHgIXMzYSEjUzFAICByOs6hErJwkIf5RApE+/qLIESP2JLHt2Jn8BIAFRytn+i/6tpwAAAQBw/nEDnwYUADwAJUARBQQeHiEhMBYNDREREhITAHIAKzIRMxEzETMvOS8zEjk5MDFTNDY2NzUuAjU0NjY3DgIjIzUhFSMiDgIVFBYzMxUjIgYGFRQWFhceAhUUBgcjPgI1NCYmJy4CcFGFTkVkNlSMUxtPXS9DAr84WKuKU524pqt+r1tXoG5pfDdMLZ4hNyAjbW6Es1sBp2icaBcLE0hwT2J/ThcDBQOKgSdPeVJtcoBTkF1pbjYXFkFYOledQS1fXCUfMSsUF2amAP//AHL/7ARgBFwGBgBSAAAAAQAZ/+wE9QRIABgAHUAQDBEVAxAQEgZyDgpyAAcLcgArMisrMhEXMzAxZTI2NxUGBiMiJjURIREjESM1NyEVIxEUFgR/HC4PEEQvbHH+JKTflgRG2TZ0DQeECBCBfwLR/EMDvUtAi/08STwAAgCk/hQEXgRcABUAIgAdQA8WEgdyDQ9yBxoaHR0EC3IAKzIRMxEzKysyMDFBFAYGIyImJyMWFhURIxE0NjYzMhYWJSIGFREWFjMyNjU0JgRedNiWV547CQUEqHXZlY3Udv4inZc8nVaklZECJbn+gjEtJY1Z/tUEIbn0eoL989HO/qwzNNrV1tUAAQBy/nEDpARcACYAFEAKGhIeDgQVBwAHcgArMi8XOTAxQTIWFwcmJiMiBhUUFhYXHgIVFAYHIz4CNTQmJicuAzU0EjYCf1GbOTQ3fUS3ozubjml9N00sniE3IiRsbFeUbTyE7ARcIRiLFB/m2nqQUh8WQVg7WKA9LF9cJiAyKxQRRXaxfcwBB4AAAgBy/+wEswRIABEAIAAXQAsdDx4eDAZyFgQLcgArMisyETMzMDFBFAYGIyImJjU0NiQzIRUhFhYFFBYWMzI2NTQmJicjIgYEXXPhppfgeo8BC7gB7/74UGL8wUSSdK2eKE03Q9bQAfmW7ol+8q7L/XaLT+CEdrZo16laoo49yQABABT/6gOQBEgAFQAXQAsUAhMTFQZyBg0LcgArMisyETMzMDFBFSERFBYzMjY3FQYGIyImJjURITU3A5D+VGxbLV8gHWw7X5xd/tmWBEiN/ZN5ZA0JfQwUOpOFAn9NQAABAKP/7ARvBEgAFwAQtxEFBnIKAAtyACsyKzIwMUUiJiY1ETMRFBYzMjY1NCYnMx4CFRAAAnCxyVOmlKCnoyEfpxUdD/7+FIbplAJZ/a21zO/6jeR6UZilZP7E/tIAAgBy/hQFSgRcAB0AKQAhQBEWD3IIFxciFAtyAQAAHgwHcgArMjIRMysyMhEzKzAxQRcGBhUUFhYXETQ2MzIWFhUUAgYHESMRLgI1NBIFIgYVET4CNTQmJgFDgE1eYKVlqJR8sV+W+paim+6HdgLYQlpurGQ6ZgRTWWTfkZa4WQkCb7i/h/Oiw/7+hQn+JwHZCXn4xKcBExNqgf2PCWnFkYK0XgAB//D+FAROBFAAJgAiQBINFBQZCBwFBAAbD3IgAAAHBnIAKzIvMysRFzkyETMwMVMyFhYXEwEzARMeAjMyNjcVBgYjIiYmJwMBIwEDJiYjIgYHNTY2sEBSPB2WAT+x/lfDGTBAMBouEhY6KVdwSiCa/piyAc6xHUMzEyMOFTwEUDdpTf6FAmD9AP4SQFMpBQOBBgtAeVUBkv1gA0YBx1BXBgaDBwoAAQCj/hQFigYSAB8AIUASCAgYBnIRD3IeExMBEAtyAAByACsrMjIRMysrMi8wMUERPgI1NCYnMxYWFRQCBgcRIxEuAjURMxEUFhYXEQNZe7JhIiClICCT/aGinvCGpGOnZgYS+mkKZ8OTje6Lh/GIz/79fgn+JQHbBnX3xwIg/dyatlQHBZkAAAEAc//sBb0ESAAwACNAESMjDzAXBnIMCykpCAgeDwtyACsyMhEzETMzKzISOS8wMUEeAhUUBgYjIiYnIwYGIyImJjU0NjY3MwYCFRQWMzI2NjURMxEUFhYzMjY2NTQCJwVDKjYaVquAco0hCR+PcHytWRs2KqlAPXxqRVkrny5ZP0loOD1BBEhes7profmMYFtbYIn3pmu6sl+Q/vujy89Ge08BOv7GV3lAXbeGowEFkP///+n/7AKTBdIGJgGFAAABBwBq/rMAAAAMtCYaEAZyACvOzjAx//8Ao//sBG8F0gYmAZEAAAEGAGohAAAMtC0hBQZyACvOzjAx//8Acv/sBGAGcQYmAFIAAAEGAVMUAAAKsyEOB3IAK84wMf//AKP/7ARvBnEGJgGRAAABBgFTHQAACrMYBQZyACvOMDH//wBz/+wFvQZxBiYBlQAAAQcBUwDAAAAACrMxFwZyACvOMDH//wDIAAAD9gdBBiYAKAAAAQcAagAhAW8ADLQhFQICcgArzs4wMQABABL/7AVBBbYAIAAhQBEQGRkAGBQUFQJyEghyBwAJcgArMisrMhEzETkvMzAxRSImJzUWFjMyNjY1NTQmIyERIxEhNSEVIREhMhYVFRQGA9IvUhgfRS4yXj56kf6AqP6sA8X+NwGOy9rOFA0KlAoKKGdeh3p3/RgFIJaW/l69tZHJxv//AMgAAAP9B5AGJgFgAAABBwB2AagBbwAKsw0FAnIAK84wMQABAH3/7ATiBc0AIwAZQAwFCAgUAB0Dcg0UCXIAKzIrMhE5LzMwMUEiDgIHIRUhHgMzMjY3FQYGIyIkAjU0EjYkMzIWFwcmJgNBcLeHUgwC1P0nBUaDwH9mtFVQwXTr/tKRXbUBCqyAyVRFSqsFNUB/uXqUhc+PSyEZlB4dvAFT4qgBFcdsMCmSJS4A//8Aaf/sBAEFywYGADYAAP//AMgAAAFyBbYGBgAsAAD//wAGAAACOwdBBiYALAAAAQcAav7QAW8ADLQNGQECcgArzs4wMf///1z+fwFqBbYGBgAtAAAAAgAB/+kHKQW2ACYAMAAfQBAnGwhyMBISAB0QAnIHAAlyACsyKzIROS8zKzIwMVciJic1FhYzMjY2NzY2EhI3IREzMhYWFRQEISERIQ4EBw4CJTMyNjU0JiYjI4MjRBsXOSA+SSsRDiImKRUCp4vQ9Wr/AP7v/q7+kQwZHBwbDhtMfwOEk8G3WbSIdhcOCo8KDmKdVkfRAQUBLKD9kmq6ecTnBSBZwsO7pkOLw2epi45jdDIAAgDIAAAHWAW2ABMAHQAjQBEHAwMdEhIABgECchQQEAAIcgArMhEzKzIROS8zMxEzMDFzETMRIREzETMyFhYVFAQhIREhESUzMjY1NCYmIyPIqgKCrInQ9Gv/AP7x/qv9fgMuk7+3WbOIdQW2/ZICbv2Sarp5xOcCsv1OkouOY3QyAAEAEgAABUEFtgATAB1ADgISEg4DAxATAnIJEAhyACsyKxE5LzMyETMwMUEVIREhMhYVESMRNCYjIREjESE1BAv+AwGXyNSpdIz+dqr+rgW2mP5eurf99QH3e3T9GgUemAD//wDIAAAE4AeQBiYBswAAAQcAdgHgAW8ACrMSBQJyACvOMDH//wAW/+wE8Qd6BiYBvAAAAQcCMwA4AW8ACrMiEQJyACvOMDEAAQDI/oIFCQW2AAsAFUAKCwYCcggCAQUIcgArMswzKzIwMWEhESMRIREzESERMwUJ/jKv/jyqAu+o/oIBfgW2+uIFHv//AAAAAAUNBbwGBgAkAAAAAgDIAAAEdwW2AA0AFwAZQAwFFxcABAECcg4ACHIAKzIrMhE5LzMwMXMRIRUhETMyFhYVFAYhJzMyNjU0JiYjI8gDW/1P49PuYfH+6f3rxqVQrIzOBbaW/ihounvK4ZKLjmN0MgD//wDIAAAEvAW2BgYAJQAA//8AyAAAA/0FtgYGAWAAAAACAAz+ggVKBbYADwAXABpADBEPAnIKARYWBAcGCAA/zTIzETMzKzIwMUERMxEjESERIxEzNhoCNwUhBgoCByEElrSj/AijcEuDZ0EJAfL+pAk+YXdCAr0Ftvri/eoBfv6CAhaAAT8BXQFgopl8/s/+wP7acgD//wDIAAAD9gW2BgYAKAAAAAEABAAABrUFtgARACJAEwAJAw8MBgYBDg4LEQhyCAUBAnIAKzIyKzIyERIXOTAxQQEzAREzEQEzAQEjAREjEQEjAlb9xL0CNKQCNL39xAJRxP2+pP29xALwAsb9PALE/TwCxP07/Q8C5f0bAuX9GwABAE//7AQ7BcsALgAfQA8EAxsbGhoLIysDchMLCXIAKzIrMhE5LzMSOTkwMUEUBgcVFhYVFAYEIyImJzUeAjMyNjU0JiMjNTMyNjY1NCYjIgYHJz4CMzIWFgQduJq0vIH+/sB32Fo+kJVExs3t1tLLkL5fp4aLtlZSOpS0aJvUbgRfla0aBxq0koHDbCUrnR4sF5mLj4OPQ3tUc3xHOHQqRSldpAAAAQDKAAAFTQW2ABUAGkAOBwgSEwQADBQIcgoAAnIAKzIrMhEXOTAxUzMRFA4CBzMBMxEjETQ+AjcjASPKnwIEBQIIAy67nwQFBgEJ/NG8Bbb8szBxbFgYBMr6SgNDNXdwWRj7MAD//wDKAAAFTQd6BiYBsQAAAQcCMwDWAW8ACrMaAAJyACvOMDEAAQDIAAAE4AW2AAoAGUANAgcKAwQJBQJyAQQIcgArMisyEhc5MDFhIwERIxEzEQEzAQTgzv1gqqoCj8P9eQLm/RoFtv08AsT9OgABAAH/6QTYBbYAHQAVQAsDHAJyEwwJcgAIcgArKzIrMjAxYSMRIQ4DBw4CIyImJzUWFjMyNjY3NjYSEjchBNiq/iYOICIiERpNf2gjRRoXOSA/SSsQDSImKRQDEgUgcPTy2FSLw2cOCo8KDmWcUkTQAQkBLqD//wDIAAAGagW2BgYAMAAA//8AyAAABRwFtgYGACsAAP//AH3/7AW8Bc0GBgAyAAD//wDIAAAFCQW2BgYBbQAA//8AyAAABGYFtgYGADMAAP//AH3/7ATLBcsGBgAmAAD//wASAAAEUwW2BgYANwAAAAEAFv/sBPEFtgAdABdACxcQBR0RAnIMBQlyACsyKzISOTkwMUEBDgIjIiYnNRYWMzI2NjcBMwEeAhczPgI3AQTx/iQ+gLCHOmMnKF00TW5UJv3MugGgCBISBwcGDxAGAWcFtvvcjLxeEQ2pExUvZ1UEQPzPDycpFA8oKA4DNwD//wBp/+wF9QXLBgYBcgAA//8ABgAABJgFtgYGADsAAAABAMj+ggW4BbYACwAXQAsKBQJyCwcHAQQIcgArzDMRMysyMDFlESMRIREzESERMxEFuKP7s6oC76iW/ewBfgW2+uIFHvrgAAABAKcAAATDBbYAEwAdQA4RDg4CBQUAEwkCcgAIcgArKzIROS8zMxEzMDFhIxEGBiMiJjURMxEUFjMyNjcRMwTDqXXSgM/dqoGSe8N4qQJeKjS/swJE/dR5ey0qAskAAQDIAAAHdwW2AAsAF0ALCwcCAnIIBAQBCHIAKzIRMysyMjAxYSERMxEhETMRIREzB3f5UaoCV6oCWKwFtvriBR764gUeAAEAyP6CCAwFtgAPABtADQ4KBQJyDwsHBwEECHIAK8wzETMzKzIyMDFlESMRIREzESERMxEhETMRCAyj+V+qAkqsAkuqlv3sAX4FtvriBR764gUe+uAAAgAPAAAFFAW2AA0AFwAZQAwXBQUAAgMCcg4ACHIAKzIrMhE5LzMwMWERITUhETMyFhYVFAYhJTMyNjU0JiYjIwFk/qsB/u/H6mf4/vn++PW2rFSpgNoFIJb9kmu7d8TnkouOY3QyAAADAMgAAAX6BbYACwAVABkAG0ANFQMDABcBAnIWDAAIcgArMjIrMhE5LzMwMXMRMxEzMhYWFRQGISUzMjY1NCYmIyMBETMRyKrqxupm9/74/v/wtatTp3/XA96qBbb9kmu7d8TnkYyOY3Mx/U4FtvpKAAACAMgAAASoBbYACwAVABdACxUDAwABAnIMAAhyACsyKxE5LzMwMXMRMxEhMhYWFRQEISUhMjY1NCYmIyHIqgEWxu9r/v7++f7TARu2tlqtf/7/Bbb9kmu7d8TnkouOY3QyAAEAP//sBIwFywAjABlADB4dHQcXEAlyAAcDcgArMisyEjkvMzAxQSIGByc2NjMyBBYSFRQCBCMiJic1FhYzMj4CNyE1IS4DAdplq0VGVdZyrwEDqlSc/sfrf7FUVbFkhsuKSQP9LQLRCU6EswU1LiCPKSxrxP72n+3+pL4dHpQXI0qQ0IaWdLeAQwAAAgDI/+wH4wXNABcAJwAhQBIPCgoFJBQDcg0CcgwIchwFCXIAKzIrKysyETkvMzAxQRQCBgYjIiQCJyERIxEzESE2EiQzMgQSBRQSFjMyNhI1NAImIyIGAgfjUaLxn9D+5ZUI/pqqqgFpDpcBFMnTAR+U+6djzqCk0GJhzqOiz2QC3an+68hrrwE/1v1QBbb9kMQBI6C7/q7gu/7vlZQBELq6AQ6Skf7zAAACAC4AAARHBbYADgAYAB1ADgMXFwAAAhAKAnINAghyACsyKzIROS8zEjkwMUEBIwEuAjU0JCEhESMRESMiBgYVFBYzMwJx/oTHAZlQi1UBEQEOAZGq4XmnVri94gJj/Z0CghldpIDI0vpKAmMCwjh4YYuV//8AXv/sA8sEWgYGAEQAAAACAHb/7ARSBh4AIgAyACxAFS4qKhYREhIWFgcjHgtyDQgIBAcBcgArMjIRMysyEjl9LzMRMxEzETMwMVM0EjY3NiQ3Fw4DBw4CBzM+AjMyFhYVFAYGIyIuAgEyNjY1NCYjIgYGBxQeAnZavZWAAQh9HT+KinovVXtHBwweaJBajr5ge96WdLd/QwH6X4lLhZJblGYXHkqDApLqAUvJJSMzE5IJFxkbDhdyyJgsVjl73pWz9Htarvz+hlCti67FTWoqZsCaWgADAK8AAAQ7BEgAEQAaACMAH0APBAMgIBYWDB8NBnIXDApyACsyKzIROS8zEjk5MDFBFAYHFRYWFRQGBiMhESEyFhYDNCYjIREhMjYDNCYjIREhMjYEFnhfZ5VawJr+KAHUdrVoiJOM/ucBHYqRIXKC/t0BBoeKAzVncxQIDnd6XpBSBEg1eP2lYVb+kFUCRk5N/sVOAAABAK8AAANIBEgABQAOtgIFBnIECnIAKysyMDFBFSERIxEDSP4OpwRIjfxFBEgAAgAn/oUEbwRIAA4AFQAbQAwQDgYKARUVBwSABQoAPxrNMjMRMzM/MzAxQREzESMRIREjETM2EhI3BSEGAgIHIQPSnaH8+J9WXnxAAgGY/vwJQ25JAgcESPxF/fgBe/6FAgiCATYBVa6Ekv7S/u9m//8Acv/sBBMEXAYGAEgAAAABAAQAAAXaBEgAEQAgQBIBChANBwQGBhEPCwZyBgMJCnIAKzIyKzIyEhc5MDFBAQEjAREjEQEjAQEzAREzEQEFs/44Ae++/iCb/iG+Ae/+N7cBwJsBwgRI/ev9zQIs/dQCLP3UAjMCFf3sAhT97AIUAAABAEP/7AOABFwALwAfQA8HCCIiISEAGBALcikAB3IAKzIrMhI5LzMSOTkwMUEyFhYVFAYHFR4CFRQGBiMiJiYnNRYWMzI2NjU0JiYjIzUzMjY1NCYjIgYHJzY2Acl7tGJsX0NtQWTMnE2KcCpGvG1Uhk9Gi2qTeY2ognlailA7VrwEXEOAXGN2GggSQ21RXJNUESAWlyI0J1dHQVUpiFBfUlElIoUmJgABAK8AAARkBEgAEgAXQAsPBhAIEgZyChAKcgArMisyEjk5MDFBERQOAgcBMxEjETQ2NjcBIxEBTQIEAwICVsybAgQB/azNBEj9TxQ/R0EVA6H7uAKgIGRhG/xgBEj//wCvAAAEZAYLBiYB0QAAAQYCM1AAAAqzFxIGcgArzjAxAAEArwAABAsESAAKABlADQUKAgMHAQgGcgQHCnIAKzIrMhIXOTAxQTMBASMBESMRMxEDLrf+JwH/w/4Op6cESP3v/ckCLP3UBEj97AABAA3/8wPlBEgAFgAVQAsDFQZyDwgLcgAKcgArKzIrMjAxYSMRIQICBgYjIiYnNRYWMzI+AhI3IQPlqf6zFD1bgVkbMBENHRAtSz0wJQ4ChgO9/v3+j+ltBgd+BARLmOkBPckAAQCuAAAFNARIABQAG0AOEwYKAxAUEgZyCQIQCnIAKzIyKzISFzkwMUERIxE0NjcjASMBIxYWFREjETMBAQU0lgUEBv6Ujf6dBgMDl98BYgFnBEj7uALKLFsu/IEDfy5bMv08BEj8gAOAAAEArwAABF8ESAALABlADAEICAoECwZyBgoKcgArMisyETkvMzAxQREhETMRIxEhESMRAVYCY6am/Z2nBEj+NAHM+7gB7/4RBEj//wBy/+wEYARcBgYAUgAAAAEArwAABEUESAAHABC3BAcGcgIGCnIAKzIrMjAxQREjESERIxEERaf9uKcESPu4A7n8RwRI//8Ar/4WBHMEXAYGAFMAAP//AHL/7AOSBFwGBgBGAAAAAQApAAADmgRIAAcAE0AJAQUFBgZyAwpyACsrMhEzMDFBIREjESE1IQOa/pek/pwDcQO7/EUDu40A//8AAv4TBAIESAYGAFwAAAADAHD+FAVHBhQAFQAeACYAJUAUHxYWARQHciAJCR4MC3IKD3IAAHIAKysrMjIRMysyMhEzMDFBER4CFRQGBgcRIxEuAjU0NjY3EREOAhUUFhYXExE+AjU0JgMso/KGgfGpoqPxhoHyrH+kT1Ckfp1+o0+2BhT+RA6N8qek9I4O/iQB3AyN9Ken840NAbz9ugtqtn9/t2oMA1T8rA1stn2+1///ACcAAAQJBEgGBgBbAAAAAQCv/oUE2gRIAAsAGUAMCQQGcgoGBgCAAwpyACsazDMRMysyMDFBIxEhETMRIREzETME2qL8d6cCRaaZ/oUBewRI/EUDu/xDAAABAJoAAAQsBEgAEwAdQA4HBAQMDw8KCRMGcgoKcgArKzIROS8zMxEzMDFBERQWMzI2NxEzESMRBgYjIiY1EQFAcWxoqlemplyyfKm5BEj+dmdiQDcB3Pu4Aes7RLCWAZYAAAEArwAABm0ESAALABdACwsIAwZyCQUFAgpyACsyETMrMjIwMUERIREzESERMxEhEQZt+kKmAeWnAeYESPu4BEj8RQO7/EUDuwAAAQCv/ocHCQRIAA8AHUAODwwHBnINAQkJA4AGCnIAKxrMMxEzMysyMjAxQREzESMRIREzESERMxEhEQZsnaf6TaYB5acB5gRI/EP9/AF5BEj8RQO7/EUDuwAAAgAmAAAFFARIAA4AFwAZQAwQAQELDQ4GchELCnIAKzIrMhE5LzMwMUERITIWFhUUBgYjIREhNQEhESEyNjU0JgImAT2TwF5awZv+Iv6mAzb+ygE4gJKJBEj+PEaKZmaWUgO7jf2w/o9ZZmROAAADAK8AAAV2BEgADAAVABkAG0ANFQMDABcBBnIWDQAKcgArMjIrMhE5LzMwMXMRMxEhMhYWFRQGBiMlITI2NTQmIyEBETMRr6cBLIy1WFe5lP7fARF8lIqB/uoDeqYESP48RopmZpZSh1hnZU/+BgRI+7gAAAIArwAABEkESAAMABUAF0ALEQAACgsGchIKCnIAKzIrETkvMzAxQSEyFhYVFAYGIyERMwE0JiMhESEyNgFWAVCMul1bvZX+E6cCTI+A/sMBPniWAoRGimZmllIESPz+ZU/+jVkAAAEAQf/sA4QEXAAfABlADA0MDAARGAdyBwALcgArMisyETkvMzAxRSImJzUWFjMyNjY3ITUhJiYjIgYHJzY2MzIWFhUUBgYBYl2JOz6OWHChWwf91AIqDaikO404LjqhUpvqg4r1FB4ckRkkUqd9ia2nIRWIGiN0+cm//n0AAAIAr//sBjAEXAAWACYAIUASDgkJBCMTB3IMBnILCnIbBAtyACsyKysrMhE5LzMwMUEUAgYjIiYmJyERIxEzESE+AjMyFhYFFBYWMzI2NjU0JiYjIgYGBjBz1pWLz3cJ/t2mpgElDnjMipDVdfzyP4dsa4c/QIZra4dAAiaz/wCHeOal/hEESP40mNZyh/2yisFlZMGLib5jY74AAAIAIgAAA78ESAAOABcAHUAOAhISDg4BFQkGcgwBCnIAKzIrMhE5LzMSOTAxcyMBLgI1NDYzIREjESEBFBYzIREhIgbkwgE8RXZJ060B5ab+6v74jIIBEP7TgHEBzg9JgF+epfu4AbgBTGJfAXpnAP//AHL/7AQTBdIGJgBIAAABBgBq9gAADLQ1KQAHcgArzs4wMQABABT+FARDBhQALwApQBUYHBwVHR0nIw4OJxkAchQKcgcAD3IAKzIrKy8zETMROS8zMxEzMDFBIiYnNRYWMzI2NRE0JiMiBgYVESMRIzUzNTMVIRUhFRQGBzM+AjMyFhYVERQGBgMuLUIZGzcgOkt8gHmRQKibm6YBlf5rBAMJImqHS4SxWT57/hQPCokKC0xiA06Jhl2zgv3mBN18u7t8vydPIzpPKlSxi/ytZZBM//8ArwAAA0gGIQYmAcwAAAEHAHYBOAAAAAqzDQUGcgArzjAxAAEAcv/sA6wEXAAgABlADBMWFgAPCAdyGgALcgArMisyETkvMzAxRSImJjU0NjYzMhYXByYmIyIGBgchFSEeAjMyNjcVBgYCeZrqg4nvmFOdOjE5iDttllMLAir91AZOlnBakD06ixR4+cHI/nggGokXHUyXcYl7p1QkGZEcHgD//wBn/+wDdARcBgYAVgAA//8AoAAAAWgF4gYGAEwAAP///+cAAAIcBdIGJgOvAAABBwBq/rEAAAAMtBkNAgZyACvOzjAx////kP4UAWgF4gYGAE0AAAACAA3/8wZJBEgAHwAoAB9AECEBARINHwZyGRILciILCnIAKzIrMisyETkvMzAxQREhMhYWFRQGBiMhESECAgYGIyImJzUWFjMyPgISNwEjETMyNjU0JgOiAQqNt1lZv5r+Y/7zEz1bgFceLxELHRAtSz4wJg4DLuvufZaOBEj+PEaKZmaWUgO7/v3+kOhtBgd8AwVLmeoBPcn9sP6PWWZkTgACAK8AAAasBEgAFAAdACNAEQESEhYNDQ8UEAZyFwsLDwpyACsyETMrMhE5LzMzETMwMUERITIWFhUUBgYjIREhESMRMxEhEQEjETMyNjU0JgQFAQaQuFlXvpr+XP4AqqoCBAGX8/N+lYsESP46RYlmZpZSAfL+DgRI/jYByv2w/o9ZZmRO//8AFAAABEEGFAYGAOkAAP//AK8AAAQLBiEGJgHTAAABBwB2AWwAAAAKsxIIBnIAK84wMf//AAL+EwQCBgsGJgBcAAABBgIzuQAACrMiAAZyACvOMDEAAQCv/ocESARIAAsAFUAKBwIGcgoJBAEKcgArMjLMKzIwMWEhETMRIREzESERIwIv/oCnAkym/omiBEj8RQO7+7j+hwABAMgAAAQMBuMABwAQtwIABQJyBAhyACsrzDMwMUERIREjESERBAz9ZqoCpQbj/jv64gW2AS0AAAEArwAAA0sFiQAHABC3AgAFBnIECnIAKyvMMzAxQREhESMRIREDS/4LpwH6BYn+Pfw6BEgBQQD//wAeAAAHRQeQBiYAOgAAAQcAQwJVAW8ACrMwEAJyACvOMDH//wAYAAIGGwYhBiYAWgAAAQcAQwHAAAAACrMxHAZyACvOMDH//wAeAAAHRQeQBiYAOgAAAQcAdgLtAW8ACrMwEAJyACvOMDH//wAYAAIGGwYhBiYAWgAAAQcAdgJXAAAACrMxDwZyACvOMDH//wAeAAAHRQdBBiYAOgAAAQcAagFgAW8ADLQ/MxACcgArzs4wMf//ABgAAgYbBdIGJgBaAAABBwBqAMsAAAAMtEA0DwZyACvOzjAx//8AAAAABHkHkAYmADwAAAEHAEMA4AFvAAqzDwcCcgArzjAx//8AAv4TBAIGIQYmAFwAAAEHAEMApQAAAAqzJAAGcgArzjAxAAEAUgHcA64CcAADAAixAQAALzIwMVM1IRVSA1wB3JSUAAABAFIB3AeuAnAAAwAIsQEAAC8yMDFTNSEVUgdcAdyUlAD//wBSAdwHrgJwBgYCAgAAAAL//P49A0r/vAADAAcADLMBAgYFAC8zzjIwMUEhNSE1ITUhA0r8sgNO/LIDTv49e4p6AAABABsDwQFCBbYACgAOtQEAgAUCcgArGs05MDFTJz4CNzMOAgcnDBI4QiF6FCkiCwPBFkmnp0hNsq9HAAABABoDwQFBBbYACwAOtQEFgAsCcgArGs05MDFBFw4CByM+AzcBMg8SOEIheg8fHBcIBbYWSaemSTmChn42//8AQf74AWgA7QQHAgYAJ/s3AAEAGwPBAUQFtgAKAA61CQSACgJyACsazTMwMVMeAhcjLgInN9oKIikVeyFDOBIOBbZHsLJMSaanSRYAAAIAGwPBArEFtgAKABUAF0AKERAQBgSAChUCcgArMhrMMjIRMzAxQQ4CByMnPgI3Iw4CByMnPgI3ArEVKSIKsQ8SOUMi9hUpIgqwDBI3QiIFtk2zrkcWSaanSU2zrkcWSaanSQACABoDwQKwBbYACgAWABdACgEMDBEFgAoWAnIAKzIazDIzETMwMUEXDgIHIz4CNyMXDgIHIz4DNwKhDxI4QiF9FSoiCsAOETlCIXgPHxsXBwW2FkqnpUlMsrBHFkqnpUk5goZ+Nv//AEH++ALXAO0EBwIKACf7NwABAIIAAAOPBhQACwAXQAkEAQEHCgoDCAMALy8SOS8zMxEzMDFBJRMjEwU1BQMzAyUDj/6gL7wt/rMBTS28LwFgA+od+/kEBx2lHAGh/l8cAAEAeQAAA5YGFAAVACdAEQkAAAYDCxQUDhEDEQMRBQ8FAC8vEjk5Ly8RMzMRMxEzMxEzMDFBJRUlEyMTBTUFAxMFNQUDMwMlFSUTAjcBX/6hLb4s/qcBWScn/qcBWSy+LQFf/qEmAeoboBr+gQF/GqAbASgBGRyhHAGA/oAcoRz+5wABAKsB+wJXA9wADwAIsQQMAC8zMDFTNDY2MzIWFhUUBgYjIiYmqzhhPT1hODhhPT1hOALsV2kwMGpWVGsyMmr//wCW/+QFowDpBCYAEQAAACcAEQIRAAAABwARBB8AAAAHAGb/7Aj4BcsACwAXABsAJwAzAD8ASwAsQBdANEY6DXIoHC4iDXIaDBIGABsbDAAFcgArMjIvEMwyPysyzDIrMswyMDFBMhYVFAYjIiY1NDYXIgYVFBYzMjY1NCYlASMBEzIWFRQGIyImNTQ2FyIGFRQWMzI2NTQmJTIWFRQGIyImNTQ2FyIGFRQWMzI2NTQmAY+Wm5abkJmSl1FMTFFUUlEDSfzVkgMra5WclpuRmJGYUUxMUVRSUQJtlZuVm5GYkZhSTExSU1JRBcvv2trz89ra73epqamsrKmoqmL6SgW2/cvv2tnz89na73ioqamrqauoqXjv2tnz89na73ioqamrqauoqQABAFADqQIEBbYAAwAKswIBAnIAK80wMUEzASMBWqr+u28Ftv3zAAIAUAOpA2YFtgADAAcADrUHAAIGAnIAKzLOMjAxQQEzASEBMwEBsQELqv66/jABCqr+uwOpAg398wIN/fMAAQBPAHoCGgPFAAYAELcEBgMAAgUBBQAvzBc5MDFTARcBAQcBTwFUd/7hAR93/qwCLAGZRP6f/p9FAZcAAQBNAHoCGAPFAAYAELcEAgUBBgUAAwAvzBc5MDFTARUBJwEBwgFW/qp1AR7+4gPF/mgb/mhFAWIBYAD//wCW/+QDUwW2BCYABAAAAAcABAHPAAAAAf6EAAACgQW2AAMAC7QCEnIAAgA/KzAxQQEjAQKB/JGOA24FtvpKBbYAAQByAkwCxATqABQAGUAKEhEJCQ4EABAQAAAvMi8QzDIzETMzMDFBMhYVESMRNCYjIgYVESMRMxczNjYBw3+Ca1FUdmBsVxAGInoE6nN//lQBplJSfHb+qAKSXzQ3AAEAXgAABCMFtgARACBADwEQEAQNCQwMAAgFBHIADAA/KzISOS8zzjIyETMwMWERIzUzESEVIREhFSEVIRUhEQEOsLADFf2QAkn9twFA/sABEHwEKpb98pXxfP7wAAABAEYAAARGBckAKQAsQBULJSUOIhIeHg8hIRkaFhYZDAcABXIAKzI/MxEzETkvMzMRM84yMhEzMDFBMhYXByYmIyIGFRUhFSEVIRUhFAYGByEVITU+AjUjNTM1IzUzNTQ2NgKycLBEO0CUU3ODAZz+ZAGc/mIkPysDGPwAQ10xyMjIyFW2BcktIYMdJ36Osnyxflx8TRaYjQ1NiGR+sXyLjchrAAMAnv/sBd8FtgAMABUALgAtQBYeJQtyLC0tFyoaGi4XDwkJCw4MAnILAC8rMhI5LzMvzTMRMxEzETMrMjAxQSAWFRQOAiMjESMRFyMRMzI2NTQmARUzFSMRFBYzMjY3FQYGIyImJjURIzU3NwGjAQ3zN37RmkCl+lU2xL6tApPj4zhCH08WGFY9S2s6n6E6Bbbdzl+ngEj9wwW2kv2sj6STjv7/1YD+SVFTDAd8CxM9el0Bzk1DxQABADT/7AR1BcoANgArQBUzMDAPJxgYKhUMDw8AHCMNcgcABXIAKzIrMhE5LzPOMjIRMxEzETMwMUEyFhcHJiYjIg4CByEVIQYGFRQWFyEVIR4CMzI2NxUGBiMiJiYnIzUzJiY1NDY1IzUzPgIDDmavUkY5mFBOgmRGEwH4/fsBAQEBAc7+QRdpqHNPnkA+mWGj6Y8dp5gBAQKYpRmQ6wXKLS+IHzIyZplmfBQpFhUuFnx5qlomHJUbJX7spnwZJBsXLw58qfmIAAQAh//2BgQFwQADAA8AGwA2ACVAEjAcIyoDAyMEchkNBxMBAQcMcgArMi8yEMwyKzIvMhDMMjAxQQEjAQEUBiMiJjU0NjMyFgUUFjMyNjU0JiMiBgEiJjU0NjYzMhYXByYmIyIGFRQWMzI2NxUGBgUY/NWTAysBf62Pha+rj4aw/hNUYV1WU2BhVP3KlcVdomU1ZiYhJVcncG5sbTViKCdoBbb6SgW2+5ils7KmpbOxp2uFhGxtgoIBVqSve5pIFQ9lDhF7dnZ3ExBlEhQAAgBw/+wDmAXLACMALQAiQBMQDSARFCsGCCcZBXIDAwAACA1yACsyETMvKzISFzkwMWUyNjczDgIjIiYmNTUGBgc1NjY3ETQ2NjMyFhUUBgYHERQWEzQmIyIGFRE2NgJ2TGkJZAVHhGNUjFQvYjA0YC07f2V2imSvcVKyQEBNN4CEbmF2bZtRRZqB8BEdDHEOHxAB7VaIUJ2PhNujMf7obHoELGBhaFn+TkPZAAQAxQAAB8EFtgATABcAJQAxACZAEiwfJhgUFQ0DAAkJAQJyDAwACAA/Mi8rMi8ROTkvM94yzDIwMXMRMwEzLgI1ETMRIwEjHgIVESE1IRUBIiYmNTQ2MzIWFhUUBicyNjU0JiMiBhUUFsW8Aq4HAgcEl7j9SwgDBwUEMAIG/vxYiE2kkFiITqaLW1RTXFtWVQW2+z00iokyA0r6SgTHNoyLN/y9g4MBElCbcKeyUJlwqLNweHN0cnJ0c3gAAgAfAuUFhQW2ABQAHAArQBUbFxcDDwwDGAcODgAAFRgFAgIYAnIAKzIvMxDMMhEzETMRFzkzETMwMUERMxMTMxEjETQ2NyMDIwMjFhYVESERIzUhFSMRApKzxsyuegQBB9NmyQgCA/3s0QId0wLlAtH9zAI0/S8BnhdiHf3MAjQjVRT+WAJpaGj9l///AE8AAAXyBc0GBgF1AAAAAgBm/90EiwRIABkAIgAZQAwiDg4AHgkGchIAC3IAKzIrMhI5LzMwMUUiJgI1ND4CMzIWFhUhERYWMzI2NxcOAhMRJiYjIgYHEQJ5re15XZy8XpfvjPzFLKFclbFFSDB4rKwmnWplky8joAECk5TWikKK/a/+nC9Me28pTH9MAosBFShPRy7+6QAABQA+//EF9AW2AAMAEQAfADgARAAuQBk5MycZBD8tIBIDAyANcg0OCQMEDwEBDwRyACsyLxDMFzkrMi8yEMwyFzkwMXMBMwEDETQ2NjcGBgcHJyUzEQEyNjU0JicnDgIVFBYXIiY1NDY2NyYmNTQ2MzIWFRQGBxYWFRQGAzY2NTQmIyIGFRQW6QNvj/ySLQIEARYyHW5CAQyJAvBYVltTGzBBIFZZk54qSS5CRaVycaBVQVNgqIRBTU5ERE1UBbb6SgJKAjYkPz0dEyoUTF64/JT+Ekw9PFIaChUzQSk8TWuDcTlWQBcoWk5sdW1uTGQgInBUcYkCExhHOjg+Pjg4SAAABQAl//EGGAXJAAMALQA7AFQAYAA5QB40NUNPVQVbSTwuAwM8DXIoJxQUERELBCEaAQEhBXIAKzIvMhDMMjkvMxI5OSsyLzIQzDIXOTAxYQEzAQMiJic1FhYzMjY1NCYjIzUzMjY1NCYjIgYHJzY2MzIWFRQGBxUWFhUUBgEyNjU0JicnDgIVFBYXIiY1NDY2NyYmNTQ2MzIWFRQGBxYWFRQGAzY2NTQmIyIGFRQWATEDb478kpBLgz1Eij5sZ3dsd3doYVVAQG83RD6MXo+SWT5RX6sDBFlVW1MbL0EhVlmSnypKLkJFpXFxoVZBU2GohUFNTkRETVUFtvpKAjobHnkhI1ZMTEVqUkNBQCsjWC42f2JTahMHEGhTd5X+Ikw9PFIaChUzQSk8TWuDcTlWQBcoWk5sdW1uTGQgInBUcYkCExhHOjg+Pjg4SAAFAEj/8QYWBbYAAwAiADAASQBVAD1AICkqOERKBVA+MSMDAzENchQVFRERGh0dCwQWGQEBFgRyACsyLzIQzDI5LzMzETMRMysyLzIQzDIXOTAxYQEzAQMiJic1FhYzMjY1NCYjIgYHJxMhFSEHNjYzMhYVFAYBMjY1NCYnJw4CFRQWFyImNTQ2NjcmJjU0NjMyFhUUBgcWFhUUBgM2NjU0JiMiBhUUFgEqA2+O/JJ0Q44sOIk4X29uZTRNHj0hAev+hBQaPSSJta0C/FlVW1MaMEEhVlqTnypKLkJFpXFxoVZBU2GohUFOT0RETVUFtvpKAjcdGoAhJlVbUVkRCCcBp2nqBQmPgI6d/iVMPTxSGgoVM0EpPE1rg3E5VkAXKFpObHVtbkxkICJwVHGJAhMYRzo4Pj44OEgAAAUAXv/xBgQFtgADAAoAGAAwADwALUAYERIfKzEFNyUZCwMDGQ1yCQYEBwEBBwRyACsyLxDMMzMrMi8yEMwyFzkwMXMBMwEDASE1IRUBATI2NTQmJycOAhUUFhciJjU0NjcmJjU0NjMyFhUUBgcWFhUUBgM2NjU0JiMiBhUUFtEDb478kpgBYP42Alf+nwN+WVVaUxwwQSBWWpKfXEVCRaVxcaJWQVNgqIVBTU1ERUxTBbb6SgJKAvlzXvzy/hJMPTxSGgoVM0EpPE1rg3FWbSMoWk5sdW1uTGQgInBUcYkCExhHOjg+Pjg4SAAAAgBl/+wEMgXIACYANgAfQA80GCcnFRUALwsTch8AA3IAKzIrMhI5LzMRMzMwMUEyHgIVFAIOAiMiJiY1ND4DMzIWFzY2NS4CIyIGBzU+AhMiDgIVFBYzMj4CNyYmAot5o2EqLF2RyYKHnkMkTHqscV2RLQICAT57XT2NNSJbZyReiVkrXWdTh2ZEDxZ6BchVl8Zye/73+Md1brNpTq+oiFFaShYxEoWzWiwjnxEbEf2pY52wTW2PYqLFY1Z3//8AJQAABH0FtgYGAWEAAAABAMf+EQUhBbYABwAOtQYBAnIEAAAvMisyMDFTESERIxEhEccEWqr8+f4RB6X4WwcN+PMAAQBK/hEE2gW2AAsAHUANAwcHCAIABAJyAQkJAAAvMhEzKxI5OTMRMzAxUzUBATUhFSEBASEVSgJ5/ZgEPvyvAkT9pQOp/hFpA54DNGqW/P38ipYAAQBnAo4EKgMWAAMACLEBAAAvMjAxUzUhFWcDwwKOiIgAAAEAJf/yBL4GmQAIABdACgIDBQIDAwYAE3IAKy85LxE5ETMwMUUBIzUhEwEzAQHx/um1AR3uAgWJ/bEOAw6F/VAFxPlZAAADAHUBkwUtBA0AGgAmADIAJ0ATHhISBy0bFQQEKhgYBCQKCjAEEgA/MzMRMxEzLzMSFzkzETMwMUEUBgYjIiYnBgYjIiYmNTQ2NjMyFhc2NjMyFgUmJiMiBhUUFjMyNiU0JiMiBgcWFjMyNgUtSoVZW5pBPplYWIdMS4dZVppAO5xfhKP9YjRuR1NgXFhEcAJUYlJDbjczcEZSYQLQVpFWanRqcFCOXliOVGlzaHGuiWVbb1JPcF1gU21cZGJebgABAAn+FAL3BhQAHQAOtRYPAHIHAAAvMisyMDFTIiYnNRYWMzI2NRE0NjYzMhYXFSYmIyIGBhURFAaSJUoaF0EiYFNOkmQhRRcWPCA/TSKx/hQMCYgID4JvBRyBoUsJCIsJDjxtS/rlwKz//wBnAY4EKQQbBicAYQAAAMgCBwBhAAD/PQABAGcApQQoBQIAEwAnQBEBAAACExMFEA8LCgoJDAwGDwAvMzMRMzMvMxDOMjIRMzMvMzAxQRcHIRUhAyEVIQMnNyE1IRMhNSEDA3tvARn+qoMB2f3ohHpt/ugBVn/+KwIUBQI56If+7of+5DflhwESh///AGf//wQqBN0GJgAfAAUABwIqAAD9cf//AGf//wQqBN0GJgAhAAUABwIqAAD9cQACAGwAAAQ6BcEABQAJABlADQQJAQcEAAgCAnIGAAgAPzIrMhIXOTAxYQEBMwEBJwkCAi/+PQHDSQHC/j4kAUL+vv7AAt8C4v0e/SHHAhgCGf3nAAABANkE2QPCBgsADwAStw8JgAwPBAEEAC9dMxrMMjAxQQ4CIyImJiczFhYzMjY3A8IJU6B9gZ1LB5wLYGxgbgsGC2WIRUOIZ25QVGoAAQGJBM0CdQYUAAwADrQBBwyABQAvGs05OTAxQRUOAgcjNT4DNwJ1CS47H1sLFRQPBAYUESdvci4XHUxVUSEA////g/47AH3/gwQHBHH+DwAAAAEBgQTYAn0GIAALAA60AQuABwYALzMazTIwMUEVDgIHIzU+AjcCfRAkHQalCy9BJQYgFyJudSwTJm9zLQAAAgAVA1QCtQbHAAoAEwAdQA0GCwsJCQQBAQN4Dwd3AD8z5DkvMzMRMxEzMDFBIxUjNSE1ATMRMyE1NDY3BgYHAwK1gI7+bgGVi4D+8gMDCz0XsQQhzc1iAkT9zM8sbjEZXiL+/wAAAQA+A0ICiwbBAB4AH0AOHRwcGRkDBgYTDHgCHncAPzPkMjkvMzMRMxEzMDFBFSEHNjYzMhYVFAYjIiYnNRYWMzI2NTQmIyIGBycTAmL+hBMaPSSJtKykQ4wuOIo3X3BtZTZMHzwhBsFq6QUIjoCOnRwagCEmVlpRWRAIJgGoAAABADoDVAKSBsEABgAQtgUBAQZ4A3cAP+QzETMwMVMBITUhFQGjAWH+NgJY/p4DVAL6c1788QADADQDRQKUBtAAGQAnADMAF0AMJxoUBi4FIQx4KAB3AD8y5DIXOTAxQTIWFRQGBxYWFRQGIyImJjU0NjY3JiY1NDYTDgIVFBYzMjY1NCYnEyIGFRQWFzY2NTQmAWVxoVZBU2Goh2GJRypKLkJFpVQwQSFWVllVW1MBRE1VQEFOTwbQbW5MZCAicFRxiTtuSzlWQBcoWk5sdf4bFTNBKTxNTD08URsBhj44OEgZGEc6OD4AFgBU/oEHwQXuAAUACwARABcAGwAfACMAJwArAC8AMwA3ADsAPwBDAEcAUwBfAG8AeACBAJAAJ0ASEhgYLCwcHAwTBzk5NTUhIQERAD8zETMRMxEzPzMRMxEzETMwMVMRIRUjFSU1IREjNQERMxUzFSE1MzUzESE1IRUhNSEVATUhFQEjETMRIxEzATUhFQEjETMBNSEVMzUhFQEjETM1IxEzASMRMwUUBiMiJjU0NjMyFgUUFjMyNjU0JiMiBiUzMhYVFAYHFRYWFRQGIyMTMzI2NTQmIyMVFTMyNjU0JiMBIic1FhYzMjY1ETMRFAZUAS/ABc4BMG35AG/ABQ7Dbf1JARH74QEO/vIBDgS3bW1tbfvCARD8MG9vAsABEHcBEfqob29vbwb+bW37n3+Hh39/h4d//nNCRUdAQEdFQgHhrG5vLiwtPm1ez3tCLiQqLztKMSUmNAFeMCAQIBQlMX1vBL4BMG/BwW/+0MH5AgEvwm1twv7RbW1tbQb+b2/6qAEOAgIBD/o7bW0BpgEOBEpvb29v/C8BEHkBD/1oARBJh6amh4mkpIlcaWlcXGhoyUNTMUIICAk5RVBaAWIiICId45orJSAq/voKZgMFJDIBkv5yZV0AAAMAVP7BB6oGFAADACEALQAXQAkhJQIXDysrAgAALy85Lzk5EjkzMDFBCQIFNTQ2Nz4CNTQmIyIGBgcXNjYzMhYVFAYHBgYVFQMUFjMyNjU0JiMiBgP+A6z8VPxWA+sqQztOJ72jOXlwLlJEfzc/PjVETEMbUTw4U1M4PFEGFPxW/FcDqfsvMj40L1RiQ4mYGywbsiIuOi86RzU9cVA7/u1IPz9ITD09////kP4UAlMGIAYmA7AAAAEHAUv/YAAAAAqzEQsGcgArzjAx//8AGgPBAUEFtgYGAgYAAAACAAz/7ATOBiEAOwBHAC5AFR8cHCAjBUNDCDQjNCM0AC0QCXI8AAAvMisyETk5L30vETMzETMRMzMRMzAxQTIeAhczFSMWFhUUAgYGIyIuAjU0NjY1NCYjIgYHJzY2MzIWFRQGBhUUFjMyNhI1NCYnJiQmNTQ2NhciBhUUFhYXLgMCRG6sflESj4QCAkKH0I1pjlYlDw4mIRkzECQjXzRhUQ4PZnF8p1UCAvz+zIxKm3RdWmjovw09WXIGIVCZ3IyLFjgeof7uynA6ZYFGOW9jIzAmEQl2ERhoUC9rdT5dhokBFM4YORYDccF5VYlQiV1SUH5JAm2qdTwAAQAAAAAEgAXDAB0AG0APGBsAAxocAnIaCHIQCQNyACsyKysSFzkwMUE+Azc+AjMyFhcVJiYjIgYHDgMHESMRATMCOSNLSkIaHD1NNB0sEAwgDh05JRhOWlolrf4hugLOUa+oiy0xQiIICIUDAyRBKpW9z2T94AIvA4cAAAIAFv/sBnwESAAbADQALUAXKCgRAhwcGBgaGwZyDQ4kJBELci4KC3IAKzIrMhEzMysyMhEzETMROS8wMUEVIx4CFRQGBiMiJicjBgYjIiY1NDY2NyE1NwUhDgIVFBYzMjY1NTMVFBYWMzI2NTQmJgZ8+SMzHFergHGPIQcij2+6xyE6Jf7skgQ4/O0hOSN7bGRkoTFaP2t4GzAESItPpqlVnNVtYFtbYO3xVaumTUpBi0ejq1XDmpl3yMhXeUCdwFWpov//AMgAAAZqB5AGJgAwAAABBwB2AtYBbwAKsx8JAnIAK84wMf//AK8AAAbCBiEGJgBQAAABBwB2AwYAAAAKsy8hB3IAK84wMf//AAD90wUNBbwGJgAkAAAABwJTATQAAP//AF790wPLBFoGJgBEAAABBwJTAMcAAAAQtQMCLwsBAbj/lrBWACs0NAACAHX90wI1/4IACwAXABC0DADAEgYAfC8zGhjMMjAxQSImNTQ2MzIWFRQGJzI2NTQmIyIGFRQWAVJhfHtiX4SCYTVDRjI0Qz3903JlZHR0YmdyYEA3OT8/OTdAAAIAff/sBmIGFAAcACsAG0ANFxURGgUoDgNyIQUJcgArMisyEjk5zjIwMUEUAgYGIyImJgI1NBIkMzIWFz4CNTMXBgYHFhYFFBIWMzI2EjUQAiMiBgIFulWp+aWr/adSlAEs5Kf9VTg6FrIOFXR9Ly/7dmnbqqvYZur8q9xqAt2p/uvHbGzIARap4AFSvHJmEE92ShV9xi9Y2X+6/vCUlAEQugEaAUCS/vIAAgBy/+wFGATwABoAKQAbQA0UEg4YBCcLB3IfBAtyACsyKzISOTnOMjAxQRQGBiMiJiY1EAAzMhYXPgI1MxcOAgcWFgUUFhYzMjY2NTQmJiMiBgRge+OdkuJ/AQ/rbbVBOzwUsA4QPmVMIiX8vkWTc3SSRUWSdayeAia0/4eH/7QBDgEoSkQTUXZIFV6SZh1Bol+MwWNkwYuKvmLZAAABALn/7AZ4BhQAHwAdQA4HBR8fAQwRFQJyGhEJcgArMisSOTkzL84yMDFBFT4CNTMXDgMHERQGBiMgADURMxEUFjMyNjY1EQUaQUUbrw4MLU98WnX0wP7r/t2ryciGqE4FtsgLTHxTFUmBZ0YQ/Yyb8osBJvYDrvxLuMphrnIDtgAAAQCj/+wFjwTyACIAKUAVAQAcHB4GDhMGcgkKChgYDgtyBwpyACsrMhEzETMrEjk5My/MMjAxQRcOAwcRIycjDgIjIiYmNREzERQWMzI2NREzFT4CNQWBDgstTnlYiBgJImqGS4SyWah8f7aVp0BCGATyFkiEakYK/KqaOU4nVLCKAsz9QImHzsMCP3oMTnxQAAAB/QUEuP5zBpEAFQAVQAkGAwwTwA8EAQQAL10azDI5OTAxQRQGBwcjJzY2NTQmIyIGBzU2NjMyFv5zXkkJaA1NV007HDcSFDgneYIF2k1VEW+tDTExMSQFBGQGB1v//wDIAAAD9geQBiYAKAAAAQcAQwEVAW8ACrMSAgJyACvOMDH//wDKAAAFTQeQBiYBsQAAAQcAQwHCAW8ACrMcAAJyACvOMDH//wBy/+wEEwYhBiYASAAAAQcAQwDqAAAACrMmAAdyACvOMDH//wCvAAAEZAYhBiYB0QAAAQcAQwE9AAAACrMZEgZyACvOMDEAAQA0//UHHgW2ACsAHkAQHxQUGgsqEAQABQJyJQAJcgArMisSFzkzETMwMUUmCgInMxYaAhczNjY3Ey4CJzMWGgIXMzYSEhMzCgIHIy4DJwEB6FSWdksJsApDYGwyCg4xH88MFQ0CsQZDZng6B1R+SAOyBV2sfZYzY1pKGv7gC5MBWgF9AY/Ivf6T/rP+5Ws6mVQCLEeUkD+w/pn+rP7Xc6UBjwHQAQP+6v30/ijHVMjV0l384AABACcAAAYOBEoAKAAfQBEoHh4jFRoJGwULEAZyBQsKcgArMisSFzkzETMwMUEGAgIHIy4CJwMjJiYCAiczFhISFzM+AjcTJiYnMxYSEhczNhISNwYOCVmgdZwqVUka9pdAe2RABqQMVXQ5Bg0jJRGbGRsDpgVGbT4ITHpNCgRKyP6K/p6qSKyzUv4HZvgBGgEyoMX+nv7caSNHSSUBOGXbZKj+sP7Gh3UBKwFbvgACABQAAAT8BbYAEwAdACRACgcKCgQBHQsLAAW4//+0chQACHIAKzIrEjkvM80yMhEzMDFhESE1ITUzFSEVIREzMhYWFRQGISczMjY1NCYmIyMBV/69AUOsAaT+XM3R82j5/uvr18KwVbGJugRTj9TUj/71a7t3xOeRjI5iczIAAAIAFAAABJ8FJwATABwAIUAQFQUFARYOCnIQBAQTEQEGcgArMs0zETMrMhE5LzMwMUEVIRUhESEyFhUUBgYjIREjNTM1ASERITI2NTQmAawBXf6jAUHc1lvCm/4h9PQB1v7OATOAnJMFJ9+L/sWcmGaWUgO9i9/80f6PWWZkTgAAAQDI/+wHJQXLACoAJ0AVCxwcBB8fABcQA3IIAnIHCHIkAAlyACsyKysrMhI5LzMzETMwMUUiJAInIREjETMRIT4DNzIWFwcmJiMiDgIHIRUhHgMzMjY3FQYGBXje/tqVB/6aqqoBaw5nsfmfcMlRREejYnG0g1AOAr/9PQVFgb18Y6tUULAUsAE91v1RBbb9j5Dtq10BMymRIzRCf7h3lYTPkUshGZQeHQABAK//7AWvBFwAJwAmQBQWDwdyGgoKHQUFBwgGcgcKIQALcgArMj8rEjkvMzMRMysyMDFFIiYmJyERIxEzESE+AjMyFhcHJiYjIgYGByEVIR4CMzI2NxUGBgSHk+GFCf7Rp6cBMRGM3otTmDcwN4A7bJRRCwIe/eAGT5VuWIc8OIQUb+Su/hMESP4zptVmIRmJFx1LlnGOeqVUJBmRHB4AAgAAAAAFXAW2AAsAGAAjQBEEBwcMCxISCQsCcgIGBgkIcgArMhEzKxI5LxI5MxEzMDFBASMBIxEjESMBIwEXDgMHByEnLgMDAAJctP7smZua/umvAlxRBhUZGwxQAVhYCxcWFAW2+koCpv1aAqb9WgW2qRdBSEgezt4dPD0/AAACAAcAAARqBEgACwAXACNAEQQHBwwLEhIJCwZyAgYGCQpyACsyETMrEjkvEjkzETMwMUEBIwMjESMRIwMjARcjDgIHByEnLgICnQHNqslylnjFqwHMaQgKFhkPPwEWPw8cFQRI+7gB4/4dAeP+HQRIdCE/QiShnyhJPwAAAgDIAAAHYQW2ABMAIAAwQBcaEREMBAgIFA8MDA4TDwJyAgYGCgoOCAA/MxEzETMrMhI5LxI5MxEzETMRMzAxQQEjASMRIxEjASMBIREjETMRIQEXDgMHByEnLgMFBgJbuv7tlJqX/uq1ARr+VKqqAesBA1EHExUZD1EBT1QMFxUTBbb6SgKs/VQCrP1UAqz9VAW2/YwCdKkeOz1BJNLcID07OwACAK8AAAYOBEgAEwAfAC5AFhoREQwECAgVDAwOEw8GcgIGBgkJDgoAPzMRMxEzKzIROS85MxEzETMRMzAxQQEjAyMRIxEjAyMTIREjETMRIRMXIw4CBwchJy4CBEIBzKnLcpZyzKrO/tqjowFjw2kHCRgbED0BFD4PGxQESPu4Aer+FgHq/hYB6v4WBEj+LgHSdBpFTSaOnChHPgACABcAAAWvBbYAHgAhACZAEiECAhwcDRAQFSAeAnIIDw8VCAA/MxEzKzIROS8zMxEzETMwMUEVAR4CFxMjAy4CIxEjESIGBgcDIxM+AzcBNQUhAQUq/lmHnVwjia2JHkN1aqtpc0EeiLSJGj1aiGT+YQO+/Q4BeQW2fv4LCFujc/42AcVibSv9QQK/LGxi/jsBylWGYDgGAfV+mf45AAIADAAABQMESAAdACAAJkASIAICGxsNEBAVHx0GcggPDxUKAD8zETMrMhI5LzMzETMRMzAxQRUBHgIXEyMDLgIjESMRIgYGBwMjEz4CNwE1BSEBBH3+sHB8SCCCp4AbO15TmlZeNx2CpYEhSH1u/rADG/23ASQESGT+mApNf1X+rwFKSFIj/fkCByJTSP62AVFTf04LAWhkif6/AAIAyAAAB8MFtgAjACYAP0AfASIiJSMjHiYCAiAgGw0QEBsbHR4Cch0ICA8PFhYcCAA/MxEzETM/KxI5LzMRMxEzETMRMxEzETMzETMwMUEVAR4CFxMjAy4CIxEjESIGBgcDIxM2NjchESMRMxEhATUFIQEHPP5ah51bI4uoiyBHdWisaHZDHYiykRs5J/4+qqoC1v5nA7/9EAF5BbZ+/gkHW6Jz/jYBxWdqJ/1DAr0tbF/+OwHRV20f/UwFtv2UAe5+mf43AAIArwAABq0ESAAjACYAOkAcASIiJSMjHiYCAg0NEBAgGxscHgZyCA8PFhYcCgA/MxEzETMrEjkvMzMRMxEzETMRMxEzMxEzMDFBFQEeAhcTIwMuAiMRIxEiBgYHAyMTNjY3IREjETMRIQE1BSEBBij+sHB8RyCCpoAbO15TmVRgORyCpoIULRr+v6OjAjj+sgMb/bYBJQRIZP6WCkx+Vf6vAUpHUSP9+wIFIlJH/rYBUTRVGf4NBEj+NgFmZIn+xQAAAQBA/k8ENwbRAFoAPUAdJCAgLxEQQEA3GS89PQorLwcAAFJUgFdOTkcKA3IAKzIyETMazDIyLzMvMxI5LxI5OTMSOTkRMxEzMDFBMhYXFSYmIyIGBxYWFRQGBxUWFhUUDgIHDgIVFBYzMjY2MzIWFxUmJiMiBgYjIiYmNTQ2Njc2NjU0JiMjNTMyNjY1NCYjIgYHJzY2Ny4CJzUzFhYXPgIDVyAyEQ0mEjFvL7S/wpu0x0KJ1pVydipLZ1R/dUNWZx4WbWFAbntWhpxCWMSiyr3z0NLNj75fqId8wVdTTLJvIlJPH3oyejQoWGUG0QkFbQUGWUQXwoyVrxoHGq+TYJtvPgQEITUjMTsHBxURohEhBQZDdElQc0IFBY2OkX2PQ3tUc3xHOHQ0TQ4pV1IeGSFtNzFdPQAAAQAb/nsDgAVNAFsAO0AcJCAgLxARQkI3GS8/PworLwcAAFNVgFhPSAoGcgArMjIyGswyMi8zLzMSOS8SOTkzEjk5ETMRMzAxQTIWFxUmJiMiBgcWFhUUBgcVHgIVFAYGBw4CFRQWMzI2NjMyFhcVJiYjIgYGIyImJjU0NjY3PgI1NCYmIyM1MzI2NTQmIyIGByc2NjcuAic1MxYWFz4CAvsfMg8MJhAwZy56jXBfQ25DYs+iaWwmSV1IgnUxRE8VGVsxL32OSXOENkeljGOUUUaNapF5j6eDeFGUUDtAeUUdRkUdeTJuOCdYZgVNCAVuBQVQPhmMa2N3GggRQWpQXI5TBAIdMSIwLwYFFROMFBYGBkNqO0VtQwQDJlRGQVMniVBeUlEkI4UbJAglT0oaGSRkODFaOgD//wBvAAAF7gW2BgYBdAAA//8Ao/4UBYoGEgYGAZQAAAADAH3/7AW8Bc0AEQAaACIAGUAMHxcXBRsOA3ISBQlyACsyKzIROS8zMDFBFAIGBiMiJiYCNTQSJDMyBBIBMjY2NyEeAhMiBgYHISYCBbxWqfqlqv2nU5QBLePZASmZ/WKg1G4H/CwIbdWkntNyCwPSEesC3an+68dsbMgBFqngAVK8uv6v/L2D9amp9IQEuH3noPMBEQADAHL/7ARgBFwADgAXAB8AGUAMGxQUBBgLB3IPBAtyACsyKzIROS8zMDFBFAYGIyImJjUQADMyFhYBMjY2NyEeAhMiBgchLgIEYHvjnZLifwEP65bhff4JbI1KBv1sBkuPap2eDgKTCU2MAia0/4eH/7QBDgEohv39nVeoeHioVwNasKhvmVAAAQAAAAAFRgXDAB0AF0AMABcDcg0GBwJyBghyACsrEjkrMjAxQSIGBgcBIwEzAR4CFz4DNxM+AjMyFhcVJiYE4zBANR/+tML977IBWBgkHQwIFRgbEKwuUXJgIz8YGDAFNjt8ZPvlBbb8Q0RwYzImUFZeMwIflLJRDgaMCAsAAQAAAAAEPgRUABsAF0AMEw0OBnINCnIHAAdyACsyKysSOTAxQTIWFxUmJiMiBgYHASMBMwEWFhczNjY3Ez4CA+8XJxENJREfLiUT/v3a/metAQodKQYHCSEXlyNCXQRUBgWDBQYlTDv82wRI/SJTfiArjUUB0Gl2L///AAAAAAVGB5AGJgJxAAABBwQMBM8BbwAMtCQxBwJyACvOzjAx//8AAAAABD4GIQYmAnIAAAEHBAwEYgAAAAy0Ii8OBnIAK87OMDEAAwB9/hMJnAXNABEAIQA/ACZAFj8oKQMiOjMPLQZyIgZyHg4DchYFCXIAKzIrMisrPzMSFzkwMUEUAgYGIyImJgI1NBIkMzIEEgUUEhYzMjYSNTQCJiMiBgIlMxMeAhczNjY3EzMBDgIjIiYnNRYWMzI2Njc3BU1Pm+aYnOiZS4cBFNHIARCM++Few5eZwFtbwJaYxF8Ecq/4FSQbCQgLNh7ir/4nJmaQZTFIGxg9Iz5bQxg8At2p/uvHbGzIARap4AFSvLr+r+W6/vCUlAEQur0BDZCS/vOw/YA2Zl4sMqFUAn/7F2WWUQsHhQUIL1o+mv//AHL+EwipBFwEJgBSAAAABwBcBKcAAAACAH3/jAYEBigAHQA4ACdAEyEkHiQkAwAbCXIxLisrDwwSA3IAKzLNMxDNMyvNMzMRMxDNMDFFIiYnLgICNTQSJDc2NjMyFhcWFhIVFA4CBwYGAzY2MzIWFz4CNTQCJwYGIyImJw4CFRQWFgNFNkcLjdeSSoUBAbsLRzUzRw2z/odMkdOHDUi7EUM0L0URgq5Yx8EQRi80QxCDsltasnQxOBR8wwEAl8oBOcUbOC4uOBzF/sfLl/3CfRU4MQEBLSYnLBud96H0ATInLicnLRmc9qGi+JwAAgBy/5cEwQSuABoAMwAnQBMlIh8fFBEXB3IuMSsxMQoHBAtyACvNMzMRMxDNKzLNMxDNMzAxQRQGBgcGBiMiJicuAjU0Ejc2NjMyFhceAgc0JiYnBgYjIiYnBgYVFBYXNjYzMhYXNjYEwWXAhwk9NDY7CYLCa+TNCDs1Mz4Jg8BprDdyWQ06MTM6C4d+fogLOjIwPAyGfAImneyRFzEtLDQWj+uf6wEgIjMoKDUWkuibcatuFCgiIyke1K6v2B4pISImH9gAAwB+/+wHqQhAABYAKQBrAENAI0xmCXJVXANyDA0NEwaAFhYjGBc6MwNyaUlGRkNHR0NDKglyACsyETMvETMRMzMrMt4yzDIvGswyMxEzKzIrMjAxQTU0PgIzMh4CMzMVIyIuAiMiBhUTNTY2NTQuAjU0NjMyFhUUBgYBIiYCNTQSNjYzMhYXByYmIyIOAhUUEhYzMjY3ETMRFhYzMjYSNTQuAiMiBgcnNjYzMhYWEhUUAgYGIyImJwYGAq0gPFY3PHBygE0QFFaLc2ItOTpfOz4dJx0zKjdBNWr+3rz7fUiJwXlPlz1BL2s8VoddMF+8i0N0NKs1d0WLu18xXYZWPWsvQT2XT3rBiEhGjdKNbLBHSK8HShw2UTccJDAkdyIuIj08/rtHEjQcFBMQGxslJUQ7NVhB+dTCAVriqAEQwWgxKoAjKVKb3Yu7/u2WMSkBvv5CKy+WARO7i92bUikjgCoxaMH+8Kiq/ufMbz89PT8AAAMAd//sBrgHAAASACkAZwA9QCBMYgtyU1oHchkaGiATgCMjAAgHOjMHcmVCRkZCQioLcgArMhEzLxEzKzLeMswyLxrMMjMRMysyKzIwMUEyFhUUBgYHNTY2NTQuAjU0NicyHgIzMxUjIi4CIyIGFSM1ND4CAyIuAjU0EjYzMhYXByYmIyIGFRQeAjMyNjcRMxEeAjMyNjY1NCYjIgYHJzY2MzIWEhUUBgYjIiYnBgYDgTZCNmpOOz0dJh0xODxwcn9MEhVXi3JiLTg6eh88V5ttrnhAacOHRHExNy9WKoCHKU9xSEptOacmSVEyYIdHiIEoVC84MHBFiMNpcdKQdKU1N6IGJ0Q6NllAE0UUNhwUEw8ZGyYl2SQuJHkjLiM7Px02UTYb+OxLkdKGuAEAhiEbgBYa3NRinm87NDkBSP66JzEXaL+D1NwaF4EbIYb/ALiz/IVTQEJRAP//ADT/9QceBxMGJgJdAAABBwOJAWUBbwAKszcFAnIAK84wMf//ACcAAAYOBaYGJgJeAAABBwOJAMIAAgAKszQQBnIAK84wMQABAHz+FATiBcsAIAATQAkQFglyFQcAA3IAKzIvKzIwMUEyFhcHJiYjIg4CFRQSFjMyNjcRIxEiLgM1NBI2JANKcdNURUeqZXzGjElw7LovVSWqmOmpbDNguQEKBcstKJIiLVOd3ou3/vSSCg39eAHYSIW65oOlARPJbgAAAQBy/hQDpgRcAB0AFUALDxULchQPcgcAB3IAKzIrKzIwMUEyFhcHJiYjIgYGFRQWFjMyNjcRIxEiLgI1NDY2AoJRnzQwNYg8dZxOUZ1yPVImpoLIikeJ7gRcIRmLFCBdvpCTulkXEP1zAdhDidWRyP54AAABAG3//gRuBQUAEwAMswUMCgAALy85OTAxQRcDBQclAwUHJQMnEyU3BRMlNwUDl3G6ASBB/uPSAR4//uG5crn+4T8BIdH+4EABHwUFQP6+pm2m/paobab+wT8BQ6ZtqAFspm+oAAAIACv+wwe/BY8ADQAbACkANwBFAFMAYQBvABhADEkRVy0DOwYfbGUmHwAvMy8zEhc5MDFBNjYzMhYXIyYmIyIGBwE2NjMyFhcjJiYjIgYHATY2MzIWFyMmJiMiBgcBNjYzMhYXIyYmIyIGBxM2NjMyFhcjJiYjIgYHATY2MzIWFyMmJiMiBgcTNjYzMhYXIyYmIyIGBwE2NjMyFhcjJiYjIgYHBV4FZWVhawdMB0w0PUMH+zcFZWVhawdMB0w0PUMHAfYFZWRiawZLB000PUII/MkFZWVhawdMB00zPUMHagVlZWFrB0wHTDQ9QwcEOQVlZWFrB0wHTDQ9Qwd3BWRmYGwHTAdNMz1DCPy3BWRlYmoHSwdNND1CCAO0WWZqVTgjHzz8JVlmaVY4Ix88/upYZmpUOCMgOwMKWWVpVTkiHzwB51lmalU4Ix88/CVZZmlWOCMfPAH0WWVqVDgjHzwDBFllaFY4Ix88AAgAK/5/B38F0wAJABMAHAAlAC8AOABCAEwAGEAMLwoZQTUEBiJGTCUiAC8zLzMSFzkwMUEXBgYHJzc+AgEXBw4CByc2NgEWFhcVByYmJwEXBgYHIzY2NyUXHgIXByYmJwEWFhcHJyYmJwEeAhcVJiYnNQEGBgcjJz4CNwZ3QkujPFwCLW1z+9lcAyxtczZBSqT+TFXASQ5MtU8ECAsTQyNcFigKAgURGzYzFD8ubCz8Li5rLVwRKFEfBOYzc3U1Vb9K/iEVKAqCCw0mLhcEokEtay1cEBs3NPwBWxEaNzMVQC1sAjIWJwuCCxRCI/2kDky1T1XASdkCLW1yNUJKpDsEn0qkPFsCRK1Q/dkMJy0YXBUoCoIDTlW/Sg4zc3U1AAIAyP6CBg4HXwAXACcAJ0ATIx2AIBgHEQkTCwJyFQACAgkIcgArMhDOMysyEjk53jIazDIwMUETIxE0NjY3IwEjETMRFAYGBzMBMxEzAwEiJiYnMxYWMzI2NzMOAgS1naUFCAQJ/M67nwUGAggDLrrEl/2TgJxJB5gKYmxfbwqdB1Sh/oIBfgNDOpGOMvsyBbb8sUCRgSsEzPrg/ewHq0KIaG5PU2pliEUAAgCv/ocFHQYLABUAJQAnQBMhGoAeFgcQCBEKBnITAgIACApyACvOMxEzKzISOTneMhrNMjAxQRMjETQ2NjcBIxEzERQGBgcBMxEzAwEiJiYnMxYWMzI2NzMOAgPtgKQCBAH9q8yeAwUDAlbMuYb+AoCcSweaCWNrX3AKnQhTof6HAXkCoShgWh/8XgRI/WoqXlsoA6H8Rf36BlJDiGduUFRqZYhFAAIALAAABHcFtgATAB0AIEAPFQUSAQEPBAQOEwJyFg4IAD8zKxI5LzMzETPOMjAxQRUhFSERMzIWFhUUBCEhESM1MzUBIxEzMjY1NCYmAXIBRv66xdb8bv74/ur+b5ycAX3T3b65WqwFtsCU/uZpunrK4QRilMD8/P3fjI5iczIAAgAdAAAEUgYUABQAHQAgQA4TEBABBAQPFBYFBRcPCAA/MzMvMy8SOS8zMxEzMDFBFSEVIREhMhYWFRQGBiMhESM1MzUBIREhMjY1NCYBXwEn/tkBQJTBXlzDm/4gm5sB1/7QATGBmpAGFPd//eZGimZmllIEnn/3++T+j1lmZE4AAAIAyAAABHMFtgAQAB8AN0AbAxgYERYXFxEGFRUREQoFBAQKCgwfDQJyDAhyACsrMhE5LzMRMxEzETMRMxEzETMRMxEzMDFBFAYHFwcnBgYjIxEjESEgBAEzMjY3JzcXNjY1NCYjIwRzaHN1Y480dEa7qgGLARgBCPz/rC1OJWhqhDxDv8bMBAt3zD2bUr0ODv3BBbbd/fgFBYtQqyN5XZKPAAIAr/4WBHMEXAAdADIAOUAeDR4eEgdyCwZyCg5yLCsrLSoqBCcnGBsbGRoaAAtyACsyETMyETMyETMzETMzETMrKysyETMwMUUiJiYnIxYWFREjETMXMz4CMzISERQGBxcHJwYGAyIGBgcVFBYWMzI2Nyc3FzY2NTQmAq5XhF4fDAUHp4kYByBdhFrN9F1UcWOAI1JGcotAAj2NdxowFnhofjIxlxQuTi4sciD+PgYyojJTMf7m/uWr8EacTqwNDwPkWK+DIYvAZAkInk6lNq141NMAAQAuAAAECgW2AA0AHUAOCwMDCgYGCAINAnIICHIAKysyETkvMzMRMzAxQRUhESEVIREjESM1MxEECv1oAan+V6qamgW2mP4Alf13AomVApgAAAEAEAAAA0oESAANAB1ADgsDAwoGBggCDQZyCApyACsrMhE5LzMzETMwMUEVIREhFSERIxEjNTMRA0r+CgFb/qWmnp4ESI3+qIH+HgHigQHlAAABAMj+AATeBbYAJgAfQA8DAAAKDQ0eFwkGAnIFCHIAKysyLzM5LzMzETMwMUEiBgcRIxEhFSERNjYzMh4CFRQOAiMiJic1FhYzMj4CNTQmJgIzLnMgqgNN/V0nfDqk9qNST5DHeFuBOz99R16QYTF14QKPCwX9gQW2mP3yCA1cq/GWpvmmUhgZmBkYQoK/fKTgdAAAAQCv/goD/wRIACEAI0ASHhsbAwYGDgIhBnIgCnIVDg9yACsyKysyETkvMzMRMzAxQRUhETY2MzIWFhUUBgYjIiYnNRYWMzI2NTQmIyIGBxEjEQNV/gEjTiis63l0x31NczIvdkaGjrG4I08jpwRIjf6zBgl6/sjE+XYeHJQZI8/T3dAJCf4nBEgAAQAE/oIG+AW2ABUAKEAWCxEIFA4BBgcVEw8CcgkEBwIHBw0IcgArMhEzEMwzKzIyEhc5MDFBAQEzESMRIwERIxEBIwEBMwERMxEBBqD9xAHbuaJl/b6k/b3EAlL9xL0CNKQCNAW2/Tv9p/3qAX4C5f0bAuX9GwLwAsb9PALE/TwCxAAAAQAE/ocGHQRIABUAKEAWAQ4RCxQIBgcVEw8GcgQJCQIHBw0KcgArMhEzMy/MKzIyEhc5MDFBAQEzESMRIwERIxEBIwEBMwERMxEBBbP+OAFzv6Fg/iCb/iG+Ae/+N7cBwJsBwgRI/ev+WP38AXkCLP3UAiz91AIzAhX97AIU/ewCFAD//wBP/j4EOwXLBiYBsAAAAAcDawFcAAD//wBD/j4DgARcBiYB0AAAAAcDawEHAAAAAQDI/oIFKgW2AA4AIUARCA0BAwoOCwJyBAcCBwcKCHIAKzIRMxDMKzISFzkwMUEBATMRIxEjAREjETMRAQTE/XkCG9Kjdf1gqqoCjwW2/Tr9qP3qAX4C5v0aBbb9PALEAAABAK/+hgQ/BEgADgAfQBADCAsDBQoGBnIMAgIABQpyACvOMxEzKzISFzkwMUERIwERIxEzEQEzAQEzEQOgWP4Op6cB2Lf+JwGDsP6GAXoCLP3UBEj97AIU/e/+Vv35AAACAMgAAATgBbYAAwAOACNAEgYLDgMJAgECAQgNCQJyBQgIcgArMisyEjk5Ly8RFzkwMUEjETMBIwERIxEzEQEzAQJvdXUCcc79YKqqAo/D/XkBIwOo+zUC5v0aBbb9PALE/ToAAgCvAAAECwRIAAMADgAjQBIJDgYDDAMCAwILBQwGcggLCnIAKzIrMhI5OS8vERc5MDFBESMRJTMBASMBESMRMxECSXsBYLf+JwH/w/4Op6cD9vxpA5dS/e/9yQIs/dQESP3sAAIAHwAABOAFtgADAA4AHUAPBgsOAwgAAQ0JAnIFCAhyACsyKzLOMhIXOTAxUzUhFQEjAREjETMRATMBHwIdAqTO/WCqqgKPw/15BHCWlvuQAub9GgW2/TwCxP06AAABABEAAAQLBhQAEgApQBYSAHILBQgDBwoKDQpyARERDg4EBwZyACvOMhEzETMrMhESFzkrMDFBFSEVIREBMwEBIwERIxEjNTM1AVYBbf6TAdi3/icB/8P+DqeengYUu3z9VwIU/e/9yQIs/dQE3Xy7AAABAA0AAAV0BbYADAAbQA4ECwEDBgwICQJyAwYIcgArMisyMhIXOTAxQQEBIwERIxEhNSERAQVZ/XkCos39YKv+sQH6Ao8Ftv06/RAC5v0aBR6Y/TwCxAAAAQAmAAAE1wRIAAwAG0AOCwEEAwYMCAkGcgMGCnIAKzIrMjISFzkwMUEBASMBESMRITUhEQEEsf4nAf/B/gyj/qcB/AHaBEj97f3LAiz91AO/if3sAhQAAAEAyP6CBcgFtgAPAB9ADwkEBAYMBwJyDQICAAYIcgArzjMRMysyETkvMzAxQREjESERIxEzESERMxEzEQUlsfz+qqoDAqis/oIBfgKx/U8Ftv2RAm/64v3qAAEAr/6HBP8ESAAPAB9ADwkEBAYMBwZyDQICAAYKcgArzjMRMysyETkvMzAxQREjESERIxEzESERMxEzEQRaof2dp6cCY6ag/ocBeQHv/hEESP40Acz8Rf36AAEAyAAABmoFtgANAB1ADgMMDAAIBQUBAnIKAAhyACsyKzIRMxE5LzMwMXMRMxEhESEVIREjESERyKoDAAH4/rKq/QAFtv2RAm+Y+uICsf1PAAABAK8AAAW5BEgADQAdQA4DDAwACAUFAQZyCgAKcgArMisyETMROS8zMDFzETMRIREhFSERIxEhEa+nAmMCAP6mpv2dBEj+NAHMifxBAe/+EQAAAQDI/gAIJgW2ACkAI0ARIh8fAQQEKCYpAnIkKAhyFQ4ALzMrMisyETkvMzMRMzAxQRE2NjMyHgIVFA4CIyImJzUWFjMyPgI1NC4CIyIGBxEjESERIxEE1yd1N5ztoVJOj8Z4Xn08Pn5GXY9hMT13r3MwdyCo/UOqBbb9XwcHXKzyl6P2plMaF5gXGkOCvXp8vIBBCAj9gwUd+uMFtgABAK/+CgarBEgAIwAlQBMcGRkBBAQiICMGch4iCnITDA9yACsyKzIrMhE5LzMzETMwMUERNjYzMhYWFRQGBiMiJic1FhYzMjY1NCYjIgYHESMRIREjEQQeI0wkkuSEbLl2SW4uLGtCe4KoryBNH6b93qcESP4mBgl1/c7E+XYeHJQZI8/T3dAKC/4qA7v8RQRIAAIAff+sBd8FzQA9AE4ALEAVQjo6FSUeA3IxLi4VCXJLBAQSBwcPAC8zETMzETMrMhEzKzISOX0vMzAxQRQGBgcWFjMyNjcVDgIjIiYnBgYjIiYmAjU0EiQzMhYXByYmIyIOAhUUEhYzMjY3LgI1ND4CMzIWFgc0JiYjIg4CFRQWFhc+AgW1R3ZGIFIyJkccEjA2HF+eRzKBRJ/1qFeMAR3ZRHQlLRpmMnmvcTZ53ZYdNhY6Uio3ZYhRaahirC1YQDJLMxotUDRGYzUCqYXhqDMREwwKlQgMBTUvEhJpwgEPpu8BWbkVDpAKE1Of44/G/veFBwZErsdogb19PWTfvnOnWjZjiFNks5M3LZS6AAIAcv/GBMwEXAA3AEUAK0AVOBgYAD8REQ4OLC8Lch8iIikHAAdyACsyLzMRMysyMhEzETMROS8zMDFBMhYXByYmIyIGFRQWFjMyNjcmJjU0NjYzMhYWFRQGBxYWMzI2NxUGBiMiJicGBiMiJiY1ND4CASIGBhUUFhc2NjU0JiYCSzlRHiQWRyikikSUdyQ2Cj5PUY5bWIdMdFEVQiAdOhwYRCNJiToraEuh3nI7d7EBpi9CIU03Q1QePQRcDgmIBg3m03i9bAsEQrh7e6FOTKB+jco5DBEHB4YIByolERiV/puC1ZlS/oU4aUxrni4soHBJaDcA//8Aff4+BMsFywYmACYAAAAHA2sCJgAA//8Acv4+A5IEXAYmAEYAAAAHA2sBggAAAAEAEP6CBFMFtgALABdACwgEBAUCcgkAAghyACvOMysyETMwMUERIxEhNSEVIREzEQKQs/4zBEP+M63+ggF+BR2Zmft7/eoAAAEAKf6HA5gESAALABdACwIKCgsGcgUDCApyACsyzCsyETMwMUEVIREzESMRIxEhNQOY/pmfoqH+nARIi/zO/fwBeQO9i///AAAAAAR5BbYGBgA8AAAAAQAA/hQD/wRIAA8AGEANDwIICQQBDgMGcgEPcgArKzISFzkwMUEjEQEzExYWFzM2NjcTMwECUqb+VK3wHTcKCg0zH+2u/lP+FAHpBEv9jlCsMjKqUgJy+7UAAQAAAAAEeQW2ABAAJUASCwgFBQwDAw8CAgYQCHIKBgJyACsyKxI5LzMzETMzETMzMDFhESE1ITUBMwEBMwEVIRUhEQHo/s4BMv4YugGDAYW3/hkBMP7QAWaWMwOH/SMC3fyBO5b+mgABAAD+FAP/BEgAFQAhQBABCQkEERAICAYVCwZyBg9yACsrMhE5Lzk5MzMRMzAxQQEhFSERIxEhNSEBMxMWFhczNjY3EwP//lUBGf7lpv7jARv+Vq3sIjMNCBA2IuYESPu4gP6UAWyABEj9k1qYQUGdXAJmAAEABv6CBOAFtgAPACBAEQMGDAkEAgsHAnINAAICBQhyACsyEM4zKzISFzkwMUERIwEBIwEBMwEBMwEBMxEEPGX+df5vtQHn/ju9AW0Bb7T+PAGEq/6CAX4ChP18AvoCvP25Akf9R/2b/eoAAAEAJ/6GBEEESAAPACBAEQMMBgkEBQsHBnINAAICBQpyACsyEM4zKzISFzkwMUERIwEBIwEBMwEBMwEBMxEDn1T+zf7LvAGN/oW+ASEBILz+hQEtm/6GAXoBv/5BAjECF/5aAab96f5c/fkAAAEAEf6CBqwFtgAPAB1ADggEBAwFAnINCQkAAghyACvOMxEzKzIyETMwMUERIREhNSEVIREhETMRMxEGC/uu/lgEMP4jAu2psv6CAX4FHZmZ+3sFHvri/eoAAAEAKf6HBZgESAAPACFAEAwFDQkJCAQEBQIKcgUGcgAALysrETMRMzIRMxEzMDFBESERITUhFSERIREzETMRBPX8cv7CA0v+mAJCp6P+hwF5A72Li/zQA7v8Q/38AAABAKf+ggVvBbYAFwAhQBAWExMHCgoGFw4CcgMBBghyACsyzCsyETkvMzMRMzAxQREzESMRIxEGBiMiJjURMxEUFjMyNjcRBMOsorN10oDP3aqBknvDeAW2+uL96gF+Al4qNL+zAkT91Hl7LSoCyQAAAQCa/oUEywRIABcAG0ANEwoKBhcOBnIDAQYKcgArMswrMhE5LzMwMUERMxEjESMRBgYjIiY1ETMRFBYzMjY3EQQsn6WgXLJ8qbmmcWxoqlcESPxF/fgBewHrO0SwlgGW/nZnYkA3AdwAAAEApwAABMMFtgAbADNAGRoXFxQVFRQUCQMGBgkICAkJARsPAnIBCHIAKysyEjkvMy8RMxEzETMRMy8RMxEzMDFBESMRBgYHESMRIi4CNREzERQWMxEzETY2NxEEw6xIklN1ca11O6qJm3VTl0MFtvpKAlocLAr+ygEuLlyLXQJE/dR6egFf/qgIKhoCzQABAJoAAAQeBEgAHAAvQBcYFRYWFRUMBgkJDAgIDAwBHBAGcgEKcgArKzIROS8zLxEzETMRMxEzLxEzMDFBESMRBgYHFSM1BgYjIiY1ETMRFBYXETMRNjY3EQQepzx1RXEGDAips6ZpZ3FBeD0ESPu4AespOg756wEBspQBmP50ZWEDAS3+3ww4KQHcAAEAyQAABOUFtgATAB1ADhEODgIFBQAKEwhyAAJyACsrMhI5LzMzETMwMVMzETY2MzIWFREjETQmIyIGBxEjyal03XbN36uAk3vDd6kFtv2iKzO+s/27Aix6ey4p/TYA//8ArwAABEEGFAYGAEsAAAACADj/7AY/Bc0AKQAyACVAEh4eJCQvLxcGBgAKEglyKgADcgArMisyEjkvMzMRMxEzLzAxQTIEEhUVIR4CMzI2NjcVBgYjIiQCJyMiJjU0NjczBgYVFBYzMz4DFyIOAgchNAID69UBBnn71gp34qhbnYo+Vd2g2f7Znw0ucIwRC48HDjs7IBJlo+CLaKZ4RggDdcQFzbT+vddirPF/FyQVmx8rpwE11X9qKUMXEDwjNDai+atXmESEwH32AQ8AAgAt/+wE3ARaACcALwAlQBIdHSMjKysVBgYACRALcigAB3IAKzIrMhI5LzMzETMRMy8wMUEyFhYVFSEWFjMyNjcVBgYjIi4CJy4CNTQ2NzMGBhUUFjMzPgIXIgYHITQmJgMdjsdq/QoEtah0m1ZTpG52v4lMBFd4PRALiAcNODcVEoTLeISfDQJGO3sEWnzelGfLwCUlkSUiRYjJgwExYUolQBYQOiEyN5/OZIiooWOUUgAAAgA4/oAGPwXNACwANQApQBQhISgoMjIZBgYAFRMKEglyLQADcgArMisyzTMSOS8zMxEzETMvMDFBMgQSFRUhHgIzMjY2NxUGBgcRIxEmJgInIyImNTQ2NzMGBhUUFjMzPgMXIg4CByE0AgPr1QEGefvWCnfiqFudij5RxoaktfeFDC5wjBELjwcOOzsgD2Sl4otopnhGCAN1vAXNs/6/1Wes8X8XJBWbHiYC/pABdROwASTBf2opQxcQPCM0NqL5q1eYRITAffYBDwAAAgAt/ocE3ARaACkAMQAoQBMMDBMTLS0EHR0XKSAAJwsqFwdyACsyPzMzzRI5LzMzETMRMy8wMUUuAicuAjU0NjczBgYVFBYzMz4CMzIWFhUVIRYWMzI2NxUGBgcRIxMiBgchNCYmAtR9tWUEV3g9EAuIBw04NxUUg8p8jsdq/QoEtah0m1ZJkVyiRYSfDQJGO3sJE4TemQExYUolQBYQOiEyN5vOaHzelGfLwCUlkSIfAv6XBUuooWOUUv//AMgAAAFyBbYGBgAsAAD//wAEAAAGtQd6BiYBrwAAAQcCMwEXAW8ACrMWAQJyACvOMDH//wAEAAAF2gYLBiYBzwAAAQcCMwClAAAACrMWCwZyACvOMDEAAQDI/gAFEwW2ACsAKUAUKicnBCIfHwEEBA4rJQJyJAhyFQ4ALzMrKzIROS8zMxEzETMRMzAxQQE2MjMyHgIVFA4CIyImJzUWFjMyPgI1NC4CIyIGBxEjETMRNjY3AQTG/YQOGQ+m+KRRU5XLeFt/PT+AUVmPZTZLir91SXYqqqovaTMBvQW2/VcBWKXqk6f4pFEYGZgZGEKAvnx8uXo9Eg39nwW2/S44fDgB5gAAAQCv/goEKARIACEAI0ASFhMTGx4eGB0ZBnIYCnILBA9yACsyKysyEjkvMzMRMzAxZRQGBiMiJic1FhYzMjY2NTQmJiMiBgcRIxEzEQEzAR4CBCh6zHpJby8ubkNWg0pbrXwlXSmlpQHhuf41memDPcP5dx4ckRgkXLqOkrhWDQv+OwRI/f0CA/4fAnDyAAEAAf6CBZoFtgAhABlADQcgAnIXEAlyAgAFCHIAKzLMKzIrMjAxZTMDIxMjESEOAwcOAiMiJic1FhYzMjY2NzY2EhI3IQTYwpbCnrL+Jg4gIiIRGk1/aCNFGhc5ID9JKxANIiYpFAMSmP3qAX4FIHD08thUi8NnDgqPCg5lnFJE0AEJAS6gAAABAA3+hwSbBEgAGgAbQA4HGQZyEwwLcgKAAAUKcgArMhrMKzIrMjAxZTMDIxMjESECAgYGIyImJzUWFjMyPgISNyED47iHqYGw/rETPVuBWBswEQ0dEC1LPDAlDQKGjf36AXkDvf79/pDpbQYGfwMDS5joATvJAAABAMj+AAUcBbYAGAAbQA0WERETGBQCchMIcgwFAC8zKysyETkvMzAxQREUAgYjIiYnNRYWMzI2NREhESMRMxEhEQUch/KfYX08PX9Kvsb8/qqqAwIFtvrW4P7fixkXlxgZ9P4CKf1PBbb9kQJvAAEAr/4MBF8ESAAYAB1ADxYRERMYFAZyEwpyDAUPcgArMisrMhE5LzMwMUERFAYGIyImJzUWFjMyNjURIREjETMRIREEX2i0ckltLCtqQHd8/Z+npwJhBEj73sDtbR4alBYkttIByf4RBEj+NAHMAAABAMj+ggXgBbYADwAhQBAMBwcJDwoCcgAFBQKACQhyACsazDMRMysyETkvMzAxZTMDIxMjESERIxEzESERMwUcxJnCn7D8/qqqAwKomP3qAX4Csf1PBbb9kQJvAAEAr/6HBRgESAAPACFAEAMODgAGAQZyBwwMCYAACnIAKxrMMxEzKzIROS8zMDFzETMRIREzETMDIxMjESERr6cCY6a5h6qBr/2dBEj+NAHM/EX9+gF5Ae/+EQAAAQCn/oIEwwW2ABcAIkAQFRISBgkJARYNAnIEAoABCAA/Gs0zKzISOS8zMxEzMDFhIxEjETMRBgYjIiY1ETMRFBYzMjY3ETMEw66ip3XSgM/dqoGSe8N4qf6CAhYBxio0v7MCRP3UeXstKgLJAAABAJr+hQQsBEgAFwAiQBAWExMHCgoCFw4GcgUDgAIKAD8azTMrMhI5LzMzETMwMUERIxEjETMRBgYjIiY1ETMRFBYzMjY3EQQsn6OcXLJ8qbmmcWxoqlcESPu4/oUCCAFeO0SwlgGW/nZnYkA3AdwAAQDI/oIHLAW2AB0AJUATDBsBAwkPCwJyEhWAEBUVAAkIcgArMjIRMxoQzCsyEhc5MDFhASMeAxURIxEzATMBMxEzAyMTIxE0PgI3IwEDS/4VCAQFAwKe/AHQCAHU+sKXxKGwAgMFAwj+DwUOJ19iWSH8VAW2+0AEwPri/eoBfgO4IltgWB/69AAAAQCu/ocF7ARIABgAI0ASFQwIAxIXFAZyGAQECwGAEgpyACsazDMzETMrMhIXOTAxZQMjEyMRNDY3IwEjASMWFhURIxEzAQEzEQXsh6qCnwUEBv6Ujf6dBgMDl98BYgFn3o39+gF5AsosWy78gQN/Llsy/TwESPyAA4D8RQD//wDIAAABcgW2BgYALAAA//8AAAAABQ0HegYmACQAAAEHAjMAPgFvAAqzFwUCcgArzjAx//8AXv/sA8sGCwYmAEQAAAEGAjPxAAAKsy0AB3IAK84wMf//AAAAAAUNB0EGJgAkAAABBwBqADQBbwAMtCgcBQJyACvOzjAx//8AXv/sA8sF0gYmAEQAAAEGAGroAAAMtD4yAAdyACvOzjAx/////gAABoEFtgYGAIgAAP//AF7/7AZ9BFwGBgCoAAD//wDIAAAD9gd6BiYAKAAAAQcCMwApAW8ACrMQAgJyACvOMDH//wBy/+wEEwYLBiYASAAAAQYCM/4AAAqzJAAHcgArzjAxAAIAeP/sBV4FzQAcACUAGUAMGCIiCR0TCXIACQNyACsyKzISOS8zMDFBIgYGBzU+AjMyBBYSFRQCBgYjIiQCNTUhLgIDMjY2NyEUFhYCoVqhjkA7haRoqwEFsFpUpvOf1v73ewQzCnfgeIvNdwr8glO5BTcXJRacFSIVasf+6qyr/uzFarUBT+hEqvGA+0p55qak6HkA//8Aav/sBAwEXAYGA3MAAP//AHj/7AVeB0EGJgLOAAABBwBqAHQBbwAMtDsvCQNyACvOzjAx//8Aav/sBAwF0gYmA3MAAAEGAGrfAAAMtDUpAAdyACvOzjAx//8ABAAABrUHQQYmAa8AAAEHAGoBDwFvAAy0JxsBAnIAK87OMDH//wAEAAAF2gXSBiYBzwAAAQcAagCcAAAADLQnGwsGcgArzs4wMf//AE//7AQ7B0EGJgGwAAABBwBq//YBbwAMtEQ4KwNyACvOzjAx//8AQ//sA4AF0gYmAdAAAAEGAGqIAAAMtEU5AAdyACvOzjAxAAEASf/sBDEFtgAdACVAEgEcHB0aAgIZGBgJHQJyEAkJcgArMisSOS8zMxEzETMRMzAxQRUBBAQVFAYEIyImJzUWFjMyNjY1NCYmIyM1ASE1A/j+BwEHASt//v/Dd9NbXuBphbJZaMeRhgHl/VIFtob+EAnLy4DGbyUrnS4zRoZfXnk7iwHemAABAB3+FAOpBEgAHgAjQBEBHR0eGwICGRkKHgZyEQoPcgArMisSOS8zETMRMxEzMDFBFQEeAhUUBgYjIiYnNRYWMzI2NjU0JiYjIzUBITUDdf4zlOeGg++jeLxDRMR2bKJaab+DcwHL/YoESHn9/Qhrx5OR3X0mIZkgNVSda3STRXQCAI0A//8AygAABU0G0AYmAbEAAAEHAUwBoAFvAAqzGAACcgArzjAx//8ArwAABGQFYQYmAdEAAAEHAUwBGgAAAAqzFRIGcgArzjAx//8AygAABU0HQQYmAbEAAAEHAGoAzQFvAAy0Kx8AAnIAK87OMDH//wCvAAAEZAXSBiYB0QAAAQYAakgAAAy0KBwSBnIAK87OMDH//wB9/+wFvAdBBiYAMgAAAQcAagDMAW8ADLQ2Kg4DcgArzs4wMf//AHL/7ARgBdIGJgBSAAABBgBqGAAADLQqNg4HcgArzs4wMf//AH3/7AW8Bc0GBgJvAAD//wBy/+wEYARcBgYCcAAA//8Aff/sBbwHJAYmAm8AAAEHAGoAzAFSAAy0OCwOA3IAK87OMDH//wBy/+wEYAXSBiYCcAAAAQYAahYAAAy0NSkLB3IAK87OMDH//wA//+wEjAckBiYBxgAAAQcAav/SAVIADLQ5LQcDcgArzs4wMf//AEH/7AOEBdIGJgHmAAABBwBq/1sAAAAMtDUpGAdyACvOzjAx//8AFv/sBPEG0AYmAbwAAAEHAUwBFwFvAAqzIBECcgArzjAx//8AAv4TBAIFYQYmAFwAAAEHAUwAggAAAAqzIAAGcgArzjAx//8AFv/sBPEHQQYmAbwAAAEHAGoARAFvAAy0MycRAnIAK87OMDH//wAC/hMEAgXSBiYAXAAAAQYAaq8AAAy0MycABnIAK87OMDH//wAW/+wE8QeQBiYBvAAAAQcBUgFJAW8ADLQlMhECcgArzs4wMf//AAL+EwQCBiEGJgBcAAABBwFSALUAAAAMtCUyAAZyACvOzjAx//8ApwAABMMHQQYmAcAAAAEHAGoAYgFvAAy0KR0JAnIAK87OMDH//wCaAAAELAXSBiYB4AAAAQYAag4AAAy0KR0TBnIAK87OMDEAAQDI/oIECgW2AAkAFUAKAgkCcgWAAwgIcgArMhrMKzIwMUEVIREzESMRIxEECv1oqqGzBbaY+3r96gF+BbYAAAEAr/6HA0YESAAJABVACgIJBnIFgAMICnIAKzIazCsyMDFBFSERMxEjESMRA0b+EJ+loQRIi/zO/fwBeQRIAP//AMgAAAX6B0EGJgHEAAABBwBqARgBbwAMtC8jAQJyACvOzjAx//8ArwAABXYF0gYmAeQAAAEHAGoAvQAAAAy0LyMBBnIAK87OMDH//wAu/nEECgW2BiYCiAAAAAcDbACSAAAAAQAQ/nEDSgRIAB8AIkAQEQ4OFhkZDRUSBnIHABoNCgA/M8wyKzISOS8zMxEzMDFBIiYnNRYWMzI2NjU1IxEjNTMRIRUhESEVIREzERQGBgEFJT4UETUfHywXp56eApz+CgFb/qWXMmb+cREHiwcMFzElkgHigQHljf6ogf6f/vZUdT0AAQAG/nEE0AW2AB0AJEATFBcRDgQPFRICcgcADRgNDQ8IcgArMhEzEMwyKzIRFzkwMUEiJic1FhYzMjY2NTUjAQEjAQEzAQEzAQEzERQGBgPsJj4TETQfHysXY/51/m+1Aef+O70BbQFvtP48AYaZMWX+cREHiwcMFzElkgKE/XwC+gK8/bkCR/1H/Zv+31R1PQABACf+cQQ7BEgAHQAjQBIOERcUBA8VEgZyBwANGA0NDwoAPzMRMxDMMisyEhc5MDFBIiYnNRYWMzI2NjU1IwEBIwEBMwEBMwEBMxEUBgYDVSU+FBE1Hx8sF1r+zf7LvAGN/oW+ASEBILz+hQEykDJl/nERB4sHDBcxJZIBv/5BAjECF/5aAab96f5Q/vZUdT0AAAEABQAABJgFtgARACFAEAQAAA0JERECDA4IcgUCAnIAKzIrMhE5LzMzMxEzMDFTIQEzAQEzASEVIQEjAQEjASGBATP+dL0BbQFutf5xATn+vgG7wf51/m+2Abz+wANOAmj9twJJ/ZiW/UgChP18ArgAAAEAJwAABAkESAARACVAEgcBAQoEAg0REQIMDgpyBQIGcgArMisyETkvORI5MzMRMzAxUyEBMwEBMwEhFSEBIwEBIwEhdgEO/rW+ASEBILz+swET/ukBZr7+zf7LvAFi/u0CdQHT/loBpv4tgf4MAb/+QQH0AAACAH4AAAQuBbYACwAVABdACw4ICAAJAnIMAAhyACsyKxI5LzMwMWEgJjU0NjYzMxEzESUzESMiBgYVFBYCkv7i9mvxx+Oq/oHV1oOrU7TRwnnHeAJr+kqSAiVAfFuOgP//AHL/7AQ1BhQGBgBHAAAAAgB9/+wGbQW2AB4AKwAjQBIfHQgdCB0THgJyKBMLcgQNC3IAKzIrMisSOTkvLxEzMDFBERQWMzI2NREzERQGIyImJwYGIyImJjU0PgIzMxERIyIGBhUUFhYzMjY1BAB4bmd4qMXCfZ8sMaaElMpoQYvamZqbhLJZQIBfj3wFtvu3fHJ8dwHe/hmo1VtRTF9fu4pjoXU+Am78/DuAaFp5PYtfAAACAHD/7AaEBhQAJgAzACtAFyYAciEnJx0ICBcdB3ITLS0XC3IEDwtyACsyKzIRMysSOS8RMxEzKzAxQREUFjMyNjURMxEUDgIjIiYmJw4CIyICERASMzIWFhczJiY1EQEiBhUUFjMyNjc1NCYEGV6Gc2yoM2KRXmaASxknZpFnzfTzxVV9WR4NBAf+zpSRj5epiQKFBhT7g4iZhooBNv66Y5RhMDJbPTlcNwEbARcBGwEjLk0xH2sjAbf9vODU09PGxSDR3gABAEz/7AZ7BcsANQAjQBEHCCYmJRUlFQARGglyLgADcgArMisyEjk5Ly8zEjk5MDFBMhYWFRQGBxUeAhceAzMyNjURMxEUBiMiLgInNC4CIyM1MzI2NjU0JiMiBgcnPgICH5TMa7eOcZxSAQEbN1k+d2+m0Lxclmw6AThsnmbJxIWyWp9/ebROVTeQqwXLXaNql68ZCBFbkmVKakMffYgByv4mxsQvY5xtT3BHIYpFflRzfEg1cipFKQABAE//7AXDBFwAMwAlQBIHCCYmJRQlFCUAEBsLci0AB3IAKzIrMhE5OS8vETMSOTkwMUEyFhYVFAYHFR4CFx4CMzI2NREzERQOAiMiLgInLgIjIzUzMjY1NCYjIgYHJzY2AbV2sWJpWUNjOwUEL2BPbm2kL1+PYF6PYTQFBUGAZJB3hZx7c0+MTjdRqARcQ4BcY3YaCA0/ZEhBXjOFiAE3/rljlGIwKlN7UURWKYhQX1JRJSKFJiYAAQBM/oIE1AXLACgAIEAPCAcaGhcXAA8MEQghAANyACsyPzPOEjkvMxI5OTAxQTIWFhUUBgcVFhYVETMRIxEjETQuAiMjNTMyNjY1NCYjIgYHJz4CAi6X0W6+lbG/s6K1PXerbs3TjLxepod/vVJVOJOxBctdo2qXrRoHGrOT/vz96gF+AZxHaEMgikV+VHF+STRyKkUpAAABAE/+hwQaBFoAJgAgQA8HCBkZFxcAEA0SCiAAB3IAKzI/M84SOS8zEjk5MDFBMhYWFRQGBxUeAhUVMxEjESMRNCYmIyM1MzI2NTQmIyIGByc2NgHCebNjbFxCaz+lo6FEimqXfI6og3RUmEo9Vb0EWkOBXWJzGgoSQmxSo/38AXkBMEJYLIpPXlFUJyKFJiYAAAH////pBx4FtgAuAB1ADwgIDRMuAnIlHglyBA0JcgArMisyKzISOS8wMUERFBYzMjY1ETMRFAYjIiYmNREhDgUHDgIjIiYnNRYWMzI2Njc2NhISNwSzb3NwcqfTtnSzZf5JCRQVFhcXCxtNf2cjRB0ZNyA/SSoRDiInKRQFtvvKh3h/hgHK/ibGxE+ujwOmSp+joJeHOYrCZg4KjwwOY55WR9ABBgEroQAAAQAN/+wGLARIACgAHUAPBwcOFScGciEaC3IDDgtyACsyKzIrMhI5LzAxQRQWMzI2NREzERQOAiMiLgI1ESECAgYGIyImJzUWFjMyPgISNyED0ml1a2qnMGCNXV6RZDT+whM9W4FYGzARDR0QLUs8MCUNAnUBfoWBhYcBOP66Y5RiMTBilWUCRf79/pDpbQYGfwMDS5joATvJAAEAyP/sB1sFtgAaACVAFBoCchgTCBMIExUWAnIVCHIEDQlyACsyKysSOTkvLxEzKzAxQREUFjMyNjURMxEUBiMiJiY1ESERIxEzESERBPNwcnFvptC2dLJk/SeqqgLZBbb7zId6fYgByv4mxsRPr5ABN/1PBbb9kQJvAAABAK//7AahBEgAHQAlQBQBGgwaDBocHQZyHApyCBMLcgMGcgArKzIrKxI5OS8vETMwMUERIREzERQWMzI2NREzERQOAiMiLgI1NSERIxEBVgJLpmt2aG2kL1+NXl2SZDT9tacESP40Acz9OIeBhogBNv66Y5RiMTFilWR3/hEESAAAAQB9/+wFmQXLACMAGUAMIwAABxYPA3IeBwlyACsyKzISOS8zMDFBIRUUDgIjIiQCNTQSJDMyFhcHJiYjIgYCFRQSFjMyNjY1IQNfAjpHluqj2/7Mo6wBT/J451xBUNFptPiAdOWroL9W/ngC8lmj/7BbtgFR6eABUr0wKpIkM5T+8rm3/vGWedeNAAABAHL/7AStBFwAIgAZQAwiAAAHFg8Hch0HC3IAKzIrMhI5LzMwMUEhFRQOAiMiJiY1NBIkMzIWFwcmJiMiBgYVFBYzMjY2NSECrgH/Pn/ChLn+gYsBD8V5v1A5QaxljsBiv816mUj+qQJCRn/Fh0WI/q+uAQGMLCeDHjBpwojC60+RYwABABD/7ATvBbYAFgAdQA4CFRUWCgoPFgJyBg8JcgArMisSOS8RMxEzMDFBFSERFBYzMjY1ETMRFAYjIiYmNREhNQRI/jJ1c3F1p9a3dbZn/kAFtpn8Y4d6focBzP4mxsRPro8DpZkAAAEAKf/sBIwESAAZAB1ADgIYGBkKChEZBnIGEQtyACsyKxI5LxEzETMwMUEVIREUFjMyNjURMxEUDgIjIi4CNREhNQOL/qFtdWtupTFhjl5ckmU1/qMESIn9wYeBfooBPP66Y5RiMTBilWUCR4kAAQBu/+wEWQXLAC8AH0APKCcPDxISABggCXIIAANyACsyKzIROS8zEjk5MDFBMhYWFwcmJiMiBhUUFhYzMxUjIgYVFBYzMjY2NxUGBiMiJiY1NDY3NS4CNTQ2NgKHZqaKPFtTsn2Nplu4itDO1/LKuFOZizxZ2oa2+X7KtGaXU3PbBcskPyl6NUB7dVR4QY2Kj4+MFyocnignZruAmL4XBxBXj2Nspl///wBZ/+wDjARcBgYBgQAAAAEAAf5xBXAFtgAvABxADg8oAnIfGAlyBwCAKg0IAD8zGswyKzIrMjAxQSImJzUWFjMyNjY1NSMRIQ4DBw4CIyImJzUWFjMyNjY3NjYSEjchETMRFAYGBIslPhMRNB8fKxes/iYOICIiERpNf2gjRRoXOSA/SSsQDSImKRQDEpgxZv5xEQeLBwwXMSWSBSBw9PLYVIvDZw4KjwoOZZxSRNABCQEuoPri/t9UdT0AAAEADf5xBHwESAAoABxADg8hBnIbFAtyBwCAIw0KAD8zGswyKzIrMjAxQSImJzUWFjMyNjY1NSMRIQICBgYjIiYnNRYWMzI+AhI3IREzERQGBgOYJT4UETQfHywXq/6zFD1bgVkbMBENHRAtSz0wJQ4ChpcxZf5xEQeLBwwXMSWSA73+/f6P6W0GB34EBEuY6QE9yfw5/vZUdT0A//8AAP6hBQ0FvAYmACQAAAAHBA4E7wAA//8AXv6hA8sEWgYmAEQAAAAHBA4EmgAA//8AAAAABQ0H4wYmACQAAAEHAlgE+QFSAAqzGAUCcgArzjAx//8AXv/sA8sGkQYmAEQAAAEHAlgEnwAAAAqzLgAHcgArzjAx//8AAAAABQ0H0QYmACQAAAEHA2ME4wFSAA23AwIbBQEBb1YAKzQ0AP//AF7/7AQ+Bn8GJgBEAAABBwNjBJEAAAANtwMCMQABAX9WACs0NAD//wAAAAAFDQfRBiYAJAAAAQcDZATeAVIADbcDAh8FAQFvVgArNDQA//8ALf/sA8sGfwYmAEQAAAEHA2QEkQAAAA23AwI1AAEBf1YAKzQ0AP//AAAAAAUNCEkGJgAkAAABBwNlBNsBUgANtwMCIAUBAW9WACs0NAD//wBe/+wEGQb3BiYARAAAAQcDZQSYAAAADbcDAjYAAQF/VgArNDQA//8AAAAABQ0IYgYmACQAAAEHA2YE4wFSAA23AwIZBQEBb1YAKzQ0AP//AF7/7APLBxAGJgBEAAABBwNmBJAAAAANtwMCLwABAX9WACs0NAD//wAA/qEFDQePBiYAJAAAACcEDgTvAAABBwFKAOcBbwAKsysFAnIAK84wMf//AF7+oQPLBiAGJgBEAAAAJwFKAJoAAAEHBA4EjwAAAAqzNgAHcgArzjAx//8AAAAABQ0IFAYmACQAAAEHA2cE6wFSAA23AwIWBQEBb1YAKzQ0AP//AF7/7APLBsIGJgBEAAABBwNnBJsAAAANtwMCLAABAX9WACs0NAD//wAAAAAFDQgUBiYAJAAAAQcDaATqAVIADbcDAhYFAQFvVgArNDQA//8AXv/sA8sGwgYmAEQAAAEHA2gEmQAAAA23AwIsAAEBf1YAKzQ0AP//AAAAAAUNCFgGJgAkAAABBwNpBOoBUgANtwMCFgUBAW9WACs0NAD//wBe/+wDywcGBiYARAAAAQcDaQSgAAAADbcDAiwAAQF/VgArNDQA//8AAAAABQ0IXAYmACQAAAEHA2oE5AFSAA23AwIWBQEBb1YAKzQ0AP//AF7/7APLBwoGJgBEAAABBwNqBJkAAAANtwMCLAABAX9WACs0NAD//wAA/qEFDQdWBiYAJAAAACcBTQEEAW8BBwQOBO8AAAAKsxcFAnIAK84wMf//AF7+oQPLBecGJgBEAAAAJwFNALcAAAEHBA4EewAAAAqzLQAHcgArzjAx//8AyP6hA/YFtgYmACgAAAAHBA4ExQAA//8Acv6hBBMEXAYmAEgAAAAHBA4ExgAA//8AyAAAA/YH4wYmACgAAAEHAlgEywFSAAqzEQICcgArzjAx//8Acv/sBBMGkQYmAEgAAAEHAlgExAAAAAqzJQAHcgArzjAx//8AyAAAA/YHTAYmACgAAAEHAVEApgFvAAqzDAICcgArzjAx//8Acv/sBBMF3QYmAEgAAAEGAVF7AAAKsyAAB3IAK84wMf//AMgAAARqB9EGJgAoAAABBwNjBL0BUgAMtCgUAgJyACvOzjAx//8Acv/sBFgGfwYmAEgAAAEHA2MEqwAAAAy0PCgAB3IAK87OMDH//wBcAAAD9gfRBiYAKAAAAQcDZATAAVIADbcCARgCAQF1VgArNDQA//8ASf/sBBMGfwYmAEgAAAEHA2QErQAAAA23AwIsAAEBfVYAKzQ0AP//AMgAAAQ9CEkGJgAoAAABBwNlBLwBUgANtwIBGQIBAXVWACs0NAD//wBy/+wEJAb3BiYASAAAAQcDZQSjAAAADbcDAi0AAQF9VgArNDQA//8AyAAAA/YIYgYmACgAAAEHA2YEuQFSAA23AgESAgEBdVYAKzQ0AP//AHL/7AQTBxAGJgBIAAABBwNmBKUAAAANtwMCJgABAX1WACs0NAD//wDI/qED9gePBiYAKAAAACcEDgTFAAABBwFKANMBbwAKsyUCAnIAK84wMf//AHL+oQQTBiAGJgBIAAAAJwFKAKgAAAEHBA4ExgAAAAqzLQAHcgArzjAx//8AjgAAAfwH4wYmACwAAAEHAlgDiQFSAAqzCQECcgArzjAx//8AdwAAAeUGkQYmA68AAAEHAlgDcgAAAAqzCQIGcgArzjAx//8AuP6hAYEFtgYmACwAAAAHBA4DfgAA//8AoP6hAWkF4gYmAEwAAAAHBA4DZgAA//8Aff6hBbwFzQYmADIAAAAHBA4FgAAA//8Acv6hBGAEXAYmAFIAAAAHBA4ExQAA//8Aff/sBbwH4wYmADIAAAEHAlgFiQFSAAqzJg4DcgArzjAx//8Acv/sBGAGkQYmAFIAAAEHAlgE0wAAAAqzJg4HcgArzjAx//8Aff/sBbwH0QYmADIAAAEHA2MFegFSAAy0PSkOA3IAK87OMDH//wBy/+wEcQZ/BiYAUgAAAQcDYwTEAAAADLQ9KQ4HcgArzs4wMf//AH3/7AW8B9EGJgAyAAABBwNkBXoBUgANtwMCLQ4BAV5WACs0NAD//wBg/+wEYAZ/BiYAUgAAAQcDZATEAAAADbcDAi0OAQF9VgArNDQA//8Aff/sBbwISQYmADIAAAEHA2UFeAFSAA23AwIuDgEBXlYAKzQ0AP//AHL/7ARgBvcGJgBSAAABBwNlBMQAAAANtwMCLg4BAX1WACs0NAD//wB9/+wFvAhiBiYAMgAAAQcDZgV3AVIADbcDAicOAQFeVgArNDQA//8Acv/sBGAHEAYmAFIAAAEHA2YEwgAAAA23AwInDgEBfVYAKzQ0AP//AH3+oQW8B48GJgAyAAAAJwQOBYAAAAEHAUoBfwFvAAqzOg4DcgArzjAx//8Acv6hBGAGIAYmAFIAAAAnBA4ExQAAAQcBSgDKAAAACrM6DgdyACvOMDH//wB9/+wGYgeQBiYCVAAAAQcAdgJYAW8ACrMzDgNyACvOMDH//wBy/+wFGAYhBiYCVQAAAQcAdgGkAAAACrMxCwdyACvOMDH//wB9/+wGYgeQBiYCVAAAAQcAQwHCAW8ACrMyDgNyACvOMDH//wBy/+wFGAYhBiYCVQAAAQcAQwEMAAAACrMwCwdyACvOMDH//wB9/+wGYgfjBiYCVAAAAQcCWAWKAVIACrMxDgNyACvOMDH//wBy/+wFGAaRBiYCVQAAAQcCWATTAAAACrMvCwdyACvOMDH//wB9/+wGYgdMBiYCVAAAAQcBUQFSAW8ACrM9DgNyACvOMDH//wBy/+wFGAXdBiYCVQAAAQcBUQCeAAAACrM7CwdyACvOMDH//wB9/qEGYgYUBiYCVAAAAAcEDgV6AAD//wBy/qEFGATwBiYCVQAAAAcEDgTHAAD//wC5/qEFGgW2BiYAOAAAAAcEDgVIAAD//wCj/qEEOARIBiYAWAAAAAcEDgS4AAD//wC5/+wFGgfjBiYAOAAAAQcCWAVPAVIACrMZCQJyACvOMDH//wCj/+wEOAaRBiYAWAAAAQcCWATTAAAACrMdDQZyACvOMDH//wC5/+wGeAeQBiYCVgAAAQcAdgImAW8ACrMnFQJyACvOMDH//wCj/+wFjwYhBiYCVwAAAQcAdgGvAAAACrMqEwZyACvOMDH//wC5/+wGeAeQBiYCVgAAAQcAQwGPAW8ACrMmFQJyACvOMDH//wCj/+wFjwYhBiYCVwAAAQcAQwEYAAAACrMpEwZyACvOMDH//wC5/+wGeAfjBiYCVgAAAQcCWAVZAVIACrMlFQJyACvOMDH//wCj/+wFjwaRBiYCVwAAAQcCWATYAAAACrMoEwZyACvOMDH//wC5/+wGeAdMBiYCVgAAAQcBUQEgAW8ACrMxFQJyACvOMDH//wCj/+wFjwXdBiYCVwAAAQcBUQCoAAAACrM0EwZyACvOMDH//wC5/qEGeAYUBiYCVgAAAAcEDgVRAAD//wCj/qEFjwTyBiYCVwAAAAcEDgS3AAD//wAA/qEEeQW2BiYAPAAAAAcEDgSbAAD//wAC/hMEAgRIBiYAXAAAAAcEDgVk/+L//wAAAAAEeQfjBiYAPAAAAQcCWASnAVIACrMOBwJyACvOMDH//wAC/hMEAgaRBiYAXAAAAQcCWARkAAAACrMjAAZyACvOMDH//wAAAAAEeQdMBiYAPAAAAQcBUQBxAW8ACrMaBwJyACvOMDH//wAC/hMEAgXdBiYAXAAAAQYBUTUAAAqzLwAGcgArzjAx//8Acv7NBNAGFAYmANMAAAEHAEIA8AAAAAqzLwALcgArzjAxAAL8cATZ/60GfwASABwAI0ARGBMWgBxABAkSAw2AAQ8HAQcAL10zGs0XORrcGsw5OTAxQSMmJicGBgcjNT4CNzMeAhcnNjY3MxUGBgcj/tNeM20zNWszXyNOTB+sH0tOI08pOSCnK2k1YATZI1YxMVYjGCZWXC0tXFYmwjJaQBU6aSsAAAL7nATZ/tkGfwASABwAI0AQFhiAGxNADwEKAwUAgAwMAAAvMi8aEMwXORreMhrNMjAxQTU+AjczHgIXFSMmJicGBgcnJiYnNTMWFhcV/HQiTk0friBLTSNgNGo1NGw0ajlnLKUgOigE2RYmVlwtLVxWJhYjVjExViPDK2k6FUBbMxUAAAL8cATZ/4EG9wASACgALUAUJSIiHBkmE8AbQAkSBoAEDg4MDAYALzMvMxEzGhDNORrcGswyOTkyETMwMUEeAhcVIyYmJwYGByM1PgI3ATIWFRQGBwcjJzY2NTQmIyIGBzU2Nv34H0tOI14zbTM1azNfI05MHwF2W2RLNgZPCTw/Ny4WJw0OKgX2LVxWJhgjVjExViMYJlZcLQEBRUc6PAxRgQkgJSQcBANPBAQAAAL8aQTZ/ucHEAASACsAJUAQKyscIxcoHx8XCRIMgAYGDAAvMy8aEN05xjIvMhDNMjIvMDFBHgIXFSMmJicGBgcjNT4CNwEOAiMiLgIjIgYHIzY2MzIeAjMyNjf9+iBMTiNcNWs1NG8zXCJPTR8BlgYvTzYlRkI/HSktDVgLYFAmSEM+HCksDAXzLVxVJhYjVDExVCMWJlVcLQEdQGM3HiceMTVffB4oHjI0AAAC/HUE2f7IBsIADQAYAB1ACw8YFRQUDQ0HgAoDAC8zGswyLzJ8LzMYzDIwMUEGBiMiJiczFhYzMjY3NxUOAgcjNTY2N/7IC5WMj5AIZghjWE9rCiEdQkckXSc8HgXheo6LfVU1OVHhFSZLQhwWMlxAAAAC/HUE2f7IBsIADQAYABtAChcOERMTDQeACgMALzMazDIyfC8zGM0yMDFBBgYjIiYnMxYWMzI2NyUWFhcVIy4CJzX+yAuUjY+PCWYIY1hQagr+8h85KFsjSEIdBeF6jot9VTU4UuFAXDIWHEJLJhUAAvx1BNn+yAcGAA0AIwAfQAwXFB0OFhYKCg0HgAMALxrMMjMRM3wvGMwyOTkwMUEGBiMiJiczFhYzMjY3AzIWFRQGBwcjJzY2NTQmIyIGBzU2Nv7IC5SNj48JZghjWFBqCu1bYUo1Bk8JOz43LBcoDQ8rBeF6jot9VTU4UgElREc6OwstXgkgJCMcBQJMBQQAAvxnBNn+5gcKAA0AJgAfQA0mFx6AIxoSQA0HgAoDAC8zGtwyGt4yMhrNMjIwMUEGBiMiJiczFhYzMjY3Ew4CIyIuAiMiBgcjNjYzMh4CMzI2N/7IC5SNj48JZghjWFBqCoQGL082JUdCPx0pLA5YC2BRJkhDPhwpLAsF3nmMiXxUMzVSASw/YTceKB4xNV94HiceMjMAAQAw/j4BbgADABMADLMRCgoEAC8zLzMwMVc0Jic3FhYVFAYjIiYnNRYWMzI25ExEdTxpaGEfPBoQMBknNPE6d0ADLIFWW2cKB2sFBjIAAQAd/nEBeQCYABMADrQHAMANDgAvMxrMMjAxUyImJzUWFjMyNjY1NSM1MxEUBgaTJT4TETUfHysXGK4yZf5xEQeLBwwXMSWSmP7fVHU9AP//ABL+FARTBbYGJgA3AAAABwB6AVEAAP//ACD+FAKrBUYGJgBXAAAABwB6AM8AAP//AH3+PgW8Bc0GJgAyAAAABwFQAjIAAP//AHL+PgRgBFwGJgBSAAAABwFQAYYAAP//AH3+PgW8BtAGJgAyAAAAJwFMAZ8BbwEHAVACTgAAAAqzIw4DcgArzjAx//8Acv4+BGAFYQYmAFIAAAAnAUwA6gAAAQcBUAGGAAAACrMjDgdyACvOMDEAAgBq/+wEDARcABcAHwAZQAwNGRkAHQgLchEAB3IAKzIrMhI5LzMwMUEyFhYVFAIGIyImJjU1ISYmIyIGBzU2NgEhHgIzMjYCAJ7sgnfZk4zJagL2BLmqZ6BXU6QByv29ATp5XoaeBFyB+rWx/v6NfOCUZ8DLJSaTJCL9YWGVU64A///9BQS4/nMGkQYGAlgAAP//AAH/7Ab4Bc0EJwAyATwAAAEHA3b+kf+aABC1AwIyDgIAuP/8sFYAKzQ0AAIBcATOA4wGLwAKABwAHUAMHAsLABkREQYEgAEAAC8yGswyMi8zETMvMzAxQTU2NjczFQ4CBwcmJjU0NjMyFhUUDgIjFBYXAnkXNg+3FD9KJoBwaTcvKzoQHCYWNUEE3xk8pEUVKmZpMBEMdmg1Qi0xGCIXCyI4BgAAAgApA0QCngbSAAsAFwAOtQwAeBIGdwA/M+QyMDFBIiY1NDYzMhYVFAYnMjY1NCYjIgYVFBYBYp2clqOdn5amXFZWXFpVVANE6d/b6+je2u54pauqpaWsqaUAAgApA0QCoQbRAB4ALAAZQAsfDAsPDycWeAcAdwA/MuQyOS8zMzMwMUEyFhcVJiYjIgYGBzM2NjMyFhUUBgYjIiYmNTQ+AhMiBgYVFBYWMzI2NTQmAd4fRhgXRyZvgToGCB1xVXmWS4pdXZNWJ2GqFztZMStWPlBjWAbRCAZyCAtWk1wsPI+DXolKVa6DZ7uRVP5NLEUnNWI+YWBQXAACACMDRAKcBtUAHQArABtADBQVJCQYGBAJeB4AdwA/MuQyOS8zETMzMDFBMhYWFRQOAiMiJic1FhYzMjY2NyMGBiMiJjU0NhciBhUUFjMyNjY1NCYmAVVclFcnX6iCI0gXFkIxcH45BQocalOCl6eLTGRUWDpZMipVBtVTq4ZnvZRVCAZ0CQxbllgoQZKFhahuXlxRYStFJz1gOP///9r/7AKTB40GJgGFAAABBwOI/28AAAASQAoEAwIBIRABAY1WACs0NDQ0////2v/sApMHjQYmAYUAAAEHA4f/bwAAABJACgQDAgEbEAEBjVYAKzQ0NDT////M/+wCkweNBiYBhQAAAQcDhv9tAAAAEkAKBAMCASUQAQGNVgArNDQ0NP///87/7AKTB40GJgGFAAABBwOF/28AAAASQAoEAwIBHxABAY1WACs0NDQ0//8Ao//sBG8HjQYmAZEAAAEHA4gA3AAAABJACgQDAgEoBQEBjVYAKzQ0NDT//wCj/+wEbweNBiYBkQAAAQcDhwDcAAAAEkAKBAMCASIFAQGNVgArNDQ0NP//AKP/7ARvB40GJgGRAAABBwOGANsAAAASQAoEAwIBLAUBAY1WACs0NDQ0//8Ao//sBG8HjQYmAZEAAAEHA4UA3AAAABJACgQDAgEmBQEBZFYAKzQ0NDQAAQDH/nsFAQXLACYAHEAOGRgPDx0DchYCchQIBwAALzI/KysyETMzMDFBIiYnNRYWMzI2NjURNCYjIgYGFREjETMXMz4CMzIWFhURFA4CA4M0TRwgTy42YT2kuZOsSqqGHQklf59UmuF8N2aM/nsODZAJDClkWAPRxatuyon8igW2yUFkOWvbqvwlY5NgLwD//wDI/n8FPwW2BgYBCwAAAAEAuv/sBPQFywAoACNAEgYXFwAcGxISIANyGQJyCwAJcgArMisrMhEzMxE5L84wMUUiJiY1NTMVFBYWMzI2NRE0JiMiBgYVFSMRMxczPgIzMhYWFREUBgYC0K3ue6pUp3rDrqS5k6xKqocbCyV+n1WZ4Xx38hSE8aMZH3uqWdewAcDFq27KiZUC1clBZDlr26r+LJzzjAAABABfBNUCzAeNAA0AGQAlADEAJUAQIBoaDismJgcKBIAAABQUDgAvMxEzLxrMMjMyL8QRMxEzMDFBIiYnMxYWMzI2NzMGBgUiJjU0NjMyFhUUBiEiJjU0NjMyFhUUBgE1PgI3MxUOAgcBkIyWD2oOZVhNbRBuEKL+vSY0NCYmNjYBVyU0NCUmNTX+uhotKRSnHERIJQXHi3BEMDY+cIvyMTEzLi4zMTExMTMuLjMxMQHVFyE+RCkUJUpEHAAEAF8E1QLMB40ADQAZACUAMQArQBMaICAUMCZAKiwsDQeACgMDDg4UAC8zETMvMxrMMjIvMxrNMhEzETMwMUEGBiMiJiczFhYzMjY3ATIWFRQGIyImNTQ2ITIWFRQGIyImNTQ2Ax4CFxUjLgInNQLMEKKKjJYPag5lWE1tEP55JjY2JiY0NAGjJjU1JiU0NMkUKS0aXiRJQx0GwnCLi3BEMDY+/tYuMzExMTEzLi4zMTExMTMuAfUpRD4hFxxESiUUAAQAawTVAsEHjQADAA8AGwAnAB9ADRAWFgonIQMDAgIEBAoALzMRMy8zEN7NETMRMzAxQRUhNRcyFhUUBiMiJjU0NiEyFhUUBiMiJjU0NhMVDgIHIzU+AjcCwf2qbCY2NiYmNDQBoyY1NSYlNDQwHERIJV4aLSkUBmeIiM8uMzExMTEzLi4zMTExMTMuAfUUJUpEHBchPkQpAAAEAGsE1QLBB40ACwAPABsAJwAfQA0iHBwQBgANDQwMFhYQAC8zETMvMxDezREzETMwMUEuAic1Mx4CFxUFNSEVASImNTQ2MzIWFRQGISImNTQ2MzIWFRQGAY0kSUMdpxQpLRr+gAJW/hYmNDQmJjY2AVclNDQlJjU1BqocREolFClEPiEXy4iI/vYxMTMuLjMxMTExMy4uMzExAAABALUE3gPnBaQADQAdQAwBDAwFCQkNgAMHBwsALzMRMxrNMhEzMhEzMDFBFQcjJyMHIycjByMnNQPnTCAuwy4hLsAuIEoFpCCmZmZmZqYg//8AHgAABb8GHwQmAEkAAAAHAEkCsQAA//8AHgAABBkGHwQmAEkAAAAHAEwCsQAA//8AHgAABAcGHwQmAEkAAAAHAE8CsQAA//8AHgAABsoGHwQmAEkAAAAnAEkCsQAAAAcATAViAAD//wAeAAAGuAYfBCYASQAAACcASQKxAAAABwBPBWIAAAABALr/7QVXBcsAKwAmQBMnCBwFBR0EABoaABQNCXIhAANyACsyKzIROS8SOTkzETM/MDFBMhYWFwEeAhUUBgYjIiYnNRYWMzI2NTQmIyM1AS4CIyIGBhURIxE0NjYC24bAfCD+2oHLdGrfsGu6Tk/CW7CftrN2AT4YUXhTfaNPqHjyBctRkmT+xQNkuIOByHEjKZwrMaCPiYx9AVM1SylhrXP8SwO2mfGLAAH/5v4UBQ8FzQAmAB5AEA0UFBkIHAUEGgYCciAAA3IAKzIrLxc5My8zMDFTMhYWFxMBMwEBHgIzMjY3FQYGIyImJicDASMBAyYmIyIGBzU2NsRFVTwe3AF8tv4ZASIkMzYlETEaHkomUWBJMNr+ILcCSf0jNzYTMR8dPwXNLmJO/ekC3vxr/UpTWSEGBn4LDUSSdQIV/KMEEwJlWFwIC38LEwAAAwDD/hQEqgW2ABQAHQAnACBADwgJFRUeHgAfExIIHQACcgArMj/NMxI5LzMSOTkwMVMhIBYVFAYGBxUeAhUUBgYjIREjEyEyNjU0JiMjEREhMjY1NCYmI8MBqwEZ/0R+WGeOSYTsnv7RqqoBFLSitrf9ASizsFKlfwW2uLZXhVYQCBBUjWiOu1z+FAUsfnx+dv2K/dOUj1h2PAD//wDI/hQD+wW2BiYALwAAAQcAegGZAAAAC7YBFwABAABWACs0AP//AMj+FAU/BbYGJgAxAAABBwB6AjAAAAALtgElAQEAAFYAKzQA//8AAP4+BQ0FvAYmACQAAAAHAVABlwAA//8AyP4+A/YFtgYmACgAAAAHAVABawAA//8AWP4+AaMFtgYmACwAAAEGAVAGAAALtgEVAAAAHlYAKzQA//8Auf4+BRoFtgYmADgAAAAHAVAB7wAAAAEAVwAAAlEFtgALAChAEwkEBAgIBQUGAnIKAwMLCwICAQgAPzMRMxEzETMrMhEzETMRMzAxYSE1NxEnNSEVBxEXAlH+BqioAfqoqGMjBKglY2Ml+1gjAAABADj/6QKKBbYAEQAOtgwCcgcACXIAKzIrMDFFIiYnNRYWMzI2NjURMxEUBgYBFkduKTFtOzleOKpbphcdF5AUGi1rXQRC+8qKtFn//wBMAAACUQeQBiYDmAAAAQcAQ//6AW8ACrMSBgJyACvOMDH//wBXAAACdweQBiYDmAAAAQcAdgCQAW8ACrMTBgJyACvOMDH//wAJAAACqgePBiYDmAAAAQcBSv+3AW8ACrMZBgJyACvOMDH//wA6AAACbwdBBiYDmAAAAQcAav8EAW8ADLQhFQYCcgArzs4wMf///9wAAALDB0wGJgOYAAABBwFR/4oBbwAKsx0GAnIAK84wMf//ACkAAAKABtAGJgOYAAABBwFM/9cBbwAKsw4GAnIAK84wMf//ACYAAAKUB1YGJgOYAAABBwFN/9QBbwAKsxAGAnIAK84wMf//AFf+PgJRBbYGJgOYAAAABwFQALAAAP//AFf+PgJRBbYGJgOYAAAABgFQXQD//wBXAAACUQdRBiYDmAAAAQcBTgCjAW8ACrMSBgJyACvOMDH//wBX/n8EFAW2BCYDmAAAAAcALQKqAAD//wA4/+kDhgePBiYDmQAAAQcBSgCTAW8ACrMfDAJyACvOMDH//wBXAAACUQfjBiYDmAAAAQcCWAO7AVIACrMRBgJyACvOMDH//wBX/qECUQW2BiYDmAAAAAcEDgO0AAD////+AAADQwYEBCcDmADyAAAABwFT/fb/k///AFcAAAJRBbYGBgOYAAD//wA6AAACbwdBBiYDmAAAAQcAav8EAW8ADLQhFQYCcgArzs4wMf//AFcAAAJRBbYGBgOYAAD//wA6AAACbwdBBiYDmAAAAQcAav8EAW8ADLQhFQYCcgArzs4wMf//ADj/6QKKBbYGBgOZAAD//wBXAAACUQW2BgYDmAAAAAEArwAAAVUESAADAAy1AgZyAQpyACsrMDFhIxEzAVWmpgRIAAH/kP4UAVUESAAQAA62CwZyBwAPcgArMiswMVMiJic1FhYzMjY1ETMRFAYGKzNMHB9AKERUpkCE/hQPCocKC0xkBPn7C2SPTAD//wCv/hQEpgYfBgYBfgAA////8P4UBE4EUAYGAZMAAP//AHL+FAQ1BiAGJgO6AAABBgI2ZQAACrM6AAdyACvOMDH//wBB/hQB0AYUBiYATwAAAQYAeiUAAAu2ARUBAQAAVgArNAD//wCv/hQEQQRcBiYAUQAAAQcAegGiAAAADrQBGQ4AALj+FLBWACs0AAMAXv4+A8sEWgAVADMAPgAyQBkIBwcdOzshNTQ0KSgoFiELchsSLRYHcg8AAC8yKzI/KxI5LzMzETMRMxEzMxEzMDFBIiY1NDY2NxcOAhUUFjMyNjcVBgYDMhYVESMnIw4CIyImJjU0JCU3NTQmIyIGByc2NgEHBgYVFBYzMjY1AmFoZUhtNlw9VS0zLCIwEBs5QMS+eSAILmSDX2SbWQEEAQq9em9WnEYzSsABSKfNqHJekrr+PmRaSYl0Jx44ZmU5LzEIBWwHCwYcsMH9F6I8USlGjm2ksAgIQ45yMiJ+Jjb9wgcIdmxeWqKiAP//AHL+PgQTBFwGJgBIAAAABwFQAW0AAP//ADH+PgF8BeIGJgBMAAAABgFQ3wAAAgCj/j4EOARIABUALQAkQBMtBnIjBnIIBwcaKCgPAB4LchgKAD8rzDIzETMzETMrKzAxQSImNTQ2NjcXDgIVFBYzMjY3FQYGAREjJyMOAiMiJiY1ETMRFBYzMjY2NRECk2plOV85gUBaLzMsITERHDoBf4gYCSJsh0yCsFmofH96kUD+PmRaOm9jJwsxXFkvLzEIBWwHCwYK+7iaOU4nVLCKAs79PomHXLOCAkEAAgBy/hQENQRcACIAMwAjQBMaKiodC3ISCw9yBQZyAyMjAAdyACsyETMrKzIrMhEzMDFBMhYXMzczERQGBiMiJic1FhYzMjY1NTQ2NyMGBiMiAhEQEhciBgYVFBYzMj4CNTU0JiYCNnGtOwsWhWjXqHjETU3PdpajBQEIN6111O/u7WKHRpqVV3xNJUSPBFxVVZb7oprRayQjmiguqpQwHVsWWFcBKAEMAQcBNYxmwYrQ2zBhkmExk7tZAP//AHL+FAQ1BiAGJgO6AAABBwFKAL4AAAAKs0EAB3IAK84wMf//AHL+FAQ1BecGJgO6AAABBwFNANwAAAAKszgAB3IAK84wMf//AHL+FAQ1BeIGJgO6AAABBwFOAaoAAAAKszoAB3IAK84wMQAB/+f/4QOkBh8AKwAlQBIRJycTFBQkBnIgGQFyBwYNDQAALzIQzDIrMisyETMyETMwMUUiJjU0NjcXBgYVFBYzMjY1ESM1NzU0NjYzMhYXByYmIyIGFRUhFSERFAYGAQeDnQUHjgIDRjM9RcPDUZxwP2koKyJVLF9aARD+8D17H494Fi8XIAoYDkREU2cCoFA3SYqtUhYOgwsTe4NQgv1lZ5RPAAIAcP/sBF0GHgAhAC8AGUANIhkJAwApEQtyAQABcgArMisyERc5MDFBFwYEBhUUFhYXHgIVFAYGIyImJjU0NjY3LgI1NDY2JAMOAhUUFjMyNjU0JiYEJxTS/tCjPIBnhbxjfeOakeKAW69+R3NEXcQBNdNaoWWumKGtTIoGHpIZK0RALD1CMkGVv4GZ2XNt0pl7voYlJUxjR1FxTzX9VhZepYOZtLejZ5JrAP//AFcAAAJRBbYGBgOYAAAAAQBy/zsCxALhABcAGEALBQQREQh8F30NFnsAPzPt5DIRMzMwMVMRFAYHMzY2MzIWFREjETQmIyIGFREjEd4DAwcheEmAg2tRVHdfbALh/ukZMBQzN3J+/lQBplJSfXX+qAOmAAEAcv87ArEC4QASABlADg8OBAULCAYJfBJ9DRF7AD8z7eQXOTAxUxEUBgczNjY3NzMBASMDBxUjEd0EAQQONBPsf/7iATOC/FZrAuH+GxhFGxA9E+n+5/6HATdJ7gOmAAEAcv87AN4C4QADAAqzAn0BewA/7TAxVyMRM95sbMUDpgABAHL/OwRlAdkAJgAlQBEcGxISIAkAACAgGXwFDg4YewA/MxEz7TIvMxEzETMRMzMwMUEyFhURIxE0JiMiBhURIxE0JiMiBgYVESMRMxczPgIzMhYXMzY2A3d2eGtLSWhda0tKR1YmbFcQBhVBUS5QbhkGI3sB2XJ9/lEBqlBQb2v+kAGqUFA3ak3+pAKSXSIuGTg5OTgAAAEAcv87AsQB2QAUABlACxIRCQkAAA98BQ57AD8z7TIvMxEzMzAxQTIWFREjETQmIyIGFREjETMXMzY2AcN/gmtRVHZgbFcQBiJ6Adlzf/5UAaZSUnx2/qgCkl80NwACAHL+FQLkAdkAFQAiACNAEAoJHR0GExIWFgAAEHwOBnsAP87kMi8zETMzETMRMzMwMUEyFhUUBiMiJicjFhYVESMRMxczNjYXIgYHFRQWMzI2NTQmAcGFnqCGVW0eBwEGbFkOBR9qR29fAlx1Y2NiAdmqqamuPCoXQhn+8gO4Yi1BVHd2FH2FkXR0igAAAQBD/y8CPwHZACkAGEANDQARJhUiBh8YfAoDewA/M+QyFzkwMUUUBiMiJic1FhYzMjY1NCYmJy4CNTQ2MzIWFwcmJiMiBhUUFhYXHgICP5iDS20pK3o+XVMhT0RFYzaSd0FwMSQtZDRKUCVSQ0JiNRFeYhYTXBQgNzAbKScXGDBEN1NaGBRPERguJx8oIxcWMUUAAAEAFf8vAbwCZQAXAB1ADQsUFBENDg4QEXwAB3sAPzP0zTMRMxEzETMwMUUyNjcVBgYjIiY1ESM1NzczFTMVIxEUFgFYGzcSE0MgVXdlZitB0NA9fwgGTQgLVnQBhjAnj5hO/n0+PQAAAQBxAAAEQgULACMAGEAMGgsdCAQAEgl5chwAAC8yKzISFzkwMXMRNDY2NzY2NwMzATY2NzY2NREzERQGBwYGBwEjAQYGBwYVEXENISEcW0D/uAHCDhgKOC+lGh0YXkEBArn+PCRZGBkBxj5pXi0qOg8BoP0YBQwIInBlAdj+KFWBMipJEv5aAu0CNj5Cb/46AAABAFIAAAQEBR8AHQAUQAkJEHpyGwEBAAoAPzIRMysyMDFzNSERNCYnJiYjIgYHNTY2MzIWFxYWFx4CFREzFVMCdGxpGUApL4xjSpFIZIc9PlIZEBIIlIkDDHZwDwUFBweLBwcRFhdIOBs+Rin88IkAAQAx//gCmgUfACYAF0ALHwohIBEXegcACnIAKzI/Mzk5PzAxVyImJzcWFjMyNjc2NjURNCYjIgYHNTYzMhYXFhYVESMnIwYGBwYGsxtBJhYdPSFOgCgbHjRSI04vWFhEYyEvKIcVChYwFSt1CAcGmAYHS0UudEYB0FVmCgqNEyAeKYZV/CPOJkAULDAAAAEALAAAA94FCwARABC2CwgICXlyAAAvKzIRMzAxYRE0Njc2NjchNSEVBgYHBhURAmoaExUmGv1AA7IyVBksA382WxwgJw+JexIyJj5r/IMAAgCvAAAEYQUfABsAHwAXQAscCh4eBwcRenIACgA/KzIRMy8/MDFhETQmJyYmIyIGBzU2Njc2NjMyFhcWFhcWFhURIREzEQO3aWkYSzA/zZcvWipQfzBxjT4+UhgPDfxOqAOVdXAPBQYMDYwFBgMFBRQaGlA/KFY1/GsDH/zhAAABAK8AAAFXBQsAAwALtAF5cgAKAD8rMDFzETMRr6gFC/r1AAABAD4AAAH/BQsAFgARtwsICAl5cgAKAD8rMhEzMDFzETQ2NzY2NyE1IRUOAgcGBgcGBhURtyIdGDAZ/ucBwRUlIQ0QFwcFBQLZVpk2LEIWiXwQLjYdJVkqHD8i/ScAAQCvAAAEYQUfAB0AF0ALEgocGRkBB3pyAAoAPysyMhEzPzAxcxE2Njc2NjMyFhcWFhcWFhURIxE0JicmJiMiBgcRrw04K12gQnOOPj5SGA8Nqm5tF0UtLn5QBQcCBAQHBxQZGk9AJ1c2/GsDlXhyDgMEBgb7eAAAAQCl/+wElAUfADYAFUALHiV6cgp5chIAC3IAKzIrKzIwMUUiJicmJicmJjURMxEUFhcWFjMyNjc2NjU0JicmJiMiBgc1NjYzMhYXFhYXFhYVFAYHBgYHBgYCmkaANDZZICclqTU0JXRLTnYlOygmNSp9SBQpFRw3GkZ8NDZTHCAhGBgfY0Q2gxQcHx9gRVDNggKB/X+X10AuNDcwSuN7edpKOTQFBIwFBB0gH2NFTMh9ZqtHWoIpICEAAQCiAdMBSwULAAQADrUDAAABeXIAKzIvMzAxUxEzEQeiqXkB0wM4/V+XAAABACL+FANPBR4AIAAMtAkWenIAAC8rMjAxQRE0JicmJicmIyIGBwYGBzU2Njc2NjMyFhcWFhcWFhURAqQfIhEuG09+LlImF0gVGUIpKlwyZrQ4HS4SISH+FAS8XZU6HzESNgkIBBQFkAgOBgYGRTcdQydGpl/7RAABAEb/7ANzBR4AOAAQtxglenIIAAtyACsyKzIwMUUiJic1HgIzMjY3NjY3NjY1NTQmJyYmIyIGBwYGBzU2Njc2NjMyFhcWFhceAhUVFAYHBgYHBgYBg1yaRyFlczZBZyMiMw4PFy4xLYdVO3c+EBYFIDgnKV81ZrU4HC4TFh0OGxsXQi5FphQREZkLFQ0kHRxMJyhvPrFusDs1NhERBQYBkAsMBgYFRTcdQycvaXNAsVaSPzVTHz4nAAABADYAAAOQBh0ACgAUQAkIAwMFBnlyAAoAPyvNMxEzMDFhExMhETMRIRUDAwHNX779TKgCsrtfAe4CkgGd/vOP/XT+CwAAAgCoAAAEWgUfABEAIAAPth0HenISAAoAPzIrMjAxcxE2Njc2NjMyFhcWFhcWFhURJSERNCYnJiYnJiYjIgYHqAw4Kl6gQ3WQQDpOGQ8O/PcCXyIjGkkuGEcvLn5PBQcCBAMIBxUbGUs8JFUz/F2JAx1BVxsWGQUEAwYGAAEAYwAABEgFHwA1AB9AECUkCjQTEi4uGXpyD3lyAAoAPysrMhEzMzM/MzAxcxM2NjU0JicuAicmJiczFhYXMzY2NzY2MzIWFxYWFxYWFREhNSERNCYnLgIjIgYHBgYHA2NaAgEHCAIQDwIECQSjEhgGDQ1NJyeASUNuKx4xEh4f/kcBECIiFDVFLEByIyE1EFwDwRMdDh41IgovLQcMFwwoRR4UPBQVISIeFjcgOJFY/K+JAshNdycaJxUmGRg7IfwhAAABAGT+GAFPBQsAEQAKswh5cgAALyswMVMRNCYmJyYmJzMWFhceAhURpw0YEQMGBKoECQUIFhH+GAVdQH95NgoUCgseExl1jj76owAAAQB1AAAC2QUfACIAD7YME3pyAQAKAD8yKzIwMXM1ITY2NRE0JicmJiMiBgc1NjYzMhYXFhYXFhYVERQGBgcHdQGkDAsYGBMxIChULSZZNDpWIB4tDxQVCg4HCYk3ajQCejBNGREUCQiOCAcWFBM4ICNaNf2GMnFnITMAAAIAbv/sBF4FHwAjADwAF0ALDQwxMRN6ciQAC3IAKzIrMhEzMzAxRSInJiYnJiY1NDY2NzcHNT4CMzIWFxYWFxYWFRQGBwYGBwYnMjY3PgI1NCYnJiYjIgYHBgYVFBYXFhYCZYxlSWshGBklSzgDmVyom0ZSjTk1UhwfHxMTH21MapFOdiUlKxFKPiNiNjRNKFZRMDEldRQ4J4ZgRqxldr+UNAMHjgUHBCgpI2lFSrpxWJlBapcsPY04MjCJnk692TUfIgIEWPuzlNM+MjgAAQA8/8oEdAULABkAGEANFwECBQkUBgAOBnlyAAAvKzISFzkwMVc1JTY2NwEzExM+AjcTMwMOAgcGBAcGBjwBDBw7Hf7Sppl4XpJcDTagNggrRzBT/vK3WqA2iygFDAkEdP29/gMumcx6AjP90lSYiT14nhsOFwAAAQBZ/hQEPQUfAC8AF0AKFRQWFgAHJXpyAAAvKzISOS8zMzAxQRE0JicmJiMiBgcGBhUUFhcWFhcXByciJicmJjU0Njc2Njc2NjMyFhcWFhcWFhURA5MxMCh5S0uJKSYqLy8eTC8eGxpblzMrMEA1Gk0hN3dBToY2MlEeJif+FARyldI9NTMxMituPFB2JBYeCAV9AUdANpJaXZ82GzQQGRkhIx5cPk7PgPuOAAEAbv/sBFEFHwBKABlADCgpKQAbOXpyCQALcgArMisyEjkvMzAxRSImJicnNRYWMzI2NzY2NzY2NTQmJyYmJyYmIyIGBwYGFRQWFxYWFxcHJyYmJyYmJyYmNTQ2NzY2MzIWFxYWFxYWFRQGBwYGBwYGAlY9c2IlKVqxWEpyJScvCQUEEBUVRzkfRSdNdyQwOC8oIVAvHhsaN2EpJkAXICFPQUiyYVOMOC1LGyYoLSkhWjQzexQECAUFiQoKMiosiEotVTNZjUNEYx0PECohK39DSXgmHiEBBH4CARkYFj0mMn9JbK41PTsmJR5YOE/PgozZTjtWGh4eAAABAAP+FANvBQsAFQAXQAwUEwEEBwUACwJ5cgAALysyEhc5MDFBEQEzATY2NzY2NREzERQGBwYGBwcRARP+8K8BAR46HUpVqCwrInNMe/4UBBkC3v04CBAIEo9zAZT+aF6TNCdBDh/8WwAAAQBPAAAEEAULABoAHUANCBgADAV5chkDAwEBAAAvMhEzETMrMhI5OTAxczUhFwEBMwEXNjY3EzMHDgIHBgYHBgYHARVTAml//s3+R7cBYjdQXQwZnxgEDBIMDSUWHUYpAROJAgG+Asb9t1VQy3sBCP8oSkUhKEolMFcl/nNkAAACAK/+FASDBQsAGgAeABdAChsaHBwPDAwNeXIAKzIRMzMvLy8wMWE0NDU0Njc+AjcTITUhFQMOAgcOAxUVAREzEQKoIxUFFhwNrvzdA9S0BhgZBwgWFg79YKkHDQczpVYWU2ItAkGJeP2sEFRZGhpbZloYG/4UBOj7GAAAAQAsAAADXgUfABkADLQHD3pyAAAvKzIwMWERNCYnJiYjIgYGBzU2NjMyFhcWFhcWFhURArVsaxg5ICd0eC5ZlD14jj4+UhkODQOVdnEPBQQDBwOMBgYUGhpPQChWNfxrAAABAFIAAAVeBQsAKAAdQA8dCgoVExQSAwUAAXlyFgAALzIrEhc5MxEzMDFzAzMTNjY3NjY3EzMDBgYHBgYHIgYjEyEyNjc2NxMzAwYGBwYGBwYGI79toT1DeigvLwkcnRwNPD04o3UCBAEYAReK7E1METWeNgtCNTaOYkCRTgUL/R8QOS85pF0BL/7Shr9HRFAUAf7glYeJrQIx/c1zyVdYhiohHAAAAQAo//wEaAUfAC8AFUAJHgokJBJ6cgYAAC8yKzIRMy8wMVciJic1FjMyNjURBgYHNT4CMzIWFhcWFhcWFhURIxE0JicmIyIGBxEUBgcGBwYGhhQuHCYrSEokSCRlrJA6XHxbKjpLFw0MqG5sLk4lWzYPEhosJGMECAiCBl5iAz0CBgKMCAsFChgTG04+I1Uy/GcDlXdxDwgDA/y6N1wmOiIcG///AFIAAAVeBg4GJgPiAAABBwQjBREAigAKsykBeXIAK84wMf//AEwAAAVeBgwGJgPiAAABBwQkAJIAiAAKsykBeXIAK84wMf//AFIAAAVhBg4GJgPiAAAAJwQhAx7/dwEHBCMFFQCKAAqzNAF5cgArzjAx//8AUAAABV4GDAYmA+IAAAAnBCEDHv93AQcEJACWAIgACrM0AXlyACvOMDH//wBx/yIEQgULBiYDyQAAAAcEHAJa/+X//wBx/lgEQgULBiYDyQAAAAcEHQJY/+n//wBxAAAEQgULBiYDyQAAAAcEIQHc/vr//wBSAAAEBAUfBiYDygAAAAcEIQF5AFH//wAx//gCmgUfBiYDywAAAAcEIQD6AFH//wAsAAAD3gULBiYDzAAAAAcEIQFZAFH//wCvAAAEYQUfBiYDzQAAAAcEIQJ8AFH///++AAABVwULBiYDzgAAAAYEIf5R////xwAAAf8FCwYmA88AAAAGBCEHUv//AKX/7ASUBR8GJgPRAAAABwQhAo0AUf///8MB0wFLBQsGJgPSAAAABwQhAAMBQP//ACL+FANPBR4GJgPTAAAABwQhAVcAUv//AEb/7ANzBR4GJgPUAAAABwQhAV4AUv//ADYAAAOQBh0GJgPVAAAABwQhATwAUf//AGMAAARIBR8GJgPXAAAABwQhAnEAUf//AHUAAALZBR8GJgPZAAAABwQhAVYAUv//AG7/7AReBR8GJgPaAAAABwQhAmAAUf//AFn+FAQ9BR8GJgPcAAAABwQhAj0BEP//AG7/7ARRBR8GJgPdAAAABwQhAlkBA///AE8AAAQQBQsGJgPfAAAABwQhAQL/rf//AK/+FASDBQsGJgPgAAAABwQhAkcAUP//ACwAAANeBR8GJgPhAAAABwQhAU8AUf//AFIAAAVeBQsGJgPiAAAABwQhAx7/d///ACj//ARoBR8GJgPjAAAABwQhAqMAT///AK8AAAFXBc4GJgPOAAABBwQeAQT/tgAKswQBeXIAK84wMf///BkE2f2uBiEEBwBD+8cAAP///YAE2f8VBiEEBwB2/S4AAP///rAE2QFRBiAEBwFK/l4AAP///BgE3P7/Bd0EBwFR+8YAAP///tUE2wEsBWEEBwFM/oMAAP///soE2QE4BecEBwFN/ngAAP///54FCABmBeIEBwFO/0wAAP///uUFEAEaBdIEBwBq/a8AAP///yUE2gDjBogEBwFP/tMAAP///wYE2QHYBiEEBwFS/rQAAP///q8E2QFQBiAEBwFL/l0AAAAC++UE2f63BiEADAAZACVAEQQRERMLGBgADROABgYPEwETAC9dMy8aEM0yMhEzETMRMzAxQR4CFxUjLgMnNSMeAhcVIy4DJzX+ARY/RB1gIk9NPhGtFj5EHV8jUEw+EQYhLnBrJxgdUVlRHBQucGsnGB1RWVEcFP///2EDwQCIBbYEBwIF/0YAAAAB/Tr+of4D/3sACwAIsQAGAC8zMDFBIiY1NDYzMhYVFAb9nio6OiorOjr+oTY3ODU1ODc2AP///zf+FADGAAAEBwB6/xsAAP///1v+PgCmAB4EBwFQ/wkAAAAB/UAE1/4vBjgAEgAMsw4DgA8ALxrMMzAxQTQ2MzIWFRQOAhUUFhcVLgL9QEQ3LDIeJh47PU5rNgW4OUcoJhoaDxMVHDISSBQ/VwAAAf1EBNf+MQY4ABIADLMQgAUEAC8zGswwMUEUBgYHNTY2NTQuAjU0NjMyFv4xNmlOOz0eJh4zKzdCBbg3Vz8USBIyHBUTDxoaJihHAAH8VwSS/zQFsgAUAA+0DQkJAwAAL80zfBDMMDFBBgYjIiY1NDYzITY2MzIWFRQGBiP9DAUoLzEoKTIBygUrLTEqEikiBPAsMjQxNCkvLzEyIyoSAAH8WgTj/z8F2QAWABK2ERAQCgCABwAvGswyMy8zMDFBMh4CFRUjNCYjIg4CIyM1MzI+Av5YN1Y7H3hDLy5ldYxVEg9OgXNxBdkbNlA2H0sxIy8jeSQuJAAC/8H+DQBM/6sACwAXAA+0DBISAAYAfC8zMi8zMDFXIiY1NDYzMhYVFAYDIiY1NDYzMhYVFAYFISMjISMkJCMhIyMhIyQk8CcmJigoJiYn/v0oJiYoKCUnKAAF/qD+CgFN/6gACwAWACIALgA6ACBADS81NQYjKSkXHR0AEQYAfC8zMzIRMzMRMxEzETMwMUUiJjU0NjMyFhUUBjMiNTQ2MzIWFRQGAyImNTQ2MzIWFRQGISImNTQ2MzIWFRQGAyImNTQ2MzIWFRQG/uUiIyMiIiQk/0UjIiIkJLMiIyQhIyQkAW8hIyMhIyMjIyEjIyEjIyP0KCYmKCgmJihOJigoJiYo/v4nJycnKCYmKCcnJigoJiYoAQIoJiYoKCYmKAAD/tL+CgEf/6gAAwAPABsAGEAJBAoKEBAWFgABAHwvMzMRMxEzETMwMUU1IRUTIiY1NDYzMhYVFAYDIiY1NDYzMhYVFAb+0gFnnyIjJCEiJSQjIiMkISIlJM5SUv7YJycnJygmJigBAigmJycoJiYoAAAD/tL+CgEf/6gABwATAB8AG0AKCA4OFBQaGgCAAwB8LxoYzDMRMxEzETMwMUM1IzUhFSMVBSImNTQ2MzIWFRQGAyImNTQ2MzIWFRQGpIoBZooBKiIjIyIjJCQjIiMjIiMkJP5oylJSyl4nJyYoKCYmKAECKCYmKCgmJigAAf+6/w0ARv+pAAoACbEABQB8LzMwMUciNTQ2MzIWFRQGAkQjISQkJPNOJigoJiYoAAAC/yL/EgDP/60ACwAXAA+0AAYGDBIAfC8zMxEzMDFXIiY1NDYzMhYVFAYhIiY1NDYzMhYVFAaIIiMjIiIlJf68ISMkICMjI+4nJicnKCYlKCcnJyYoJSYoAAAD/yL+CgDP/6gACwAXACMAGUAJAAYYGB4MEhIeAHwvMxEzETMYEM4yMDFDIiY1NDYzMhYVFAYTIiY1NDYzMhYVFAYhIiY1NDYzMhYVFAYJIiMjIiMkJG4iIyMiIiUl/rwhIyQgIyMj/gonJyYoKCYmKAECJycmKCgmJigoJicnKCYmKAAB/0b/PQCz/48AAwAJsQABAHwvMzAxRzUhFboBbcNSUgAAAf9I/m8As/+LAAcACrIAgAMALxrMMDFDNSM1IRUjFSuNAWuN/m/JU1PJAAAB/7sFfQBHBhgACgAIsQUAAC8yMDFDIjU0NjMyFhUUBgFEIyIjJCQFfU0nJygmJicAAAH/wATpAEwFhAALAAixBgAALzIwMVMiJjU0NjMyFhUUBgQhIyMhIyUlBOknJicnKCYmJwAD/yj97QDl/6UACwAXACMAFrcYHh4MEhIABgB8LxjNMi/NMi/NMDFHIiY1NDYzMhYVFAYXIiY1NDYzMhYVFAYXIiY1NDYzMhYVFAaUISMkICMjI3UiIyMiIyQkdyIjIyIjJCT2JyYnJygmJiePKCcmKCgmJimOKCcmKCgmJygAAAH/wAH8AEwClwAKAAixBQAALzIwMVMiNTQ2MzIWFRQGBEQjISMlJQH8TScnKCYlKAAAAf/Q/jYALf9yAAMACrIAgAEALxrNMDFDETMRMF3+NgE8/sQAAf/ABOkATAWEAAoACLEFAAAvMjAxUyI1NDYzMhYVFAYERCMhIyUlBOlNJycoJiYnAAAB/7oE6QBGBYQACwAIsQYAAC8yMDFDIiY1NDYzMhYVFAYCIiIjISQkJATpJyYnJygmJicAAf9T/twAj/+7AAcAErUGAgIAgAMAfC8aGMwzETMwMUM1IzUhFSMVNncBPHj+3JBPT5AA//8AKf/wAp4DfgYHA3cAAPys//8ATAAAAeEDbQYHAHsAAPys//8AMgAAAnMDfwYHAHQAAPys//8AJf/xAo0DfwYHAHUAAPys//8AFQAAArUDcwYHAjcAAPys//8APv/uAosDbQYHAjgAAPys//8AKf/wAqEDfQYHA3gAAPys//8AOgAAApIDbQYHAjkAAPys//8ANP/xApQDfAYHAjoAAPys//8AI//wApwDgQYHA3kAAPysAAIAc//sBDcFzQARAB8AELccDgVyFQUNcgArMisyMDFBFAIGBiMiJiYCNTQSNjMyFhIFEBIzMhIRNAImIyIGAgQ3NnS4gXu1dzpf06+m1Wj845GpqZI+inNzij0C3bL+6MJlZcEBGLPrAVC1s/6v7P7N/tABLwE0yQEPiYn+8QAAAQAzAAACSQW2AA0AFUAKCgkJBQsEcg0McgArKzIyLzMwMWERNDY2NwYGBwcnATMRAaYCAwMfNyimVwGLiwQMO1VHJSAtIYZxATH6SgAAAQBPAAAEDAXLAB0AF0ALCREFchoBGxsADHIAKzIRMzMrMjAxczUBPgI1NCYjIgYHJz4CMzIWFhUUBgYHARUhFU8Bh22VTpN3aqNUWTqInlqGxGpcpXD+wgLriwGNbqynZHyDSEJwMUwsXq54dMfDbf7DB5gAAAEAV//sBBUFywAtAB1ADQQDHR0aGgskKwUSCw0APzM/MxI5LzMSOTkwMUEUBgcVFhYVFAYGIyImJzUWFjMyNjY1NCYmIyM1MzI2NjU0JiMiBgcnNjYzMhYD6KeJrq939b90xVpb1mSFp05juoKRk3emV5R/dq1TVFDmkuDgBGGTsRsIFrSSf8RvJSucLTNIhVxfdTeORn9Xb3lFOHI+WssAAAIAMAAABHAFvgAKABUAHUANBgMLCwkQBAEBBAQADAA/PzkvEjkzMxEzMzAxYREhNQEzETMVIxEDETQ2NjcjBgYHAQL0/TwCuazb26EBBAMIFkAZ/lABU4wD3/wrlv6tAekB3kl0XCUoZCP9kwAAAQB+/+wEFwW2ACEAIUAPGhkZFhYfAAAIHhsEDwgNAD8zPzMSOS8zMxEzETMwMUEyFhYVFAYGIyImJzUWFjMyNjY1NCYjIgYHJxMhFSEDNjYCLZbceILzqnPEQ0nQYm+nXbPAP5QvVTgC2P22JCV5A35lwImW2XUoKJ4sNEeRbpKfFAw3Aq6Y/kgHEQACAHP/7AQvBcsAIgAxABtADBIpKRYWBiMeDQ0GBQA/Mz8zEjkvMxEzMDFTND4DMzIWFxUmJiMiBgIHMz4CMzIWFhUUBgYjIi4CATI2NTQmJyYGBhUUHgJzJViX458uZyIlXjC51l8HDB9giVuAv2lxz45rtYVJAeyHpJKSZJRSJ096AnGE/NmkXQkKjw0Mof7rrjJRMGjGjZfcd1Ki8f6nrrCQpwEBU39BQoh0RgABABEAAAPgBbYABgAQtgYMBQICAwQAPzMRMz8wMXMBITUhFQHWAlj84wPP/awFHpiA+soAAwB6/+wEOgXLAB8AMAA+ABdADCgpCBgxBTgQBSAADQA/Mj8zFzkwMUUiJiY1NDY2Ny4CNTQ2NjMyFhYVFAYGBx4CFRQGBicyNjY1NCYmJycOAhUUFhYTPgI1NCYjIgYVFBYWAl6b2HFVjlVKeEdxw3yAxG5NgE9dllh21pRmjkpMi2AkXIFDRo1xSndFlHx1lkp9FF2ve2WVbCUoZolbb5tRUJtxWYVjJytskmR7s2CFQnZPSW9YJA0mXXZOSnVCAtcfTGtLanBxakxpSwACAGb/7AQjBcsAIgAxABtADBIpKRYWBiMeBQ0GDQA/Mz8zEjkvMxEzMDFBFA4DIyImJzUWFjMyNhI3Iw4CIyImJjU0NjYzMh4CASIGFRQWFzI2NjU0LgIEIyVZmOWfK24jJWQwu9VfBgweYYpcf71oc9CNa7SFSf4ThqWPk2aWUSdQegNHhfzZpVwKC48ND6EBFK4wUTFoxoyY3HhSo/ABWK2wkKYBUX1CQohzR///ACkCOgKeBcgGBwN3AAD+9v//AEwCSgHhBbcGBwB7AAD+9v//ADICSgJzBckGBwB0AAD+9v//ACUCOwKNBckGBwB1AAD+9v//ABUCSgK1Bb0GBwI3AAD+9v//AD4COAKLBbcGBwI4AAD+9v//ACkCOgKhBccGBwN4AAD+9v//ADoCSgKSBbcGBwI5AAD+9v//ADQCOwKUBcYGBwI6AAD+9v//ACMCOgKcBcsGBwN5AAD+9gACAHD/7AQ9BF4ADwAbABC3FggHchAAC3IAKzIrMjAxRSImAjU0NjYzMh4CFRACJzI2NTQmIyIGFRQWAlOi12pw2p96tXk89fOhmp2fnZ2cFJEBAqmr/o1Rl9B+/v3+x4za1tPX19PQ4AAAAQAqAAACZgReAA0AErcLCgoGDAZyAAAvKzIyETMwMWEjETQ2NjcGBgcHJwEzAmaoAgUCEz8p0FIBsIwCmjZnWyMUOB2ZcQE6AAABAFUAAAP4BF4AHQAVQAkLEgdyGwIcHAEALzMRMzMrMjAxYSE1AT4CNTQmJiMiBgcnNjYzMhYWFRQGBgcFFyED+PxdAZdrgDo5cVRXrFNYZ9+De7FgSIpk/tcCApuHASFMZ2NEQFsxQkVzV01OkGRdjHtG2AYAAQA7/poDywRfAC0AHUANBQQdHRoaDCQrB3ITDAAvMysyEjkvMxI5OTAxQRQGBgcVFhYVFAYGIyImJzUWFjMyNjU0JiYjIzUzMjY2NTQmIyIGByc2NjMyFgOeQoBdqqJ/6aCAuFBKw2utumC0foCCY6Vjl3FqmlhMVtmCu+0C/lyMXBUGFKmah8BnLSeVJjmdjllxNow2eWRvdzo8ckdIugAAAgAu/qYEaAReAAoAFQAeQA4REAcGcgYLCwkJBAIBCgA/zTMzETMRMysyMjAxZSMRIxEhNQEzETMhETQ2NjcjBgYHAQRo5KP9TQKrq+T+eQIEAwcQPC3+biP+gwF9bgPN/EwBuD9saTgfYEL9vQABAHn+mQQVBEgAIQAhQA8aGRkWFh8AAAgeGwZyDwgALzMrMhI5LzMzETMRMzAxQTIWFhUUBgYjIiYnNRYWMzI2NjU0JiMiBgcnEyEVIQM2NgIrkt17hPWqc8BGXr1icqZbv6xAjERNNwLf/bcnP3MCEl+8jZrPaCwomS80RYxqlZgTFC4CtpT+RAwOAAIAdv/sBDYFzgAhADAAH0APEBEoKBUVBSIdDXIMBQVyACsyKzISOS8zETMzMDFTNBI2NhcyFhcVJiYjIgYCBzM+AjMyFhYVFAYGIyIuAgEyNjU0JicmBgYXFB4Cdlut+J0vXC0pXjeb3HoJCypvhkuJwGVuz5N+uns9AeyPnpWNV5ddASpRdwJt3AFG1mkBCwqLDAuJ/uzSPlgua8mNld16YK3q/pW1q5OmAQJQgEhDiXJGAAEAIf6tA+0ESAAGABC2BgUCAgMGcgArMhEzLzAxUwEhNSEVAe8CQvzwA8z9uP6tBQmSavrPAAMAZ//sBCkFywAfAC8APQAaQA4sGAg3BAAkEA1yMAAFcgArMisyERc5MDFBMhYWFRQGBgceAhUUBgYjIiYmNTQ2NjcuAjU0NjYDFBYWMzI2NjU0JiYnDgIBIgYVFBYWFz4CNTQmAkiAw29Ngk9el1h31pCb2XFWjlRJeUdxxcJGjmpljktJmXlcgUQBPHaWSX5OSnZGlQXLUJtxWYVjJytskmR7s2Bdr3tllWwlKGaJW2+bUfunSnVCQnZPSW5dLSZddgODcWpMaUsgH0xrS2pwAAIAYv6aBCUEXgAgAC8AG0AMEScnFRUFIRwHcgwFAC8zKzIROS8zETMwMUEUAgYGIyImJzUWFjMyNhI3Iw4CIyImNTQ2NjMyHgIBIgYVFBYXMjY2NTQuAgQlWKv8pDhkKytpLp7kgQoIJ2uMXMffcNCQdbmBRP4QkJ2XjleWXCdPeQHZ2f7GymIMCowNDoMBENFDWi3p0pPbelOj8QFbt6CXogFHflBEh29CAAADAGf/7AQrBc0AAwAUACQAGkAOAAEDAgQJIREFchkJDXIAKzIrMhIXOTAxQScBFxMUAgYGIyImAjU0EjYzMhYSBRQSFjMyNhI1NAImIyIGAgEeagKval42dLiBo9VpX9SupdZo/OM+i3Fxiz8+inNzij0BWmsCrmr+1LL+6MJlsgFR7uoBUbWz/q/szP7wh4YBEM3JAQ+Jif7xAP//AEj/7AQVBF4EBgRE2AD//wCXAAAC0wReBAYERW0A//8AXwAABAIEXgQGBEYKAP//AEv+mgPbBF8EBgRHEAD//wAH/qYEQQReBAYESNkA//8AYP6ZA/wESAQGBEnnAP//AFT/7AQUBc4EBgRK3gD//wBC/q0EDgRIBAYESyEA//8ATP/sBA4FywQGBEzlAP//AEb+mgQJBF4EBgRN5AD//wAp/uYCngJ0BgcDdwAA+6L//wBM/vYB4QJjBgcAewAA+6L//wAy/vYCcwJ1BgcAdAAA+6L//wAl/ucCjQJ1BgcAdQAA+6L//wAV/vYCtQJpBgcCNwAA+6L//wA+/uQCiwJjBgcCOAAA+6L//wAp/uYCoQJzBgcDeAAA+6L//wA6/vYCkgJjBgcCOQAA+6L//wA0/ucClAJyBgcCOgAA+6L//wAj/uYCnAJ3BgcDeQAA+6IAAQBSBIMCQgULAAMACLEBAAAvMjAxUzUhFVIB8ASDiIgAAAEAUAHbAY0GIAANAAixCwMAL8QwMVM0EjczBgIVFBIXIyYCUGJbgGFkY2KAWGUD/qwBDmht/uecmP7lcGIBFf//AFD+ZAGNAqkGBwRkAAD8iQABAD0B2wF7BiAADQAIsQQKAC/GMDFBFAIHIzYSNTQCJzMWEgF7ZFmBZGNlYoFbYgQBrf7waW8BHpedARZuaP7qAP//AD3+ZAF7AqkGBwRmAAD8iQABAEgCkAJmBLkACwAStgcFBAQKAAEALzMzMxEzMzAxQTUjNTM1MxUzFSMVASXd3WTd3QKQ42Ti4mTjAAACAEgDAgJmBEYAAwAHAAyzBAUBAAAvMs4yMDFTNSEVBTUhFUgCHv3iAh4D42Nj4WRk//8ASP8ZAmYBQgYHBGgAAPyJ//8ASP+LAmYAzwYHBGkAAPyJ//8AFQAAAtkFtgYGABIAAAACAK4AAAWiBbYADwAfACVAERAQDg4ZAQRyCAgSEh8fAAxyACsyETMRM3wvKzIyETN9LzAxcxEhMhYWFREjETQmJiMhERMzESEyNjY1ETMRFAYGIyGuAcyQvl2YRYNd/uDVmgEWaI1HmV3Io/5DBbZxzIf9gwJ8aY9K+s0EQvxBS5JoA+78EoHPeAACAHEC1wXWBckAFAA9ADNAHAMfOiI2MyYPCwkpBwcODgAAHBUpwAQBATApA3IAKzIyLzMaEMwyMi8zLzMvERc5MDFBETMTEzMRIxE0NjcjAyMDIxYWFREFIiYnNRYWMzI2NTQmJy4CNTQ2MzIWFwcmJiMiBhUUFhceAhUUBgYC47TGzK16BQEI02XKBwID/e06biUpcD1RVVRTMmVDkHc8aC0eJl40RkpTVEdhM0aCAuUC0f3MAjT9LwGeF2Id/cwCNCNVFP5YDhQSZhAdOjI0Nh8TMFNFYmEXE18UGTUzNjEfGDVMPUReMP//AK8AAAFVBEgGBgOvAAD///+Q/hQBVQRIBgYDsAAAAAEBdP47Am7/gwALAA60AQcFgAsALxrNOTkwMUUVDgIHIzU+AjcCbgowQSRbDyMeBX0RJ3BzLRgibXUs//8AM/4+AX4ESAYmA68AAAAGAVDhAP//AKT+oQFtBEgGJgOvAAAABwQOA2oAAAABAAAEdACRABYAXwAFAAIAEAAvAJoAAAK+D4MAAwABAAAAAAAAAAAAAAApAEcAnwEFAWUB2AHsAhMCPQJuAo0CqgK7AtYC6wMrA1EDjQPgBBkEYAS4BNQFPAWVBcIF8gYQBioGSAaVByEHVgehB90IDggzCFMImAi8CM4I8wkfCTUJbQmbCd0KEApfCpoK7wsKCzULXwuzC94MAQwkDD8MVAxuDIoMnAy+DQ8NWw2SDd0OHQ5TDtUPDQ8zD2oPoA+yEAEQMhBtEL4RCxE8EYkRvxHzEhsSbhKbEtoS/RNFE1YTnRPWE9YT/RQ+FIcU/BU7FVQVxhX0FmUWshbqFwEXCRd7F40XwRfsGCEYaxiNGMwY9hj/GS0ZUxmDGbcaFRpyGvQbQBtSG2QbdhuIG5sbpxvjG+8cARwTHCUcOBxKHFwcbhyBHMQc1hzoHPodDB0eHTEdZB3UHeYd+B4KHh0eLx5oHsce2R7rHv0fDh8gHzQftx/DH9Uf5x/5IAsgHCAtID8gUiC1IMcg2SDrIP0hDyEhIVghwCHSIeQh9iIIIhoiayJ9Io8ioSKzIsUi0SLdIu8jASMTIyUjNyNJI1sjbSN/I5IjmiPwJAIkFCQmJDgkSiRcJGgkziTgJPIlBCUWJSglOyVNJWAlbCV9JY8loiXaJh8mMiZEJlcmaCZ7JowmlyaiJrUmwSbNJt8m8Sb9JwgnPCdOJ2Anayd3J4onnCeoJ7Qn3igDKBUoJygzKD8oUShjKG8osij6KQwpHikwKUIpVSloKcEqMSpDKlUqYSptKn8qkCqiKrQqxirXKuMq7ysBKxIrHSsoKzorRit0K7UrxyvZK+sr/SwPLCEsNSxJLFwsbyzALMws3izwLQItEy0mLTgtSi1cLW4tgC2RLbcuAS5rLvcvCS8bLy0vPy9KL1Uvgi+xL8Qv6zAHMDQwXjCVMM4w7jEwMTwxRTFSMV8xbDF4MYUxkTGmMa4xtjHNMf8yBzIPMhcyZDJsMnQynjKmMq4y1DLcMvYy/jM1Mz0zRTOYM6Az3zQtNEA0UzRkNHU0hjSYNKs1CjVmNZw19zZHNpQ2yDcMNzE3OTePN5c3wzgqODI4aDitOPI5MjliOZE54zo2Ono60zrmOvg7CTsaOyw7PzuBO5M72TvhO+k7/DwEPF48nzzQPOI89D0WPR49UT1ZPWE9nD2kPdw+Lz5iPnQ+mT7UPtw+5D7sPvQ+/D8EPww/TD9UP1w/gD+vP9I//UAxQGpAm0DhQTZBcEF4QdtCJkI9QnVCfUK2QwpDOUNKQ3BDokPXQ/xEBEQfRCdEL0RMRFREpUStRNJFA0UoRVVFjEXGRflGOEaGRr5G0EcoRzpHekeCR4pHnUelR/ZIOUhBSFNIZEiGSKJIvkjQSOJI9EkGSRlJLEk+SVBJYUlySXpJlEmySdFJ2kn4SipKXUpmSo5Kz0rvSv9Lg0uWS7VL00vxS/1MEkxBTHBMwk0eTYJN6U4/Tp1O407rTzBPsVBXUPRRalHJUdFR61IVUiZSSVKpUt5S61MkUzBTPFNmU4xTrFO1U9RUB1RHVGJUu1S7VLtUu1S7VLtUu1S7VLtUu1S7VLtUu1S7VadV+1YNVhVWklbQVzJXRFdWV2JXd1elV/pYSViKWNNZAlkUWSZZOFlKWaVZ/Fo8Wnxa0VshW2Fbn1vxXD9cjlzcXT9doF48Xthe4F7oXzNfd1+2X/NgBmAZYJJgnmEJYWxiJWLSYuRi9mM0Y25joWRWZOZlO2WOZc5mD2ZgZspm82ccZ2Znq2ftaC9oO2hHaHhoqGjaaQxpO2l0aaBpzGn5aiZqT2p4asdrEGuXbBJsHmwqbE5scWx5bKZs2m0UbUptgG2tbdxuFG5JbpBu1m8Gbw5vbW/HcC1wi3CTcKVwt3EOcVVxmXHVcgxyRHJycqBy13MPc1Rzk3Obc61zvnPRc+Nz63PzdAV0FnRhdGl0fHSOdKF0tHTHdNl1HXVgdXJ1hHWXdal1vHXOddZ13nXxdgN2FnYpdjt2TXZgdnJ2hXaYdqt2vXbddv13EHcjdy93cXe6eAN4PHh3eKd4r3kBeWR5wXodeml6snsHe1R7knvTfBl8W3yPfMZ9Gn0ifXl9x33Tfd998X4Dfhd+K34/flN+Z357fo9+o365fs9+4373fwt/H38zf0d/W39vf4V/m3+nf7N/xX/Xf+l/+oANgCCANIBIgFyAcICEgJiAroDEgNaA6ID0gQCBDIEYgSqBPIFPgWKBdoGKgZ6BsoHGgdqB8IIGghiCKoI8gk6CYIJygoSCloKigq6CuoLGgtiC6oL8gw6DIIMyg0SDVoNog3qDhoOSg56DqoO8g86D4IPxhAOERYSHhN6FNIVthaWF7YY4hl+Gh4aThp+Gq4a3hs2G44ckhyyHQod/h6yH+4hJiF+IdYiLiKGIt4jNiOOI+YlBiUmJlYnzilSKoYrvixeLI4svizuLS4tbi7CMAoxQjGOMdoyCjI6MoIysjNiM/o0QjSKNNI1HjVmNa419jYmNlI2mjbKNxI3WjeKN7433jgqOEo4lji2ONY5HjmyOdI58jo2On46zjyqPNo9Bj5iP9pAIkBqQLJB+kNSQ3JEOkT6RT5GbkcqSEZJbko+S2JMQk1eTf5O/k9GUAJQ8lJmUr5TrlUiVa5WplguWMZZvltaXEpdol+WYGphamJiYyZkcmW6ZgJmSmaiZvpnKmdaZ4pnumfqaBpoSmh2aKJo0mkCaTJpYmmSacJp8moialJqgmqyauJrEmtCa3JrumvebAJsJmxKbG5skmy2bNps/m0ibUZuNm5absZu6m8Ob6ZwPnDmcZZySnPWdLp1snYWdsp30ngWeG540nk6ejp6nnrme0p7snwafD58YnyGfKp8znzyfRZ9On1efYJ+gn8egAqBToIqg0KEnoUGhqKH/ogiiEaIaoiOiLKI1oj6iR6JQolmijqKzou6jP6N2o7ykFqQxpJqk8KU+pUalTqVWpV6lZqVupXalfqWGpY6ll6WgpamlsqW7pcSlzaXWpd+l6KX5phmmIqZDpkymaqaDpoymlaadpuKnV6dfp2enhaeQp5wAAAABAAAAAwBCt70h4F8PPPUACwgAAAAAANnMwvcAAAAA3XcmUfuc/dMJnAhiAAAABgACAAAAAAAABM0AwQAAAAACFAAAAhQAAAIdAJYDMACHBSsANASTAH8GnQBmBdQAbwHBAIcCXABSAlwAPgRoAFkEkwBnAhIAUwKTAFICGgCWAu8AFQSTAGcEkwC5BJMAZQSTAFwEkwAsBJMAhASTAHQEkwBdBJMAZwSTAGcCGgCWAhoAQQSTAGcEkwBzBJMAZwN0AB8HLAB2BQ8AAAUrAMgFCgB9Bc4AyARyAMgEIQDIBdEAfQXmAMgCPADIAib/XATmAMgELQDIBzIAyAYGAMgGOQB9BNAAyAY5AH0E8ADIBGMAaQRoABIF1QC5BMUAAAdjAB4EnwAGBHkAAASUAE4CngCmAu8AFQKeADMEkwBQA4H//AI4AFIEcgBeBOUArwPVAHIE5QByBH4AcgKxAB4EWAAfBOgArwIFAKACBf+QBDQArwIFAK8HaACvBOgArwTQAHIE5QCvBOUAcQNFAK8D0ABnAtoAIAToAKMD/wAABjMAGAQwACcEAgACA8AAUAMAADkEZQHsAwAAQwSTAGcCFAAAAh0AlgSTALkEkwBEBJMAeQSTAB8EZQHsBBwAegSjATYGqABkAtMARAP3AE8EkwBnApMAUgaoAGQEAP/6A20AdQSTAGcCyAAyAsgAJQI4AFIE8gCvBT0AegIaAJYBxgAcAsgATAL9AEMD9wBNBewAQgYlACwGOgAhA3QANQUPAAAFDwAABQ8AAAUPAAAFDwAABQ8AAAby//4FCgB9BHIAyARyAMgEcgDIBHIAyAI8//QCPAC0Ajz/zgI8AAYFzgA6BgYAyAY5AH0GOQB9BjkAfQY5AH0GOQB9BJMAhQY5AH0F1QC5BdUAuQXVALkF1QC5BHkAAATQAMgE+wCvBHIAXgRyAF4EcgBeBHIAXgRyAF4EcgBeBuYAXgPVAHIEfgByBH4AcgR+AHIEfgByAgX/+AIFAI8CBf+1AgX/5wTMAHEE6ACvBNAAcgTQAHIE0AByBNAAcgTQAHIEkwBnBNAAcgToAKME6ACjBOgAowToAKMEAgACBOUArwQCAAIFDwAABHIAXgUPAAAEcgBeBQ8AAARyAF4FCgB9A9UAcgUKAH0D1QByBQoAfQPVAHIFCgB9A9UAcgXOAMgE5QByBc4AOgToAHIEcgDIBH4AcgRyAMgEfgByBHIAyAR+AHIEcgDIBH4AcgRyAMgEfgByBdEAfQRYAB8F0QB9BFgAHwXRAH0EWAAfBdEAfQRYAB8F5gDIBOj/twXmAAAE6AAUAjz/rQIF/4kCPP/zAgX/1gI8/+cCBf/TAjwAWAIFADECPAC9BGIAyAQKAKACJv9cAgX/kATmAMgENACvBDQArwQtAKcCBQCPBC0AyAIFAIMELQDIAgUArwQtAMgCFwCvBC0AGgIF//IGBgDIBOgArwYGAMgE6ACvBgYAyAToAK8FaQACBgYAyAToAK8GOQB9BNAAcgY5AH0E0AByBjkAfQTQAHIHZgB9B5YAcATwAMgDRQCvBPAAyANFAH0E8ADIA0UAlQRjAGkD0ABnBGMAaQPQAGcEYwBpA9AAZwRjAGkD0ABnBGgAEgLaACAEaAASAtoAIARoABIC2gAgBdUAuQToAKMF1QC5BOgAowXVALkE6ACjBdUAuQToAKMF1QC5BOgAowXVALkE6ACjB2MAHgYzABgEeQAABAIAAgR5AAAElABOA8AAUASUAE4DwABQBJQATgPAAFAClQCvBJMAvgUR//4EcgBeBvL//gbmAF4GOQB9BNAAcgRjAGkD0ABnA0UAUgNFAFIC+wBSAxIAUgFsAFICYgBSAe8AUgOKAFIDdgBSBJ4CCASeASAFDwAAAhoAlgUV//4Gif/+AuT//gaP//4Fr//+BoT/8gK3/9UFDwAABSsAyAQpAMgEogAlBHIAyASUAE4F5gDIBjkAfQI8AMgE5gDIBNMAAAcyAMgGBgDIBGgAQwY5AH0F0wDIBNAAyASIAEgEaAASBHkAAAZgAGkEnwAGBmEAbwY/AE8CPAAGBHkAAATjAHID0gBZ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AHQAeQBwAGUAIABJAG0AYQBnAGkAbgBnACAASQBuAGMALgBNAG8AbgBvAHQAeQBwAGUAIABEAGUAcwBpAGcAbgAgAFQAZQBhAG0ARABlAHMAaQBnAG4AZQBkACAAYgB5ACAATQBvAG4AbwB0AHkAcABlACAAZABlAHMAaQBnAG4AIAB0AGUAYQBtAC4AaAB0AHQAcAA6AC8ALwB3AHcAdwAuAGcAbwBvAGcAbABlAC4AYwBvAG0ALwBnAGUAdAAvAG4AbwB0AG8ALwBoAHQAdABwADoALwAvAHcAdwB3AC4AbQBvAG4AbwB0AHkAcABlAC4AYwBvAG0ALwBzAHQAdQBkAGkAbwBUAGgAaQBzACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAGkAcwAgAGwAaQBjAGUAbgBzAGUAZAAgAHUAbgBkAGUAcgAgAHQAaABlACAAUwBJAEwAIABPAHAAZQBuACAARgBvAG4AdAAgAEwAaQBjAGUAbgBzAGUALAAgAFYAZQByAHMAaQBvAG4AIAAxAC4AMQAuACAAVABoAGkAcwAgAGwAaQBjAGUAbgBzAGUAIABpAHMAIABhAHYAYQBpAGwAYQBiAGwAZQAgAHcAaQB0AGgAIABhACAARgBBAFEAIABhAHQAOgAgAGgAdAB0AHAAcwA6AC8ALwBzAGMAcgBpAHAAdABzAC4AcwBpAGwALgBvAHIAZwAvAE8ARgBMAGgAdAB0AHAAOgAvAC8AcwBjAHIAaQBwAHQAcwAuAHMAaQBsAC4AbwByAGcALwBPAEYATABPAHAAZQBuAFMAYQBuAHMAUgBvAG0AYQBuAFcAZQBpAGcAaAB0AFcAaQBkAHQAaABOAG8AcgBtAGEAbABJAHQAYQBsAGkAYwBSAG8AbQBhAG4AAAACAAAAAAAA/5wAMgAAAAAAAAAAAAAAAAAAAAAAAAAABHQAAAECAQMAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAQQAowCEAIUAvQCWAOgAhgCOAIsAnQCpAKQBBQCKAQYAgwCTAQcBCACNAQkAiADDAN4BCgCeAKoA9QD0APYAogCtAMkAxwCuAGIAYwCQAGQAywBlAMgAygDPAMwAzQDOAOkAZgDTANAA0QCvAGcA8ACRANYA1ADVAGgA6wDtAIkAagBpAGsAbQBsAG4AoABvAHEAcAByAHMAdQB0AHYAdwDqAHgAegB5AHsAfQB8ALgAoQB/AH4AgACBAOwA7gC6AQsBDAENAQ4BDwEQAP0A/gERARIBEwEUAP8BAAEVARYBFwEBARgBGQEaARsBHAEdAR4BHwEgASEBIgEjAPgA+QEkASUBJgEnASgBKQEqASsBLAEtAS4BLwEwATEBMgEzAPoBNAE1ATYBNwE4ATkBOgE7ATwBPQE+AT8BQAFBAUIA4gDjAUMBRAFFAUYBRwFIAUkBSgFLAUwBTQFOAU8BUAFRALAAsQFSAVMBVAFVAVYBVwFYAVkBWgFbAPsA/ADkAOUBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoBawFsAW0BbgFvAXABcQC7AXIBcwF0AXUA5gDnAXYApgF3AXgBeQF6AXsBfAF9AX4A2ADhANoA2wDcAN0A4ADZAN8BfwGAAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcAmwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHfAeAB4QHiAeMB5AHlAeYB5wHoAekB6gHrAewB7QHuAe8B8AHxAfIB8wH0AfUB9gH3AfgB+QH6AfsB/AH9Af4B/wIAAgECAgIDAgQCBQIGAgcCCAIJAgoCCwIMAg0CDgIPAhACEQISAhMCFAIVAhYCFwIYAhkCGgIbAhwCHQIeAh8CIAIhAiICIwIkAiUCJgInAigCKQIqAisAsgCzAiwCLQC2ALcAxAIuALQAtQDFAIIAwgCHAKsAxgIvAjAAvgC/AjEAvAIyAPcCMwI0AjUCNgI3AjgAjAI5AjoCOwI8Aj0CPgCYAj8AmgCZAO8ApQCSAJwApwCPAJQAlQC5AkACQQJCAkMCRAJFAkYCRwJIAkkCSgJLAkwCTQJOAk8CUAJRAlICUwJUAlUCVgJXAlgCWQJaAlsCXAJdAl4CXwJgAmECYgJjAmQCZQJmAmcCaAJpAmoCawJsAm0CbgJvAnACcQJyAnMCdAJ1AnYCdwJ4AnkCegJ7AnwCfQJ+An8CgAKBAoICgwKEAoUChgKHAogCiQKKAosCjAKNAo4CjwKQApECkgKTApQClQKWApcCmAKZApoCmwKcAp0CngKfAqACoQKiAqMCpAKlAqYCpwKoAqkCqgKrAqwCrQKuAq8CsAKxArICswK0ArUCtgK3ArgCuQK6ArsCvAK9Ar4CvwLAAsECwgLDAsQCxQLGAscCyALJAsoCywLMAs0CzgLPAtAC0QLSAtMC1ALVAtYC1wLYAtkC2gLbAtwC3QLeAt8C4ALhAuIC4wLkAuUC5gLnAugC6QLqAusC7ALtAu4C7wLwAvEC8gLzAvQC9QL2AvcC+AL5AvoC+wL8Av0C/gL/AwADAQMCAwMDBAMFAwYDBwMIAwkDCgMLAwwDDQMOAw8DEAMRAxIDEwMUAxUDFgMXAxgDGQMaAxsDHAMdAx4DHwMgAyEDIgMjAyQDJQMmAycDKAMpAyoDKwMsAy0DLgMvAzADMQMyAzMDNAM1AzYDNwM4AzkDOgM7AzwDPQM+Az8DQANBA0IDQwNEA0UDRgNHA0gDSQNKA0sDTANNA04DTwNQA1EDUgNTA1QDVQNWA1cDWANZA1oDWwNcA10DXgNfA2ADYQNiA2MDZANlA2YDZwNoA2kDagNrA2wDbQNuA28DcANxA3IDcwN0A3UDdgN3A3gDeQN6A3sDfAN9A34DfwOAA4EDggODA4QDhQOGA4cDiAOJA4oDiwOMA40DjgOPA5ADkQOSA5MDlAOVA5YDlwDAAMEDmAOZA5oDmwOcA50DngOfA6ADoQOiA6MDpAOlA6YDpwOoA6kDqgOrA6wDrQOuA68DsAOxA7IDswO0A7UDtgO3A7gDuQDXA7oDuwO8A70DvgO/A8ADwQPCA8MDxAPFA8YDxwPIA8kDygPLA8wDzQPOA88D0APRA9ID0wPUA9UD1gPXA9gD2QPaA9sD3APdA94D3wPgA+ED4gPjA+QD5QPmA+cD6APpA+oD6wPsA+0D7gPvA/AD8QPyA/MD9AP1A/YD9wP4A/kD+gP7A/wD/QP+A/8EAAQBBAIEAwQEBAUEBgQHBAgECQQKBAsEDAQNBA4EDwQQBBEEEgQTBBQEFQQWBBcEGAQZBBoEGwQcBB0EHgQfBCAEIQQiBCMEJAQlBCYEJwQoBCkEKgQrBCwELQQuBC8EMAQxBDIEMwQ0BDUENgQ3BDgEOQQ6BDsEPAQ9BD4EPwRABEEEQgRDBEQERQRGBEcESARJBEoESwRMBE0ETgRPBFAEUQRSBFMEVARVBFYEVwRYBFkEWgRbBFwEXQReBF8EYARhBGIEYwRkBGUEZgRnBGgEaQRqBGsEbARtBG4EbwRwBHEEcgRzBHQEdQR2BHcEeAR5BHoEewR8BH0ETlVMTAJDUgd1bmkwMEEwB3VuaTAwQUQJb3ZlcnNjb3JlB3VuaTAwQjIHdW5pMDBCMwd1bmkwMEI1B3VuaTAwQjkHQW1hY3JvbgdhbWFjcm9uBkFicmV2ZQZhYnJldmUHQW9nb25lawdhb2dvbmVrC0NjaXJjdW1mbGV4C2NjaXJjdW1mbGV4BENkb3QEY2RvdAZEY2Fyb24GZGNhcm9uBkRjcm9hdAdFbWFjcm9uB2VtYWNyb24GRWJyZXZlBmVicmV2ZQpFZG90YWNjZW50CmVkb3RhY2NlbnQHRW9nb25lawdlb2dvbmVrBkVjYXJvbgZlY2Fyb24LR2NpcmN1bWZsZXgLZ2NpcmN1bWZsZXgER2RvdARnZG90B3VuaTAxMjIHdW5pMDEyMwtIY2lyY3VtZmxleAtoY2lyY3VtZmxleARIYmFyBGhiYXIGSXRpbGRlBml0aWxkZQdJbWFjcm9uB2ltYWNyb24GSWJyZXZlBmlicmV2ZQdJb2dvbmVrB2lvZ29uZWsCSUoCaWoLSmNpcmN1bWZsZXgLamNpcmN1bWZsZXgHdW5pMDEzNgd1bmkwMTM3DGtncmVlbmxhbmRpYwZMYWN1dGUGbGFjdXRlB3VuaTAxM0IHdW5pMDEzQwZMY2Fyb24GbGNhcm9uBExkb3QEbGRvdAZOYWN1dGUGbmFjdXRlB3VuaTAxNDUHdW5pMDE0NgZOY2Fyb24GbmNhcm9uC25hcG9zdHJvcGhlA0VuZwNlbmcHT21hY3JvbgdvbWFjcm9uBk9icmV2ZQZvYnJldmUNT2h1bmdhcnVtbGF1dA1vaHVuZ2FydW1sYXV0BlJhY3V0ZQZyYWN1dGUHdW5pMDE1Ngd1bmkwMTU3BlJjYXJvbgZyY2Fyb24GU2FjdXRlBnNhY3V0ZQtTY2lyY3VtZmxleAtzY2lyY3VtZmxleAd1bmkwMjFBB3VuaTAyMUIGVGNhcm9uBnRjYXJvbgRUYmFyBHRiYXIGVXRpbGRlBnV0aWxkZQdVbWFjcm9uB3VtYWNyb24GVWJyZXZlBnVicmV2ZQVVcmluZwV1cmluZw1VaHVuZ2FydW1sYXV0DXVodW5nYXJ1bWxhdXQHVW9nb25lawd1b2dvbmVrC1djaXJjdW1mbGV4C3djaXJjdW1mbGV4C1ljaXJjdW1mbGV4C3ljaXJjdW1mbGV4BlphY3V0ZQZ6YWN1dGUKWmRvdGFjY2VudAp6ZG90YWNjZW50BWxvbmdzCkFyaW5nYWN1dGUKYXJpbmdhY3V0ZQdBRWFjdXRlB2FlYWN1dGULT3NsYXNoYWN1dGULb3NsYXNoYWN1dGUHdW5pMDIxOAd1bmkwMjE5BXRvbm9zDWRpZXJlc2lzdG9ub3MKQWxwaGF0b25vcwlhbm90ZWxlaWEMRXBzaWxvbnRvbm9zCEV0YXRvbm9zCUlvdGF0b25vcwxPbWljcm9udG9ub3MMVXBzaWxvbnRvbm9zCk9tZWdhdG9ub3MRaW90YWRpZXJlc2lzdG9ub3MFQWxwaGEEQmV0YQVHYW1tYQd1bmkwMzk0B0Vwc2lsb24EWmV0YQNFdGEFVGhldGEESW90YQVLYXBwYQZMYW1iZGECTXUCTnUCWGkHT21pY3JvbgJQaQNSaG8FU2lnbWEDVGF1B1Vwc2lsb24DUGhpA0NoaQNQc2kHdW5pMDNBOQxJb3RhZGllcmVzaXMPVXBzaWxvbmRpZXJlc2lzCmFscGhhdG9ub3MMZXBzaWxvbnRvbm9zCGV0YXRvbm9zCWlvdGF0b25vcxR1cHNpbG9uZGllcmVzaXN0b25vcwVhbHBoYQRiZXRhBWdhbW1hBWRlbHRhB2Vwc2lsb24EemV0YQNldGEFdGhldGEEaW90YQVrYXBwYQZsYW1iZGEHdW5pMDNCQwJudQJ4aQdvbWljcm9uA3Jobwd1bmkwM0MyBXNpZ21hA3RhdQd1cHNpbG9uA3BoaQNjaGkDcHNpBW9tZWdhDGlvdGFkaWVyZXNpcw91cHNpbG9uZGllcmVzaXMMb21pY3JvbnRvbm9zDHVwc2lsb250b25vcwpvbWVnYXRvbm9zB3VuaTA0MDEHdW5pMDQwMgd1bmkwNDAzB3VuaTA0MDQHdW5pMDQwNQd1bmkwNDA2B3VuaTA0MDcHdW5pMDQwOAd1bmkwNDA5B3VuaTA0MEEHdW5pMDQwQgd1bmkwNDBDB3VuaTA0MEUHdW5pMDQwRgd1bmkwNDEwB3VuaTA0MTEHdW5pMDQxMgd1bmkwNDEzB3VuaTA0MTQHdW5pMDQxNQd1bmkwNDE2B3VuaTA0MTcHdW5pMDQxOAd1bmkwNDE5B3VuaTA0MUEHdW5pMDQxQgd1bmkwNDFDB3VuaTA0MUQHdW5pMDQxRQd1bmkwNDFGB3VuaTA0MjAHdW5pMDQyMQd1bmkwNDIyB3VuaTA0MjMHdW5pMDQyNAd1bmkwNDI1B3VuaTA0MjYHdW5pMDQyNwd1bmkwNDI4B3VuaTA0MjkHdW5pMDQyQQd1bmkwNDJCB3VuaTA0MkMHdW5pMDQyRAd1bmkwNDJFB3VuaTA0MkYHdW5pMDQzMAd1bmkwNDMxB3VuaTA0MzIHdW5pMDQzMwd1bmkwNDM0B3VuaTA0MzUHdW5pMDQzNgd1bmkwNDM3B3VuaTA0MzgHdW5pMDQzOQd1bmkwNDNBB3VuaTA0M0IHdW5pMDQzQwd1bmkwNDNEB3VuaTA0M0UHdW5pMDQzRgd1bmkwNDQwB3VuaTA0NDEHdW5pMDQ0Mgd1bmkwNDQzB3VuaTA0NDQHdW5pMDQ0NQd1bmkwNDQ2B3VuaTA0NDcHdW5pMDQ0OAd1bmkwNDQ5B3VuaTA0NEEHdW5pMDQ0Qgd1bmkwNDRDB3VuaTA0NEQHdW5pMDQ0RQd1bmkwNDRGB3VuaTA0NTEHdW5pMDQ1Mgd1bmkwNDUzB3VuaTA0NTQHdW5pMDQ1NQd1bmkwNDU2B3VuaTA0NTcHdW5pMDQ1OAd1bmkwNDU5B3VuaTA0NUEHdW5pMDQ1Qgd1bmkwNDVDB3VuaTA0NUUHdW5pMDQ1Rgd1bmkwNDkwB3VuaTA0OTEGV2dyYXZlBndncmF2ZQZXYWN1dGUGd2FjdXRlCVdkaWVyZXNpcwl3ZGllcmVzaXMGWWdyYXZlBnlncmF2ZQd1bmkyMDE1DXVuZGVyc2NvcmVkYmwNcXVvdGVyZXZlcnNlZAZtaW51dGUGc2Vjb25kCWV4Y2xhbWRibAd1bmkyMDdGCWFmaWkwODk0MQZwZXNldGEERXVybwd1bmkyMTA1B3VuaTIxMTMHdW5pMjExNgd1bmkyMTI2CWVzdGltYXRlZAlvbmVlaWdodGgMdGhyZWVlaWdodGhzC2ZpdmVlaWdodGhzDHNldmVuZWlnaHRocwd1bmkyMjA2DWN5cmlsbGljYnJldmUQY2Fyb25jb21tYWFjY2VudAd1bmkwMzI2EWNvbW1hYWNjZW50cm90YXRlB3VuaTIwNzQHdW5pMjA3NQd1bmkyMDc3B3VuaTIwNzgHdW5pMjAwMAd1bmkyMDAxB3VuaTIwMDIHdW5pMjAwMwd1bmkyMDA0B3VuaTIwMDUHdW5pMjAwNgd1bmkyMDA3B3VuaTIwMDgHdW5pMjAwOQd1bmkyMDBBB3VuaTIwMEIHdW5pRkVGRgd1bmlGRkZDB3VuaUZGRkQHdW5pMDFGMAd1bmkwMkJDB3VuaTAzRDEHdW5pMDNEMgd1bmkwM0Q2B3VuaTFFM0UHdW5pMUUzRgd1bmkxRTAwB3VuaTFFMDEHdW5pMDJGMwVPaG9ybgVvaG9ybgVVaG9ybgV1aG9ybgRob29rB3VuaTA0MDAHdW5pMDQwRAd1bmkwNDUwB3VuaTA0NUQHdW5pMDQ2MAd1bmkwNDYxB3VuaTA0NjIHdW5pMDQ2Mwd1bmkwNDY0B3VuaTA0NjUHdW5pMDQ2Ngd1bmkwNDY3B3VuaTA0NjgHdW5pMDQ2OQd1bmkwNDZBB3VuaTA0NkIHdW5pMDQ2Qwd1bmkwNDZEB3VuaTA0NkUHdW5pMDQ2Rgd1bmkwNDcwB3VuaTA0NzEHdW5pMDQ3Mgd1bmkwNDczB3VuaTA0NzQHdW5pMDQ3NQd1bmkwNDc2B3VuaTA0NzcHdW5pMDQ3OAd1bmkwNDc5B3VuaTA0N0EHdW5pMDQ3Qgd1bmkwNDdDB3VuaTA0N0QHdW5pMDQ3RQd1bmkwNDdGB3VuaTA0ODAHdW5pMDQ4MQd1bmkwNDgyB3VuaTA0ODgHdW5pMDQ4OQd1bmkwNDhBB3VuaTA0OEIHdW5pMDQ4Qwd1bmkwNDhEB3VuaTA0OEUHdW5pMDQ4Rgd1bmkwNDkyB3VuaTA0OTMHdW5pMDQ5NAd1bmkwNDk1B3VuaTA0OTYHdW5pMDQ5Nwd1bmkwNDk4B3VuaTA0OTkHdW5pMDQ5QQd1bmkwNDlCB3VuaTA0OUMHdW5pMDQ5RAd1bmkwNDlFB3VuaTA0OUYHdW5pMDRBMAd1bmkwNEExB3VuaTA0QTIHdW5pMDRBMwd1bmkwNEE0B3VuaTA0QTUHdW5pMDRBNgd1bmkwNEE3B3VuaTA0QTgHdW5pMDRBOQd1bmkwNEFBB3VuaTA0QUIHdW5pMDRBQwd1bmkwNEFEB3VuaTA0QUUHdW5pMDRBRgd1bmkwNEIwB3VuaTA0QjEHdW5pMDRCMgd1bmkwNEIzB3VuaTA0QjQHdW5pMDRCNQd1bmkwNEI2B3VuaTA0QjcHdW5pMDRCOAd1bmkwNEI5B3VuaTA0QkEHdW5pMDRCQgd1bmkwNEJDB3VuaTA0QkQHdW5pMDRCRQd1bmkwNEJGB3VuaTA0QzAHdW5pMDRDMQd1bmkwNEMyB3VuaTA0QzMHdW5pMDRDNAd1bmkwNEM1B3VuaTA0QzYHdW5pMDRDNwd1bmkwNEM4B3VuaTA0QzkHdW5pMDRDQQd1bmkwNENCB3VuaTA0Q0MHdW5pMDRDRAd1bmkwNENFB3VuaTA0Q0YHdW5pMDREMAd1bmkwNEQxB3VuaTA0RDIHdW5pMDREMwd1bmkwNEQ0B3VuaTA0RDUHdW5pMDRENgd1bmkwNEQ3B3VuaTA0RDgHdW5pMDREOQd1bmkwNERBB3VuaTA0REIHdW5pMDREQwd1bmkwNEREB3VuaTA0REUHdW5pMDRERgd1bmkwNEUwB3VuaTA0RTEHdW5pMDRFMgd1bmkwNEUzB3VuaTA0RTQHdW5pMDRFNQd1bmkwNEU2B3VuaTA0RTcHdW5pMDRFOAd1bmkwNEU5B3VuaTA0RUEHdW5pMDRFQgd1bmkwNEVDB3VuaTA0RUQHdW5pMDRFRQd1bmkwNEVGB3VuaTA0RjAHdW5pMDRGMQd1bmkwNEYyB3VuaTA0RjMHdW5pMDRGNAd1bmkwNEY1B3VuaTA0RjYHdW5pMDRGNwd1bmkwNEY4B3VuaTA0RjkHdW5pMDRGQQd1bmkwNEZCB3VuaTA0RkMHdW5pMDRGRAd1bmkwNEZFB3VuaTA0RkYHdW5pMDUwMAd1bmkwNTAxB3VuaTA1MDIHdW5pMDUwMwd1bmkwNTA0B3VuaTA1MDUHdW5pMDUwNgd1bmkwNTA3B3VuaTA1MDgHdW5pMDUwOQd1bmkwNTBBB3VuaTA1MEIHdW5pMDUwQwd1bmkwNTBEB3VuaTA1MEUHdW5pMDUwRgd1bmkwNTEwB3VuaTA1MTEHdW5pMDUxMgd1bmkwNTEzB3VuaTFFQTAHdW5pMUVBMQd1bmkxRUEyB3VuaTFFQTMHdW5pMUVBNAd1bmkxRUE1B3VuaTFFQTYHdW5pMUVBNwd1bmkxRUE4B3VuaTFFQTkHdW5pMUVBQQd1bmkxRUFCB3VuaTFFQUMHdW5pMUVBRAd1bmkxRUFFB3VuaTFFQUYHdW5pMUVCMAd1bmkxRUIxB3VuaTFFQjIHdW5pMUVCMwd1bmkxRUI0B3VuaTFFQjUHdW5pMUVCNgd1bmkxRUI3B3VuaTFFQjgHdW5pMUVCOQd1bmkxRUJBB3VuaTFFQkIHdW5pMUVCQwd1bmkxRUJEB3VuaTFFQkUHdW5pMUVCRgd1bmkxRUMwB3VuaTFFQzEHdW5pMUVDMgd1bmkxRUMzB3VuaTFFQzQHdW5pMUVDNQd1bmkxRUM2B3VuaTFFQzcHdW5pMUVDOAd1bmkxRUM5B3VuaTFFQ0EHdW5pMUVDQgd1bmkxRUNDB3VuaTFFQ0QHdW5pMUVDRQd1bmkxRUNGB3VuaTFFRDAHdW5pMUVEMQd1bmkxRUQyB3VuaTFFRDMHdW5pMUVENAd1bmkxRUQ1B3VuaTFFRDYHdW5pMUVENwd1bmkxRUQ4B3VuaTFFRDkHdW5pMUVEQQd1bmkxRURCB3VuaTFFREMHdW5pMUVERAd1bmkxRURFB3VuaTFFREYHdW5pMUVFMAd1bmkxRUUxB3VuaTFFRTIHdW5pMUVFMwd1bmkxRUU0B3VuaTFFRTUHdW5pMUVFNgd1bmkxRUU3B3VuaTFFRTgHdW5pMUVFOQd1bmkxRUVBB3VuaTFFRUIHdW5pMUVFQwd1bmkxRUVEB3VuaTFFRUUHdW5pMUVFRgd1bmkxRUYwB3VuaTFFRjEHdW5pMUVGNAd1bmkxRUY1B3VuaTFFRjYHdW5pMUVGNwd1bmkxRUY4B3VuaTFFRjkHdW5pMjBBQhNjaXJjdW1mbGV4YWN1dGVjb21iE2NpcmN1bWZsZXhncmF2ZWNvbWISY2lyY3VtZmxleGhvb2tjb21iE2NpcmN1bWZsZXh0aWxkZWNvbWIOYnJldmVhY3V0ZWNvbWIOYnJldmVncmF2ZWNvbWINYnJldmVob29rY29tYg5icmV2ZXRpbGRlY29tYhBjeXJpbGxpY2hvb2tsZWZ0EWN5cmlsbGljYmlnaG9va1VDB3VuaTAxNjIHdW5pMDE2Mwd1bmkwMUVBB3VuaTAxRUIHdW5pMDFFQwd1bmkwMUVEB3VuaTAyNTkNaG9va2Fib3ZlY29tYgd1bmkxRjREB3VuaTFGREUHdW5pMjA3MAd1bmkyMDc2B3VuaTIwNzkTdW5pMDNCOTAzMDgwMzA0MDMwMBN1bmkwM0I5MDMwODAzMDQwMzAxE3VuaTAzQjkwMzA4MDMwNjAzMDATdW5pMDNCOTAzMDgwMzA2MDMwMRN1bmkwM0M1MDMwODAzMDQwMzAwE3VuaTAzQzUwMzA4MDMwNDAzMDETdW5pMDNDNTAzMDgwMzA2MDMwMBN1bmkwM0M1MDMwODAzMDYwMzAxCEVuZy5hbHQxCEVuZy5hbHQyCEVuZy5hbHQzD3VuaTAzMDEwMzA2MDMwOA91bmkwMzAwMDMwNjAzMDgPdW5pMDMwMTAzMDQwMzA4D3VuaTAzMDAwMzA0MDMwOA9jeXJpbGxpY19vdG1hcmsDZl9mBWZfZl9pBWZfZl9sB3VuaTFFOUUHdW5pQTdCMwd1bmlBN0I0D3VuaTAxM0IubG9jbE1BSA91bmkwMTQ1LmxvY2xNQUgPQW9nb25lay5sb2NsTkFWD0VvZ29uZWsubG9jbE5BVg9Jb2dvbmVrLmxvY2xOQVYPVW9nb25lay5sb2NsTkFWBkkuc2FsdAZKLnNhbHQLSWdyYXZlLnNhbHQLSWFjdXRlLnNhbHQQSWNpcmN1bWZsZXguc2FsdA5JZGllcmVzaXMuc2FsdAtJdGlsZGUuc2FsdAxJbWFjcm9uLnNhbHQLSWJyZXZlLnNhbHQMSW9nb25lay5zYWx0FElvZ29uZWtfbG9jbE5BVi5zYWx0D0lkb3RhY2NlbnQuc2FsdAdJSi5zYWx0EEpjaXJjdW1mbGV4LnNhbHQMdW5pMUVDOC5zYWx0DHVuaTFFQ0Euc2FsdA5Jb3RhdG9ub3Muc2FsdAlJb3RhLnNhbHQRSW90YWRpZXJlc2lzLnNhbHQMdW5pMDQwNi5zYWx0DHVuaTA0MDcuc2FsdAx1bmkwNDA4LnNhbHQMdW5pMDRDMC5zYWx0B3VuaTAyMzcHdW5pQTdCNQd1bmlBQjUzC3VuaTAxMjMuYWx0D3VuaTAxM0MubG9jbE1BSA91bmkwMTQ2LmxvY2xNQUgPYW9nb25lay5sb2NsTkFWD2VvZ29uZWsubG9jbE5BVg9pb2dvbmVrLmxvY2xOQVYPdW9nb25lay5sb2NsTkFWBmcuc2FsdBBnY2lyY3VtZmxleC5zYWx0C2dicmV2ZS5zYWx0CWdkb3Quc2FsdAtmbG9yaW4uc3MwMw91bmkwNDMxLmxvY2xTUkIMdW5pMDRDRi5zYWx0B3VuaTIwOTUHdW5pMjA5Ngd1bmkyMDk3B3VuaTIwOTgHdW5pMjA5OQd1bmkyMDlBB3VuaTIwOUIHdW5pMjA5Qwd1bmkwNUQwB3VuaTA1RDEHdW5pMDVEMgd1bmkwNUQzB3VuaTA1RDQHdW5pMDVENQd1bmkwNUQ2B3VuaTA1RDcHdW5pMDVEOAd1bmkwNUQ5B3VuaTA1REEHdW5pMDVEQgd1bmkwNURDB3VuaTA1REQHdW5pMDVERQd1bmkwNURGB3VuaTA1RTAHdW5pMDVFMQd1bmkwNUUyB3VuaTA1RTMHdW5pMDVFNAd1bmkwNUU1B3VuaTA1RTYHdW5pMDVFNwd1bmkwNUU4B3VuaTA1RTkHdW5pMDVFQQd1bmlGQjJBB3VuaUZCMkIHdW5pRkIyQwd1bmlGQjJEB3VuaUZCMkUHdW5pRkIyRgd1bmlGQjMwB3VuaUZCMzEHdW5pRkIzMgd1bmlGQjMzB3VuaUZCMzQHdW5pRkIzNQd1bmlGQjM2B3VuaUZCMzgHdW5pRkIzOQd1bmlGQjNBB3VuaUZCM0IHdW5pRkIzQwd1bmlGQjNFB3VuaUZCNDAHdW5pRkI0MQd1bmlGQjQzB3VuaUZCNDQHdW5pRkI0Ngd1bmlGQjQ3B3VuaUZCNDgHdW5pRkI0OQd1bmlGQjRBB3VuaUZCNEIJZ3JhdmVjb21iCWFjdXRlY29tYgd1bmkwMzAyCXRpbGRlY29tYgd1bmkwMzA0B3VuaTAzMDYHdW5pMDMwNwd1bmkwMzA4B3VuaTAzMEEHdW5pMDMwQgd1bmkwMzBDB3VuaTAzMEYHdW5pMDMxMgxkb3RiZWxvd2NvbWIHdW5pMDMyNwd1bmkwMzI4B3VuaTA0ODUHdW5pMDQ4Ngd1bmkwNDgzB3VuaTA0ODQHdW5pMDVCMAd1bmkwNUIxB3VuaTA1QjIHdW5pMDVCMwd1bmkwNUI0B3VuaTA1QjUHdW5pMDVCNgd1bmkwNUI3B3VuaTA1QjgHdW5pMDVCOQd1bmkwNUJBB3VuaTA1QkIHdW5pMDVCQwd1bmkwNUJEB3VuaTA1QzEHdW5pMDVDMgd1bmkwNUM3CXplcm8uZG5vbQhvbmUuZG5vbQh0d28uZG5vbQp0aHJlZS5kbm9tCWZvdXIuZG5vbQlmaXZlLmRub20Ic2l4LmRub20Kc2V2ZW4uZG5vbQplaWdodC5kbm9tCW5pbmUuZG5vbQd6ZXJvLmxmBm9uZS5sZgZ0d28ubGYIdGhyZWUubGYHZm91ci5sZgdmaXZlLmxmBnNpeC5sZghzZXZlbi5sZghlaWdodC5sZgduaW5lLmxmCXplcm8ubnVtcghvbmUubnVtcgh0d28ubnVtcgp0aHJlZS5udW1yCWZvdXIubnVtcglmaXZlLm51bXIIc2l4Lm51bXIKc2V2ZW4ubnVtcgplaWdodC5udW1yCW5pbmUubnVtcgh6ZXJvLm9zZgdvbmUub3NmB3R3by5vc2YJdGhyZWUub3NmCGZvdXIub3NmCGZpdmUub3NmB3NpeC5vc2YJc2V2ZW4ub3NmCWVpZ2h0Lm9zZghuaW5lLm9zZgp6ZXJvLnNsYXNoCXplcm8udG9zZghvbmUudG9zZgh0d28udG9zZgp0aHJlZS50b3NmCWZvdXIudG9zZglmaXZlLnRvc2YIc2l4LnRvc2YKc2V2ZW4udG9zZgplaWdodC50b3NmCW5pbmUudG9zZgd1bmkyMDgwB3VuaTIwODEHdW5pMjA4Mgd1bmkyMDgzB3VuaTIwODQHdW5pMjA4NQd1bmkyMDg2B3VuaTIwODcHdW5pMjA4OAd1bmkyMDg5B3VuaTA1QkUHdW5pMjA3RAd1bmkyMDhEB3VuaTIwN0UHdW5pMjA4RQd1bmkyMDdBB3VuaTIwN0MHdW5pMjA4QQd1bmkyMDhDB3VuaTIyMTUHdW5pMjBBQQd1bmkyMTIwEGFmaWkxMDEwM2RvdGxlc3MQYWZpaTEwMTA1ZG90bGVzcwxjb21tYWFjY2VudDIOaW9nb25la2RvdGxlc3MOdW5pMUVDQmRvdGxlc3MAAAABAAMACAAKAA0AB///AA8AAQAC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Y2NtcALGY2NtcALaZG5vbQIaZnJhYwLQbGlnYQIgbG51bQImbG9jbAIsbG9jbAIybG9jbAI4bG9jbAI+bG9jbAJEbG9jbAJKbG9jbAJQbG9jbAJWbG9jbAJcbnVtcgJib251bQJob3JkbgJucG51bQJ0c2FsdAK0c3MwMQK0c3MwMgJ6c3MwMwKAc3MwNAKGc3VicwKMc3VwcwKSdG51bQKYemVybwKeAowAAAIwAAACWAAAAoAAAk1LRCACrFNSQiAC2gRkAAdBUFBIBJBDQVQgBL5JUFBIBOxNQUggBRpNT0wgBUhOQVYgBXZST00gBaQAAQAAAAEHIAADAAAAAQayAAEAAAABA14ABAAAAAEEBAAEAAAAAQLyAAQAAAABA9wAAQAAAAEDqgABAAAAAQLuAAEAAAABAvQABgAAAAEC1AAEAAAAAQKqAAQAAAABAqoAAQAAAAEC4gABAAAAAQJiAAEAAAABBeIAAQAAAAEFLAABAAAAAQJQAAEAAAABAk4AAQAAAAECTAABAAAAAQJKAAEAAAABArAAAQAAAAECQAABAAAAAQUYAAEAAAABBT4AAQAAAAEFZAAEAAAAAQJCAAEAAAABAh4AAQAAAAEChgABAAAAAQWkAAEAAAABAgwABgAAAAICkAMAAAYAAAACApgCqgAGAAAAAgKyAsQAAAABABYAAAABACIAAAABAB4AAAABABAAAAABAAwAAAABAA8AAAABAAsAAAABABIAAAABAAkAAAABAAgAAAABAAoAAAABABEAAAABABUAAAABACEAAAABABwAAAABAB8AAAABACQAAAABACUAAAABACYAAAABABMAAAABABQAAAABACAAAAABACMAAAACAAAAAQAAAAIAAgAFAAAAAgAkACUAAAADAAIABQAGAAAAAwACAAUABwAAAAMAFwAYABkAAAAEAAIABQACAAUAAAAGAAIABQACAAUAAgAFAAD//wATAAAAAwAGAAcACAAJABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AAP//ABMAAAAEAAYABwAIAAkAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAA//8AEwAAAAEABgAHAAgACQATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfAAD//wAUAAAAAQAGAAcACAAJAA4AEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAA//8AFAAAAAEABgAHAAgACQASABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AAQTwAfUAAQUmBBMAAQTqAgQAAQUaBCcAAQUK/+wAAQT6/+wAAQTYBDsAAQTYAn0AAQkkAAEE2AABCSgAAQTUAAEJSAABBP4AAQm2AAIFAgUMAAEE5AACBL4EwgACBQIABAFIAUkBIwEkAAIFAAAEA5IDtAOTA7UAAgT+AAQDkQOQA7EDsgACBPwABABsAHwAbAB8AAIFNAAFA7oDuwO8A70DswACBWgABgOvA7AEcgRvBHAEcwADAAAAAQVWAAEFcgABAAAAAwADAAEExgABBFoAAAABAAAAGgADAAEE/AABBEgAAAABAAAAGwADAAEEQAABBKgAAAABAAAAHQADAAEELgABBJ4AAAABAAAAHQACBSgACAOUA7YDlQO3A5YDuAOXA7kAAwAAAAEE5gACBPYFAgABAAAABAABCQIACQRqBG4EcgR2BHoEfgSCBIYEigABCUwACgSOBJIElgSuBJoEngSiBKYEtASqAAD//wATAAAABQAGAAcACAAJABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AAP//ABQAAAABAAYABwAIAAkACgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfAAD//wAUAAAAAgAGAAcACAAJAAsAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAA//8AFAAAAAEABgAHAAgACQAMABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AAP//ABQAAAACAAYABwAIAAkADQATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfAAD//wAUAAAAAgAGAAcACAAJAA8AEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAA//8AFAAAAAIABgAHAAgACQAQABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AAP//ABQAAAACAAYABwAIAAkAEQATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfAAIDogAPBGQEZgRoA3cAewB0AHUCNwI4A3gCOQI6A3kEaQIXAAIDTgAUBDAEMQQyBDMENAQ1BDYENwQ4BDkERARFBEYERwRIBEkESgRLBEwETQACAzAAFAATABQAFQAWABcAGAAZABoAGwAcBE8EUARR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";

// igc2kmz/color.ts
var RGB = class {
  constructor(r, g, b) {
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.r = r;
    this.g = g;
    this.b = b;
  }
  static fromByteValue(r, g, b, a) {
    return new RGB(r / 255, g / 255, b / 255);
  }
  static validColor(color) {
    let reg_rgba = /^#?([\da-f]{6}(?:[\da-f]{2})?)$/;
    color = (color ?? "").trim().toLowerCase();
    let match = color.match(reg_rgba);
    if (!match || match.length <= 1) {
      return null;
    }
    return match[1];
  }
  static fromRGBHexString(color) {
    color = RGB.validColor(color);
    if (!color) {
      return null;
    }
    return RGB.fromByteValue(parseInt(color.substring(0, 2), 16), parseInt(color.substring(2, 4), 16), parseInt(color.substring(4, 6), 16));
  }
  toHexString() {
    return ("0" + Math.trunc(255 * this.b).toString(16)).substr(-2) + ("0" + Math.trunc(255 * this.g).toString(16)).substr(-2) + ("0" + Math.trunc(255 * this.r).toString(16)).substr(-2);
  }
  toRGBString() {
    return `rgb(${Math.trunc(255 * this.r)},${Math.trunc(255 * this.g)},${Math.trunc(255 * this.b)})`;
  }
};
__name(RGB, "RGB");
var RGBA = class extends RGB {
  constructor(r, g, b, a) {
    super(r, g, b);
    this.a = 0;
    this.a = a;
  }
  static fromByteValue(r, g, b, a) {
    return new RGBA(r / 255, g / 255, b / 255, a / 255);
  }
  static fromRGBAHexString(color) {
    color = RGB.validColor(color);
    if (!color) {
      return null;
    }
    let alpha = 1;
    if (color.length == 8) {
      alpha = parseInt(color.substring(6, 8), 16);
    }
    return RGBA.fromByteValue(parseInt(color.substring(0, 2), 16), parseInt(color.substring(2, 4), 16), parseInt(color.substring(4, 6), 16), alpha);
  }
  toHexString() {
    return ("0" + Math.trunc(255 * this.a).toString(16)).substr(-2) + super.toHexString();
  }
  toRGBAString() {
    return `rgba(${Math.trunc(255 * this.r)},${Math.trunc(255 * this.g)},${Math.trunc(255 * this.b)},${Math.trunc(255 * this.a)})`;
  }
};
__name(RGBA, "RGBA");
function h_to_value(p, q, t) {
  if (t < 0) {
    t++;
  } else if (1 < t) {
    t--;
  }
  if (t < 1 / 6) {
    return p + 6 * (q - p) * t;
  } else if (t < 0.5) {
    return q;
  } else if (t < 2 / 3) {
    return p + 6 * (q - p) * (2 / 3 - t);
  } else {
    return p;
  }
}
__name(h_to_value, "h_to_value");
function hsl_to_rgba(h, s, l, a = 1) {
  if (s == 0) {
    return new RGBA(1, 1, 1, a);
  }
  let q;
  if (l < 0.5) {
    q = l * (s + 1);
  } else {
    q = l + s - l * s;
  }
  let p = 2 * l - q;
  let r = h_to_value(p, q, h + 1 / 3);
  let g = h_to_value(p, q, h);
  let b = h_to_value(p, q, h - 1 / 3);
  return new RGBA(r, g, b, a);
}
__name(hsl_to_rgba, "hsl_to_rgba");
function default_gradient(value) {
  let h;
  if (value < 0) {
    return hsl_to_rgba(2 / 3, 1, 0.5);
  } else if (1 <= value) {
    return hsl_to_rgba(0, 1, 0.5);
  } else {
    h = 2 * (1 - value) / 3;
    return hsl_to_rgba(h, 1, 0.5);
  }
}
__name(default_gradient, "default_gradient");
function bilinear_gradient(value) {
  let h;
  if (value < 0) {
    h = 2 / 3;
  } else if (value < 0.5) {
    h = (6 - 4 * value) / 9;
  } else if (value == 0.5) {
    h = 1 / 3;
  } else if (value < 1) {
    h = (4 - 4 * value) / 9;
  } else {
    h = 0;
  }
  return hsl_to_rgba(h, 1, 0.5);
}
__name(bilinear_gradient, "bilinear_gradient");

// igc2kmz/util.ts
var SEALEVEL_QNH = 1013.25;
var Bounds = class {
  constructor(value) {
    if (value instanceof Bounds) {
      this.min = value.min;
      this.max = value.max;
    } else if (value instanceof Array) {
      if (value.length == 2) {
        this.min = value[0];
        this.max = value[1];
      } else {
        this.min = value[0];
        this.max = value[0];
        for (let i = 0; i < value.length; i++) {
          if (value[i] < this.min)
            this.min = value[i];
          if (value[i] > this.max)
            this.max = value[i];
        }
      }
    } else {
      this.min = value;
      this.max = value;
    }
  }
  static createbounds(value) {
    if (value instanceof Array && value.length == 0) {
      return null;
    } else if (value == null) {
      return null;
    }
    return new Bounds(value);
  }
  update(value) {
    if (value instanceof Bounds) {
      if (value.min < this.min)
        this.min = value.min;
      if (value.max > this.max)
        this.max = value.max;
    } else {
      if (value < this.min)
        this.min = value;
      if (value > this.max)
        this.max = value;
    }
  }
  tuple() {
    return [this.min, this.max];
  }
};
__name(Bounds, "Bounds");
function bsupdate(bs, other) {
  for (let key in other) {
    if (bs.hasOwnProperty(key)) {
      bs[key]?.update(other[key]);
    } else {
      bs[key] = new Bounds(other[key]);
    }
  }
}
__name(bsupdate, "bsupdate");
function round(n, digits = 0) {
  digits = digits ? digits * 10 : 1;
  return Math.round(n * digits) / digits;
}
__name(round, "round");
function add_seconds(dt, seconds) {
  return new Date(dt.getTime() + seconds * 1e3);
}
__name(add_seconds, "add_seconds");
var Utils = class {
  static incr_douglas_peucker(x, y, epsilon, max_indexes = Number.MAX_SAFE_INTEGER) {
    let indexes = [0];
    let queue = [[0, x.length - 1]];
    let i = 0, left = 0, right = 0, kx = 0, ky = 0, c = 0, pivot = 0, max_dist = 0, dist = 0;
    while (i < queue.length) {
      left = queue[i][0];
      right = queue[i][1];
      i++;
      indexes.push(right);
      if (indexes.length == max_indexes)
        break;
      kx = y[left] - y[right];
      ky = x[right] - x[left];
      c = x[left] * y[right] - x[right] * y[left];
      pivot = left + 1;
      max_dist = Math.abs(kx * x[pivot] + ky * y[pivot] + c);
      for (let j = left + 2; j < right; j++) {
        dist = Math.abs(kx * x[j] + ky * y[j] + c);
        if (dist > max_dist) {
          max_dist = dist;
          pivot = j;
        }
      }
      max_dist /= Math.sqrt(Math.pow(x[right] - x[left], 2) + Math.pow(y[right] - y[left], 2));
      if (max_dist > epsilon) {
        indexes.push(pivot);
        if (indexes.length == max_indexes)
          break;
        queue.push([left, pivot]);
        queue.push([pivot, right]);
      }
    }
    return indexes.sort(function(a, b) {
      return a - b;
    });
  }
  static find_first_ge(seq, value) {
    let left = 0;
    let right = seq.length;
    while (left < right) {
      let middle = Math.trunc((left + right) / 2);
      let direction = value - seq[middle];
      if (direction <= 0) {
        right = middle;
      } else {
        left = middle + 1;
      }
    }
    if (left == seq.length) {
      return null;
    } else {
      return right;
    }
  }
  static runs(seq) {
    let indexes = [];
    let start = 0, index = 0;
    let current = seq[0];
    let element;
    for (index = 0; index < seq.length; index++) {
      element = seq[index];
      if (element != current) {
        indexes.push({ start, stop: index });
        start = index;
        current = element;
      }
    }
    indexes.push({ start, stop: index });
    return indexes;
  }
  static runs_where(seq) {
    let indexes = [];
    let start = 0, index = 0;
    let current = seq[0];
    let element;
    for (index = 0; index < seq.length; index++) {
      element = seq[index];
      if (element != current) {
        if (current) {
          indexes.push({ start, stop: index });
        }
        start = index;
        current = element;
      }
    }
    if (current) {
      indexes.push({ start, stop: index });
    }
    return indexes;
  }
  static condense(ranges, t, delta) {
    let indexes = [];
    if (ranges.length > 0) {
      let sl = ranges[0];
      let start = sl.start;
      let stop = sl.stop;
      for (let i = 0; i < ranges.length; i++) {
        sl = ranges[i];
        if (t[sl.start] - t[stop] < delta) {
          stop = sl.stop;
        } else {
          indexes.push({ start, stop });
          start = sl.start;
          stop = sl.stop;
        }
      }
      indexes.push({ start, stop });
    }
    return indexes;
  }
  // calculate altitude from given pressure and pressure at sea level
  static getAltitude(pressure, seaLevelPressure = SEALEVEL_QNH) {
    return 44330 * (1 - Math.pow(pressure / seaLevelPressure, 0.1902949));
  }
  // calculate pressure from given altitude and pressure at sea level
  static getPressure(altitude, seaLevelPressure = SEALEVEL_QNH) {
    return seaLevelPressure * Math.pow(1 - altitude / 44330, 5.2550015);
  }
  // Calculate sea level from Pressure given on specific altitude
  static getSeaLevel(pressure, altitude) {
    return pressure / Math.pow(1 - altitude / 44330, 5.2550016);
  }
  static hashcode(value) {
    for (var i = 0, h = 0; i < value.length; i++)
      h = Math.imul(31, h) + value.charCodeAt(i) | 0;
    return h;
  }
  static datediffsecs(dt1, dt2) {
    if (dt1 > dt2) {
      return (dt1.getTime() - dt2.getTime()) / 1e3;
    } else {
      return (dt1.getTime() + 864e5 - dt2.getTime()) / 1e3;
    }
  }
  static salient2(seq, epsilons) {
    let result = [];
    let helper = /* @__PURE__ */ __name((start, stop) => {
      if (stop - start < 2)
        return;
      let delta = 0;
      let left = start, right = stop;
      if (seq[start] <= seq[stop]) {
        let max_index = start;
        for (let i = start + 1; i < stop; i++) {
          if (seq[i] > seq[max_index]) {
            max_index = i;
          } else if (seq[max_index] - seq[i] > delta) {
            left = max_index;
            right = i;
            delta = seq[max_index] - seq[i];
          }
        }
      }
      if (seq[start] >= seq[stop]) {
        let min_index = start;
        for (let i = start + 1; i < stop; i++) {
          if (seq[i] < seq[min_index]) {
            min_index = i;
          } else if (seq[i] - seq[min_index] > delta) {
            left = min_index;
            right = i;
            delta = seq[i] - seq[min_index];
          }
        }
      }
      if (delta >= epsilons[epsilons.length - 1] && (left != start || right != stop)) {
        for (let i = 0, epsilon = epsilons[0]; i < epsilons.length; i++, epsilon = epsilons[i]) {
          if (delta < epsilon)
            continue;
          if (!result.hasOwnProperty(left) || result[left] > i) {
            result[left] = i;
          }
          if (!result.hasOwnProperty(right) || result[right] > i) {
            result[right] = i;
          }
        }
        helper(start, left);
        helper(left, right);
        helper(right, stop);
      }
    }, "helper");
    if (seq.length > 0) {
      result[0] = 0;
      result[seq.length - 1] = 0;
      helper(0, seq.length - 1);
    }
    return result;
  }
  static seconds_to_date(sec) {
    return new Date(sec * 1e3);
  }
  static datetime_floor(dt, delta) {
    dt = new Date(dt.getTime());
    if (delta >= 3600) {
      dt.setMinutes(0);
      dt.setSeconds(0);
      return new Date(dt.getTime() - 36e5 * (dt.getHours() % Math.trunc(delta / 3600)));
    } else if (delta >= 60) {
      dt.setSeconds(0);
      return new Date(dt.getTime() - 6e4 * (dt.getMinutes() % Math.trunc(delta / 60)));
    } else if (delta >= 1) {
      return new Date(dt.getTime() - 1e3 * (dt.getSeconds() % Math.trunc(delta)));
    }
    return dt;
  }
  static make_table(rows, bgcolors = ["#dddddd", "#ffffff"]) {
    let result = '<table cellpadding="1" cellspacing="1">';
    rows.forEach((row, i) => {
      result += `<tr bgcolor="${bgcolors[i % 2]}"><th align="right">${row[0]}</th><td>${row[1]}</td></tr>`;
    });
    result += "</table>";
    return result;
  }
  static capitalizeFirstLetter(str) {
    str = str ?? "";
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  static roundToFloor(numToRound, numToRoundTo) {
    return Math.floor(numToRound / numToRoundTo) * numToRoundTo;
  }
  static roundToCeil(numToRound, numToRoundTo) {
    return Math.ceil(numToRound / numToRoundTo) * numToRoundTo;
  }
};
__name(Utils, "Utils");
var RandomIdGenerator = class {
  static id(length) {
    let result = "";
    const charactersLength = this.characters.length;
    let counter = 0;
    while (counter < length) {
      result += this.characters.charAt(Math.floor(Math.random() * charactersLength));
      counter += 1;
    }
    return result;
  }
  static factorial(n) {
    if (n == 0 || n == 1)
      return 1;
    if (this.factorials[n] > 0)
      return this.factorials[n];
    return this.factorials[n] = this.factorial(n - 1) * n;
  }
  static combinaisons() {
    const n = this.characters.length;
    return this.factorial(n + this.len - 1) / (this.factorial(this.len) * this.factorial(n - 1));
  }
  static reset(len) {
    this.len = typeof len === "number" && len > 0 ? len : 1;
    this.ids = [];
  }
  static makeid(len) {
    if (typeof len === "number" && len > 0) {
      this.len = len;
    }
    let id;
    while (this.combinaisons() <= this.ids.length)
      this.len++;
    let counter = 0;
    do {
      id = this.id(this.len);
      counter++;
    } while (counter < this.maxretry && this.ids.some((_) => _ == id));
    if (counter == this.maxretry) {
      this.len++;
      return this.makeid();
    }
    this.ids.push(id);
    return "_" + id;
  }
};
__name(RandomIdGenerator, "RandomIdGenerator");
RandomIdGenerator.ids = [];
RandomIdGenerator.len = 1;
RandomIdGenerator.characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
RandomIdGenerator.factorials = [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800, 87178291200, 1307674368e3, 20922789888e3, 355687428096e3, 6402373705728e3, 121645100408832e3, 243290200817664e4, 5109094217170944e4, 11240007277776077e5, 2585201673888498e7, 6204484017332394e8, 15511210043330986e9, 40329146112660565e10, 10888869450418352e12, 30488834461171387e13, 8841761993739702e15, 26525285981219107e16, 8222838654177922e18, 2631308369336935e20, 8683317618811886e21, 29523279903960416e22, 10333147966386145e24, 37199332678990125e25, 13763753091226346e27, 5230226174666011e29, 20397882081197444e30, 8159152832478977e32, 3345252661316381e34, 140500611775288e37, 6041526306337383e37, 2658271574788449e39, 11962222086548019e40, 5502622159812089e42, 25862324151116818e43, 12413915592536073e45, 6082818640342675e47, 30414093201713376e48, 15511187532873822e50, 8065817517094388e52, 42748832840600255e53, 2308436973392414e56, 12696403353658276e57, 7109985878048635e59, 40526919504877214e60, 23505613312828785e62, 13868311854568984e64, 832098711274139e67, 5075802138772248e68, 3146997326038794e70, 198260831540444e73, 12688693218588417e73, 8247650592082472e75, 5443449390774431e77, 3647111091818868e79, 24800355424368305e80, 1711224524281413e83, 11978571669969892e84, 8504785885678623e86, 61234458376886085e87, 44701154615126844e89, 3307885441519386e92, 248091408113954e95, 18854947016660504e95, 14518309202828587e97, 11324281178206297e99, 8946182130782976e101, 7156945704626381e103, 5797126020747368e105, 4753643337012842e107, 3945523969720659e109, 3314240134565353e111, 281710411438055e114, 24227095383672734e114, 2107757298379528e117, 18548264225739844e118, 1650795516090846e121, 14857159644817615e122, 1352001527678403e125, 12438414054641308e126, 11567725070816416e128, 1087366156656743e131, 1032997848823906e133, 9916779348709496e134, 9619275968248212e136, 9426890448883248e138, 9332621544394415e140, 9332621544394415e142];
RandomIdGenerator.maxretry = 20;

// igc2kmz/kml.ts
var KML;
((_KML) => {
  class Attribute {
    constructor(name, value2) {
      this.name = "";
      this.value = "";
      this.name = name;
      this.value = value2;
    }
  }
  __name(Attribute, "Attribute");
  class Namespace extends Attribute {
    constructor(name, uri, defaultns = false) {
      if (defaultns === true)
        name = null;
      super(name ?? "", uri);
      this.defaultns = false;
      this.defaultns = name == null || defaultns;
    }
    get uri() {
      return this.value;
    }
  }
  __name(Namespace, "Namespace");
  const SPACES_INDENT = 2;
  class Element {
    constructor(name, nsprefix = null) {
      this.namespaces = {};
      this.name = "";
      this.nsprefix = null;
      this.attributes = [];
      this.id = "";
      this.name = name ?? this.constructor.name;
      this.nsprefix = nsprefix;
    }
    get Id() {
      if ((this.id ?? "").trim().length > 0) {
        return this.id;
      }
      this.id = RandomIdGenerator.makeid(5);
      this.add_attr("id", this.id);
      return this.id;
    }
    get url() {
      return "#" + this.Id;
    }
    add_ns(name, uri) {
      this.namespaces[name ?? "default"] = new Namespace(name, uri);
      ;
    }
    add_attr(name, value2) {
      this.attributes.push(new Attribute(name, value2));
    }
    serialize(indent = false, level = 0) {
      let name = ((this.nsprefix ?? "").trim().length > 0 ? this.nsprefix + ":" : "") + this.name;
      let result = (indent ? " ".repeat(level * SPACES_INDENT) : "") + "<" + name;
      for (let key in this.namespaces) {
        let nskey = "";
        if (!this.namespaces[key].defaultns) {
          nskey = ":" + this.namespaces[key].name;
        }
        result += ` xmlns${nskey}="${this.namespaces[key].uri}"`;
      }
      for (let i = 0; i < this.attributes.length; i++) {
        result += ` ${this.attributes[i].name}="${this.attributes[i].value}"`;
      }
      result += "></" + name + ">";
      return result;
    }
  }
  __name(Element, "Element");
  _KML.Element = Element;
  class Comment extends Element {
    constructor(text2) {
      super();
      this.text = text2 ?? "";
    }
    serialize(indent, level) {
      return `<!--${this.text}-->`;
    }
  }
  __name(Comment, "Comment");
  _KML.Comment = Comment;
  class CompoundElement extends Element {
    constructor(childs = []) {
      super();
      this.childs = [];
      this.childs = childs;
    }
    add(child) {
      this.childs.push(child);
    }
    prefixes() {
      let prefixes = [];
      if (this.childs && this.childs.length > 0) {
        for (let i = 0; i < this.childs.length; i++) {
          if ((this.childs[i].nsprefix ?? "").trim().length > 0 && !prefixes.some((p) => p == this.childs[i].nsprefix))
            prefixes.push(this.childs[i].nsprefix ?? "");
          if (this.childs[i] instanceof CompoundElement)
            this.childs[i].prefixes().forEach((p) => {
              if (!prefixes.some((p0) => p0 == p))
                prefixes.push(p);
            });
        }
      }
      return prefixes;
    }
    serialize(indent = false, level = 0) {
      let name = ((this.nsprefix ?? "").trim().length > 0 ? this.nsprefix + ":" : "") + this.name;
      let result = (indent ? " ".repeat(level * SPACES_INDENT) : "") + "<" + name;
      for (let key in this.namespaces) {
        let nskey = ":" + key;
        if (this.namespaces[key].defaultns) {
          nskey = "";
        }
        result += ` xmlns${nskey}="${this.namespaces[key].uri}"`;
      }
      for (let i = 0; i < this.attributes.length; i++) {
        result += ` ${this.attributes[i].name}="${this.attributes[i].value}"`;
      }
      if (this.childs.length == 0) {
        result += "/>" + (indent ? "\n" : "");
      } else {
        result += ">" + (indent ? "\n" : "");
        for (let i = 0; i < this.childs.length; i++) {
          result += this.childs[i].serialize(indent, level + 1) + (indent ? "\n" : "");
        }
        result += (indent ? " ".repeat(level * SPACES_INDENT) : "") + "</" + name + ">";
      }
      return result;
    }
  }
  __name(CompoundElement, "CompoundElement");
  _KML.CompoundElement = CompoundElement;
  class SimpleElement extends Element {
    constructor(name, content) {
      super(name);
      this.content = content ?? "";
    }
    serialize(indent = false, level = 0) {
      let name = ((this.nsprefix ?? "").trim().length > 0 ? this.nsprefix + ":" : "") + this.name;
      let result = (indent ? " ".repeat(level * SPACES_INDENT) : "") + "<" + name;
      for (let key in this.namespaces) {
        let nskey = ":" + key;
        if (this.namespaces[key].defaultns) {
          nskey = "";
        }
        result += ` xmlns${nskey}="${this.namespaces[key].uri}"`;
      }
      for (let i = 0; i < this.attributes.length; i++) {
        result += ` ${this.attributes[i].name}="${this.attributes[i].value}"`;
      }
      if ((this.content ?? "").trim().length == 0) {
        result += "/>";
      } else {
        result += ">" + this.content + "</" + name + ">";
      }
      return result;
    }
  }
  __name(SimpleElement, "SimpleElement");
  _KML.SimpleElement = SimpleElement;
  class CDATA extends SimpleElement {
    constructor(name, content) {
      super(name, `<![CDATA[${content}]]>`);
    }
  }
  __name(CDATA, "CDATA");
  _KML.CDATA = CDATA;
  class altitude extends SimpleElement {
  }
  __name(altitude, "altitude");
  _KML.altitude = altitude;
  class altitudeMode extends SimpleElement {
    constructor(altitude_mode) {
      super(void 0, altitude_mode);
    }
  }
  __name(altitudeMode, "altitudeMode");
  _KML.altitudeMode = altitudeMode;
  class BalloonStyle extends CompoundElement {
  }
  __name(BalloonStyle, "BalloonStyle");
  _KML.BalloonStyle = BalloonStyle;
  class begin extends SimpleElement {
  }
  __name(begin, "begin");
  _KML.begin = begin;
  class bgColor extends SimpleElement {
  }
  __name(bgColor, "bgColor");
  _KML.bgColor = bgColor;
  class Camera extends CompoundElement {
    constructor(coord, heading2, tilt2) {
      super([
        new SimpleElement("altitude", coord.ele.toString()),
        new SimpleElement("heading", heading2.toString()),
        new SimpleElement("latitude", coord.lat_deg.toString()),
        new SimpleElement("longitude", coord.lon_deg.toString()),
        new SimpleElement("tilt", tilt2.toString())
      ]);
    }
  }
  __name(Camera, "Camera");
  _KML.Camera = Camera;
  class color extends SimpleElement {
    constructor(rgba) {
      if (rgba instanceof RGBA) {
        super(void 0, rgba.toHexString());
      } else {
        super(void 0, rgba);
      }
    }
  }
  __name(color, "color");
  _KML.color = color;
  class coordinates extends SimpleElement {
    constructor(coord) {
      if (!Array.isArray(coord)) {
        coord = [coord];
      }
      super(void 0, coord.map((c) => `${c.lon_deg},${c.lat_deg},${c.ele}`).join(" "));
    }
    static circle(center, radius, ele, error = 0.1) {
      let decimation = Math.ceil(Math.PI / Math.acos((radius - error) / (radius + error)));
      let coords = [];
      for (let i = 0; i < decimation + 1; i++) {
        let coord = center.coord_at(-2 * Math.PI * i / decimation, radius + error);
        if (typeof ele === "number") {
          coord.ele = ele;
        }
        coords.push(coord);
      }
      return coords;
    }
  }
  __name(coordinates, "coordinates");
  _KML.coordinates = coordinates;
  class Data extends CompoundElement {
    constructor(name, value2) {
      super([new SimpleElement("value", value2.toString())]);
      this.add_attr("name", name);
    }
  }
  __name(Data, "Data");
  _KML.Data = Data;
  class description extends SimpleElement {
  }
  __name(description, "description");
  _KML.description = description;
  class Document extends CompoundElement {
  }
  __name(Document, "Document");
  _KML.Document = Document;
  class end extends SimpleElement {
  }
  __name(end, "end");
  _KML.end = end;
  class ExtendedData extends CompoundElement {
    constructor(dict) {
      super([]);
      for (let prop in dict)
        this.add(new Data(prop, dict[prop]));
    }
  }
  __name(ExtendedData, "ExtendedData");
  _KML.ExtendedData = ExtendedData;
  class extrude extends SimpleElement {
  }
  __name(extrude, "extrude");
  _KML.extrude = extrude;
  class Folder extends CompoundElement {
    constructor(name, style_url = null, childs = null, isopen = null, isvisible = null) {
      childs = childs ?? [];
      if (isopen != null) {
        childs.unshift(new open(isopen));
      }
      if (isvisible != null) {
        childs.unshift(new visibility(isvisible));
      }
      if (name != null) {
        childs.unshift(new SimpleElement("name", name));
      }
      if (style_url != null) {
        childs.push(new styleUrl(style_url));
      }
      super(childs);
    }
  }
  __name(Folder, "Folder");
  _KML.Folder = Folder;
  class heading extends SimpleElement {
  }
  __name(heading, "heading");
  _KML.heading = heading;
  class href extends SimpleElement {
  }
  __name(href, "href");
  _KML.href = href;
  class Icon extends CompoundElement {
    static palette(pal, icon, extra = "") {
      return new Icon([new SimpleElement("href", `http://maps.google.com/mapfiles/kml/pal${pal}/icon${icon}${extra}.png`)]);
    }
  }
  __name(Icon, "Icon");
  _KML.Icon = Icon;
  class IconStyle extends CompoundElement {
  }
  __name(IconStyle, "IconStyle");
  _KML.IconStyle = IconStyle;
  class KML2 extends CompoundElement {
    constructor(version, child) {
      super([child]);
      this.name = "kml";
      this.add_ns(null, "http://earth.google.com/kml/" + version.toString());
      this.add_ns("gx", "http://www.google.com/kml/ext/" + version.toString());
    }
    serialize(indent = false, level = 0) {
      let usedprefixes = this.prefixes();
      for (let key in this.namespaces) {
        if (!this.namespaces[key].name)
          continue;
        if (!usedprefixes.includes(this.namespaces[key].name))
          delete this.namespaces[key];
      }
      return '<?xml version="1.0" encoding="UTF-8"?>\n' + super.serialize(indent, level);
    }
  }
  __name(KML2, "KML");
  _KML.KML = KML2;
  class LabelStyle extends CompoundElement {
    constructor(colorval, scaleval, colorMode) {
      super();
      if (colorval) {
        this.add(new color(colorval));
      }
      if (colorMode) {
        this.add(new SimpleElement("colorMode", colorMode));
      }
      if (scaleval) {
        this.add(new scale(scaleval.toString()));
      }
    }
  }
  __name(LabelStyle, "LabelStyle");
  _KML.LabelStyle = LabelStyle;
  class latitude extends SimpleElement {
  }
  __name(latitude, "latitude");
  _KML.latitude = latitude;
  class LineString extends CompoundElement {
    constructor(coords, altitude_mode, istessellate) {
      super();
      if (altitude_mode) {
        this.add(new altitudeMode(altitude_mode));
      }
      if (typeof istessellate === "boolean") {
        this.add(new tessellate(istessellate));
      }
      this.add(new coordinates(coords));
    }
  }
  __name(LineString, "LineString");
  _KML.LineString = LineString;
  class LineStyle extends CompoundElement {
    constructor(colorval, width2) {
      super([new color(colorval), new SimpleElement("width", width2.toString())]);
    }
  }
  __name(LineStyle, "LineStyle");
  _KML.LineStyle = LineStyle;
  class ListStyle extends CompoundElement {
    constructor(listItemType2) {
      super([new SimpleElement("listItemType", listItemType2)]);
    }
  }
  __name(ListStyle, "ListStyle");
  _KML.ListStyle = ListStyle;
  class listItemType extends SimpleElement {
  }
  __name(listItemType, "listItemType");
  _KML.listItemType = listItemType;
  class longitude extends SimpleElement {
  }
  __name(longitude, "longitude");
  _KML.longitude = longitude;
  class MultiGeometry extends CompoundElement {
  }
  __name(MultiGeometry, "MultiGeometry");
  _KML.MultiGeometry = MultiGeometry;
  class open extends SimpleElement {
    constructor(isopen) {
      super("open", isopen ? "1" : "0");
    }
  }
  __name(open, "open");
  _KML.open = open;
  class overlayXY extends SimpleElement {
    constructor(x, xunits, y, yunits) {
      super();
      this.add_attr("x", x.toString());
      this.add_attr("y", y.toString());
      this.add_attr("xunits", xunits);
      this.add_attr("yunits", yunits);
    }
  }
  __name(overlayXY, "overlayXY");
  _KML.overlayXY = overlayXY;
  class Placemark extends CompoundElement {
    constructor(name = null, coord = null, childs = null, style_url = null, isopen = null, isvisible = null) {
      childs = childs ?? [];
      if (isopen != null) {
        childs.unshift(new open(isopen));
      }
      if (isvisible != null) {
        childs.unshift(new visibility(isvisible));
      }
      if (coord) {
        childs.unshift(coord);
      }
      if (style_url) {
        childs.unshift(new styleUrl(style_url));
      }
      if (name) {
        childs.unshift(new SimpleElement("name", name));
      }
      super(childs);
    }
  }
  __name(Placemark, "Placemark");
  _KML.Placemark = Placemark;
  class Point extends CompoundElement {
    constructor(coord, altitude_mode) {
      super();
      if (altitude_mode) {
        this.add(new altitudeMode(altitude_mode));
      }
      this.add(new coordinates(coord));
    }
  }
  __name(Point, "Point");
  _KML.Point = Point;
  class PolyStyle extends CompoundElement {
  }
  __name(PolyStyle, "PolyStyle");
  _KML.PolyStyle = PolyStyle;
  class roll extends SimpleElement {
  }
  __name(roll, "roll");
  _KML.roll = roll;
  class scale extends SimpleElement {
    constructor(content) {
      super(void 0, content);
    }
  }
  __name(scale, "scale");
  _KML.scale = scale;
  class ScreenOverlay extends CompoundElement {
  }
  __name(ScreenOverlay, "ScreenOverlay");
  _KML.ScreenOverlay = ScreenOverlay;
  class screenXY extends overlayXY {
  }
  __name(screenXY, "screenXY");
  _KML.screenXY = screenXY;
  class size extends overlayXY {
  }
  __name(size, "size");
  _KML.size = size;
  class Snippet extends SimpleElement {
    constructor(text2) {
      super(void 0, text2);
    }
  }
  __name(Snippet, "Snippet");
  _KML.Snippet = Snippet;
  class Style extends CompoundElement {
  }
  __name(Style, "Style");
  _KML.Style = Style;
  class styleUrl extends SimpleElement {
    constructor(text2) {
      super(void 0, text2);
    }
  }
  __name(styleUrl, "styleUrl");
  _KML.styleUrl = styleUrl;
  class tessellate extends SimpleElement {
    constructor(te) {
      super(void 0, te ? "1" : "0");
    }
  }
  __name(tessellate, "tessellate");
  _KML.tessellate = tessellate;
  class text extends SimpleElement {
  }
  __name(text, "text");
  _KML.text = text;
  class tilt extends SimpleElement {
  }
  __name(tilt, "tilt");
  _KML.tilt = tilt;
  class TimeSpan extends CompoundElement {
    constructor(begin2, end2) {
      super();
      if (begin2 != null) {
        this.add(new SimpleElement("begin", begin2.toISOString()));
      }
      if (end2 != null) {
        this.add(new SimpleElement("end", end2.toISOString()));
      }
    }
  }
  __name(TimeSpan, "TimeSpan");
  _KML.TimeSpan = TimeSpan;
  class value extends SimpleElement {
  }
  __name(value, "value");
  _KML.value = value;
  class visibility extends SimpleElement {
    constructor(visibility2) {
      super(void 0, visibility2 ? "1" : "0");
    }
  }
  __name(visibility, "visibility");
  _KML.visibility = visibility;
  class when extends SimpleElement {
  }
  __name(when, "when");
  _KML.when = when;
  class width extends SimpleElement {
  }
  __name(width, "width");
  _KML.width = width;
  class Tour extends CompoundElement {
    constructor(name = null, initialwait = 0) {
      super();
      this.nsprefix = "gx";
      if (name != null) {
        this.add(new SimpleElement("name", name));
      }
      this.playlist = new Playlist(initialwait);
      this.add(this.playlist);
    }
    add_update(targetId, wait = 0.02) {
      this.playlist.add_update(targetId, wait);
    }
  }
  __name(Tour, "Tour");
  _KML.Tour = Tour;
  class Playlist extends CompoundElement {
    constructor(wait = 0) {
      super();
      this.nsprefix = "gx";
      if (wait > 0) {
        this.add(new Wait(wait));
      }
    }
    add_update(targetId, wait = 0.02) {
      this.add(new AnimatedUpdate(targetId));
      this.add(new Wait(wait));
    }
  }
  __name(Playlist, "Playlist");
  _KML.Playlist = Playlist;
  class Wait extends CompoundElement {
    constructor(wait) {
      super([new duration(wait)]);
      this.nsprefix = "gx";
    }
  }
  __name(Wait, "Wait");
  _KML.Wait = Wait;
  class duration extends SimpleElement {
    constructor(duration2) {
      super(void 0, duration2.toString());
      this.nsprefix = "gx";
    }
  }
  __name(duration, "duration");
  _KML.duration = duration;
  class AnimatedUpdate extends CompoundElement {
    constructor(targetId) {
      super([new Update(targetId)]);
      this.nsprefix = "gx";
    }
  }
  __name(AnimatedUpdate, "AnimatedUpdate");
  _KML.AnimatedUpdate = AnimatedUpdate;
  class Update extends CompoundElement {
    constructor(targetId) {
      super([new Change(targetId)]);
    }
  }
  __name(Update, "Update");
  _KML.Update = Update;
  class Change extends CompoundElement {
    constructor(targetId) {
      let placemark = new Placemark(null, null, null, null, null, true);
      placemark.add_attr("targetId", targetId);
      super([placemark]);
    }
  }
  __name(Change, "Change");
  _KML.Change = Change;
})(KML || (KML = {}));

// igc2kmz/kmz.ts
var JSZip = __toESM(require_lib3());
var KMZResource = class {
  constructor(path, content) {
    this.path = path;
    this.content = content;
  }
};
__name(KMZResource, "KMZResource");
var KMZ = class {
  constructor(elements) {
    this.elements = [];
    this.files = [];
    if (elements) {
      this.elements = elements;
    }
    this.roots = [];
  }
  add_roots(roots) {
    roots.forEach((root) => this.roots.push(root));
    return this;
  }
  add_root(root) {
    this.roots.push(root);
    return this;
  }
  add_file(filename, content) {
    this.files.push(new KMZResource(filename, content));
    return this;
  }
  add_files(files) {
    files.forEach((f) => this.files.push(f));
    return this;
  }
  add(args) {
    args.forEach((arg) => {
      if (this.elements[0] instanceof KML.CompoundElement) {
        if (arg instanceof KMZ) {
          arg.elements.forEach((elm) => this.elements[0].add(elm));
          this.add_roots(arg.roots);
          this.add_files(arg.files);
        } else {
          this.elements[0].add(arg);
        }
      }
    });
    return this;
  }
  add_siblings(args) {
    args.forEach((arg) => {
      if (arg instanceof KMZ) {
        arg.elements.forEach((elm) => this.elements.push(elm));
        this.add_roots(arg.roots);
        this.add_files(arg.files);
      } else {
        this.elements.push(arg);
      }
    });
    return this;
  }
  get_data(version, retkml = false, serialize = false) {
    return new Promise((res) => {
      const j = new JSZip.default();
      let document = new KML.Document();
      this.roots.forEach((root) => document.add(root));
      this.elements.forEach((elm) => document.add(elm));
      let kml = new KML.KML(version, document);
      if (retkml || serialize) {
        let kmlstring = kml.serialize(true);
        if (serialize)
          console.log(kmlstring);
        if (retkml) {
          res(kmlstring);
          return;
        }
      }
      j.file("doc.kml", kml.serialize());
      for (let i = 0; i < this.files.length; i++) {
        j.file(this.files[i].path, this.files[i].content, { base64: typeof this.files[i].content == "string" });
      }
      j.generateAsync({ type: "arraybuffer", compression: "DEFLATE" }).then((buff) => res(buff));
    });
  }
};
__name(KMZ, "KMZ");

// igc2kmz/scale.ts
var Scale = class {
  constructor(range, title, step = 1, cbgradient = default_gradient, max_divisions = 16) {
    this.grid_step = 0;
    this.range = range;
    this.title = title;
    this.cbgradient = cbgradient;
    this.step = step;
    if (step > 0) {
      let i = 0;
      let mult = step;
      while (true) {
        i = ++i % 3 == 0 ? 0 : i;
        if (i == 1) {
          mult = step;
        } else if (i == 2) {
          mult = 2 * step;
        } else {
          mult = 5 * step;
          step *= 10;
        }
        let lower = Math.trunc(this.range.min / mult);
        let upper = Math.trunc(this.range.max / mult);
        if (this.range.min < mult * lower) {
          lower--;
        }
        if (this.range.max > mult * upper) {
          upper++;
        }
        if (upper - lower <= max_divisions) {
          this.grid_step = 100 / (upper - lower);
          this.range = new Bounds([mult * lower, mult * upper]);
          this.step = mult;
          break;
        }
      }
    }
  }
  normalize(value) {
    if (value < this.range.min) {
      return 0;
    } else if (this.range.max <= value) {
      return 1;
    }
    return (value - this.range.min) / (this.range.max - this.range.min);
  }
  discretize(value, n = 32) {
    if (value < this.range.min) {
      return 0;
    } else if (this.range.max <= value) {
      return n - 1;
    }
    let result = Math.trunc(n * this.normalize(value));
    return result > n - 1 ? n - 1 : result;
  }
  color(value) {
    return this.cbgradient(this.normalize(value));
  }
  colors(n = 32) {
    return Array.from(Array(n)).map((v, i) => this.cbgradient(i / (n - 1)));
  }
};
__name(Scale, "Scale");
var ZeroCenteredScale = class extends Scale {
  normalize(value) {
    if (value < 0) {
      if (value < this.range.min) {
        return 0;
      } else {
        return 0.5 - 0.5 * value / this.range.min;
      }
    } else if (value == 0) {
      return 0.5;
    } else {
      if (this.range.max <= value) {
        return 1;
      } else {
        return 0.5 + 0.5 * value / this.range.max;
      }
    }
  }
};
__name(ZeroCenteredScale, "ZeroCenteredScale");
var TimeScale = class extends Scale {
  constructor(range, title, step = 1, cbgradient = default_gradient, max_divisions = 16, tz_offset = 0) {
    super(range, title, 0, cbgradient, max_divisions);
    this.labels = [];
    this.positions = [];
    this.step = step;
    let lower = Utils.seconds_to_date(range.min), upper = Utils.seconds_to_date(range.max);
    if (step > 0) {
      let steps = [
        1,
        5,
        15,
        30,
        60,
        5 * 60,
        15 * 60,
        30 * 60,
        3600,
        3 * 3600,
        6 * 3600,
        12 * 3600
      ].filter((s) => s >= step);
      for (let i = 0, mult = steps[0]; i < steps.length; i++, mult = steps[i]) {
        lower = Utils.datetime_floor(Utils.seconds_to_date(range.min), mult);
        upper = Utils.datetime_floor(Utils.seconds_to_date(range.max), mult);
        if (upper < range.max) {
          upper = new Date(upper.getTime() + mult * 1e3);
        }
        if ((upper.getTime() - lower.getTime()) / (mult * 1e3) < max_divisions) {
          this.range = new Bounds([lower.getTime() / 1e3, upper.getTime() / 1e3]);
          this.grid_step = 100 * mult / ((upper.getTime() - lower.getTime()) / 1e3);
          this.step = mult;
          break;
        }
      }
    }
    let t = new Date(new Date(lower.getFullYear(), lower.getMonth(), lower.getDate(), lower.getHours(), 0).getTime() + this.step * 1e3);
    while (t < upper) {
      let labeltime = new Date(t.getTime() + tz_offset * 1e3);
      this.labels.push(labeltime.toTimeString().split(" ")[0].substring(0, 5));
      this.positions.push(Math.round(100 * Utils.datediffsecs(t, lower) / Utils.datediffsecs(upper, lower)) % 3600);
      t = new Date(t.getTime() + this.step * 1e3);
    }
  }
};
__name(TimeScale, "TimeScale");

// igc2kmz/coord.ts
var R = 6371e3;
var cardinals = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"];
var Coord = class {
  constructor(lat, lon, ele, dt) {
    this.lat = lat;
    this.lon = lon;
    this.ele = ele ?? 0;
    this.dt = dt ?? /* @__PURE__ */ new Date();
  }
  static deg(lat, lon, ele, dt) {
    return new Coord(Math.PI * lat / 180, Math.PI * lon / 180, ele, dt);
  }
  get lat_deg() {
    return 180 * this.lat / Math.PI;
  }
  get lon_deg() {
    return 180 * this.lon / Math.PI;
  }
  static todegree(n) {
    return 180 * n / Math.PI;
  }
  static rad_to_cardinal(rad) {
    while (rad < 0) {
      rad += 2 * Math.PI;
    }
    return cardinals[Math.trunc(8 * rad / Math.PI + 0.5) % 16];
  }
  /**
   * Return the point halfway between self and other.
   * @param other
   */
  halfway_to(other) {
    let bx = Math.cos(other.lat) * Math.cos(other.lon - this.lon);
    let by = Math.cos(other.lat) * Math.sin(other.lon - this.lon);
    let cos_lat_plus_bx = Math.cos(this.lat) + bx;
    let lat = Math.atan2(Math.sin(this.lat) + Math.sin(other.lat), Math.sqrt(cos_lat_plus_bx * cos_lat_plus_bx + by * by));
    let lon = this.lon + Math.atan2(by, cos_lat_plus_bx);
    let ele = (this.ele + other.ele) / 2;
    return new Coord(lat, lon, ele);
  }
  /**
   * Return the initial bearing from self to other.
   * @param other
   */
  initial_bearing_to(other) {
    let y = Math.sin(other.lon - this.lon) * Math.cos(other.lat);
    let x = Math.cos(this.lat) * Math.sin(other.lat) - Math.sin(this.lat) * Math.cos(other.lat) * Math.cos(other.lon - this.lon);
    return Math.atan2(y, x);
  }
  initial_bearing_to_deg(other) {
    return this.initial_bearing_to(new Coord(Coord.todegree(other.lat), Coord.todegree(other.lon)));
  }
  /**
   * Return the distance from self to other.
   * @param other
   * @returns
   */
  distance_to(other) {
    let d = Math.sin(this.lat) * Math.sin(other.lat) + Math.cos(this.lat) * Math.cos(other.lat) * Math.cos(this.lon - other.lon);
    return d < 1 ? R * Math.acos(d) : 0;
  }
  static haversineDistance(pointA, pointB) {
    if (Array.isArray(pointA)) {
      pointA = new Coord(pointA[1], pointA[0]);
    }
    if (Array.isArray(pointB)) {
      pointB = new Coord(pointB[1], pointB[0]);
    }
    const deltaLatitude = (pointB.lat - pointA.lat) * Math.PI / 180;
    const deltaLongitude = (pointB.lon - pointA.lon) * Math.PI / 180;
    const halfChordLength = Math.cos(
      pointA.lat * Math.PI / 180
    ) * Math.cos(pointB.lat * Math.PI / 180) * Math.sin(deltaLongitude / 2) * Math.sin(deltaLongitude / 2) + Math.sin(deltaLatitude / 2) * Math.sin(deltaLatitude / 2);
    const angularDistance = 2 * Math.atan2(Math.sqrt(halfChordLength), Math.sqrt(1 - halfChordLength));
    return R * angularDistance;
  }
  /**
   * Return the point delta between self and other.
   * @param other
   * @param delta
   * @returns
   */
  interpolate(other, delta) {
    let d = Math.sin(this.lat) * Math.sin(other.lat) + Math.cos(this.lat) * Math.cos(other.lat) * Math.cos(other.lon - this.lon);
    d = d < 1 ? delta * Math.acos(d) : 0;
    let y = Math.sin(other.lon - this.lon) * Math.cos(other.lat);
    let x = Math.cos(this.lat) * Math.sin(other.lat) - Math.sin(this.lat) * Math.cos(other.lat) * Math.cos(other.lon - this.lon);
    let theta = Math.atan2(y, x);
    let lat = Math.asin(Math.sin(this.lat) * Math.cos(d) + Math.cos(this.lat) * Math.sin(d) * Math.cos(theta));
    let lon = this.lon + Math.atan2(Math.sin(theta) * Math.sin(d) * Math.cos(this.lat), Math.cos(d) - Math.sin(this.lat) * Math.sin(lat));
    let ele = (1 - delta) * this.ele + delta * other.ele;
    return new Coord(lat, lon, ele);
  }
  /**
   * Return the point d from self in direction theta.
   * @param theta
   * @param d
   * @returns
   */
  coord_at(theta, d) {
    let lat = Math.asin(Math.sin(this.lat) * Math.cos(d / R) + Math.cos(this.lat) * Math.sin(d / R) * Math.cos(theta));
    let lon = this.lon + Math.atan2(Math.sin(theta) * Math.sin(d / R) * Math.cos(this.lat), Math.cos(d / R) - Math.sin(this.lat) * Math.sin(this.lat));
    let ele = this.ele;
    return new Coord(lat, lon, ele);
  }
};
__name(Coord, "Coord");

// igc2kmz/flight.ts
var RIGHTWARDS_ARROW = "->";
var INFINITY = "inf";
var UP_TACK = "n/a";
var Flight = class {
  constructor(track) {
    this.photos = [];
    this.url = "";
    this.time_positions = [];
    this.pcount = 0;
    this.id = "";
    this.endconv = null;
    this.track = track;
    this.root = new KMZ([new KML.Folder(this.track.filename, null, [], true)]);
    if (track.elevation_data) {
      this.altitude_mode = "absolute";
    } else {
      this.altitude_mode = "clampToGround";
    }
    let solid_color = RGBA.fromRGBAHexString(track.options.solid_color);
    if (!solid_color) {
      solid_color = new RGBA(0, 0, 0, 255 / 255);
    } else {
      solid_color.a = 255 / 255;
    }
    this.color = solid_color.toHexString();
    this.width = 2;
    this.pilot_name = track.pilot_name;
    this.glider_type = track.glider_type;
    this.glider_id = track.glider_id;
  }
  get Id() {
    if ((this.id ?? "").trim().length > 0) {
      return this.id;
    }
    this.id = RandomIdGenerator.makeid(5);
    return this.id;
  }
  endwork() {
    this.pcount--;
    if (this.pcount <= 0 && this.endconv) {
      this.endconv(this.root);
    }
  }
  make_description(globals) {
    let rows = [];
    if (this.pilot_name) {
      rows.push(["Pilot name", this.pilot_name]);
    }
    if (this.glider_type) {
      rows.push(["Glider type", this.glider_type]);
    }
    if (this.glider_id) {
      rows.push(["Glider ID", this.glider_id]);
    }
    let take_off_time = new Date((this.track.bounds["time"]?.min + globals.tz_offset) * 1e3);
    rows.push(["Take-off time", take_off_time.toISOString().substring(11, 19)]);
    let landing_time = new Date((this.track.bounds["time"]?.max + globals.tz_offset) * 1e3);
    rows.push(["Landing time", landing_time.toISOString().substring(11, 19)]);
    let duration = this.track.bounds["time"]?.max - this.track.bounds["time"]?.min;
    let hour = Math.trunc(duration / 3600);
    let seconds = duration % 3600;
    let minute = Math.trunc(seconds / 60);
    let second = Math.trunc(seconds % 60);
    rows.push(["Duration", `${hour}h ${("0" + minute.toString()).substr(-2)}m ${("0" + second.toString()).substr(-2)}s`]);
    if (this.track.elevation_data) {
      rows.push(["Take-off altitude", this.track.coords[0].ele + "m"]);
      rows.push(["Maximum altitude", this.track.bounds["ele"]?.max + "m"]);
      rows.push(["Minimum altitude", this.track.bounds["ele"]?.min + "m"]);
      rows.push(["Landing altitude", this.track.coords[this.track.coords.length - 1].ele + "m"]);
      rows.push(["Total altitude gain", this.track.total_dz_positive + "m"]);
      rows.push(["Maximum altitude gain", this.track.max_dz_positive + "m"]);
      rows.push(["Maximum climb", Math.round(this.track.bounds["climb"]?.max * 10) / 10 + "m/s"]);
      rows.push(["Maximum sink", Math.round(this.track.bounds["climb"]?.min * 10) / 10 + "m/s"]);
    }
    rows.push(["Maximum speed", Math.round(this.track.bounds["speed"]?.max * 10) / 10 + "km/h"]);
    if (this.url) {
      let url = new URL(this.url);
      rows.push(["Flight URL", `<a href="${this.url}">${url.hostname}</a>`]);
    }
    let table = Utils.make_table(rows);
    return new KMZ([new KML.CDATA("description", table)]);
  }
  make_snippet(globals) {
    let date = new Date((this.track.bounds["time"]?.min + globals.tz_offset) * 1e3);
    let strings = [this.pilot_name, date.toISOString().substring(0, 10)];
    return new KMZ([new KML.Snippet(strings.join(", "))]);
  }
  static make_task_folder(globals, task) {
    let name = task.name ?? "Task";
    let rows = [];
    let tp0 = null;
    let total = 0;
    let count = -1;
    let indexes = Utils.runs(task.tps.map((tp) => tp.name));
    for (let i = 0, sl = indexes[0]; i < indexes.length; i++, sl = indexes[i]) {
      if (!tp0) {
        tp0 = task.tps[sl.start];
        continue;
      }
      let tp1 = task.tps[sl.stop - 1];
      let distance = tp0.coord.distance_to(tp1.coord);
      let th = `${tp0.name} ${RIGHTWARDS_ARROW} ${tp1.name}`;
      let td = `${round(distance / 1e3, 1)}km`;
      rows.push([th, td]);
      total += distance;
      count++;
      tp0 = tp1;
    }
    rows.push(["Total", `${round(total / 1e3, 1)}km`]);
    let table = Utils.make_table(rows);
    let snippet = `${round(total / 1e3, 1)}km via ${count} turnpoints`;
    let style_url = globals.stock.check_hide_children_style.url;
    let folder = new KML.Folder(name, style_url, [new KML.CDATA("description", table), new KML.Snippet(snippet)]);
    let line_style = new KML.Style([new KML.LineStyle("cc00F5FF", "2")]);
    folder.add(line_style);
    style_url = globals.stock.xc_style.url;
    let done = [];
    for (let i = 0, tp = task.tps[0]; i < task.tps.length; i++, tp = task.tps[i]) {
      let key = tp.name;
      if (done.indexOf(key) >= 0)
        continue;
      done.push(key);
      let point = new KML.Point(tp.coord);
      folder.add(new KML.Placemark(tp.name, point, [], style_url));
    }
    done = [];
    for (let i = 0, tp = task.tps[0]; i < task.tps.length; i++, tp = task.tps[i]) {
      if (tp.radius == 0)
        continue;
      let key = tp.name + tp.radius.toString();
      if (done.indexOf(key) >= 0)
        continue;
      done.push(key);
      let coordinates = KML.coordinates.circle(tp.coord, tp.radius);
      let line_string = new KML.LineString(coordinates, null, true);
      folder.add(new KML.Placemark(null, line_string, [], style_url));
    }
    tp0 = null;
    indexes = Utils.runs(task.tps.map((tp) => tp.name));
    for (let i = 0, sl = indexes[0]; i < indexes.length; i++, sl = indexes[i]) {
      if (!tp0) {
        tp0 = task.tps[sl.start];
        continue;
      }
      let tp1 = task.tps[sl.stop - 1];
      let coord0 = tp0.coord.coord_at(tp0.coord.initial_bearing_to(tp1.coord), tp0.radius);
      let theta = tp1.coord.initial_bearing_to(tp0.coord);
      let coord1 = tp1.coord.coord_at(theta, tp1.radius);
      let line_string1 = new KML.LineString([coord0, coord1], null, true);
      let coords = [coord1.coord_at(theta - Math.PI / 12, 400), coord1, coord1.coord_at(theta + Math.PI / 12, 400)];
      let line_string = new KML.LineString(coords, null, true);
      let multi_geometry = new KML.MultiGeometry([line_string1, line_string]);
      folder.add(new KML.Placemark(null, multi_geometry, [], line_style.url));
      tp0 = tp1;
    }
    return new KMZ([folder]);
  }
  make_solid_track(globals, style, altitude_mode, name, visibility = null, extrude = false) {
    let line_string = new KML.LineString(this.track.coords, altitude_mode);
    if (extrude) {
      line_string.add(new KML.SimpleElement("extrude", "1"));
    }
    let placemark = new KML.Placemark(null, line_string, [style]);
    let style_url = globals.stock.check_hide_children_style.url;
    let folder = new KML.Folder(name, style_url, [placemark]);
    if (visibility != null) {
      folder.add(new KML.visibility(visibility));
    }
    return new KMZ([folder]);
  }
  make_colored_track(globals, values, scale, altitude_mode, visibility, scale_chart = true) {
    if (!scale) {
      return new KMZ();
    }
    let folder = new KML.Folder("Colored by " + scale.title, globals.stock.check_hide_children_style.url, [], null, visibility);
    let styles = scale.colors().map((c) => new KML.Style([new KML.LineStyle(c, this.width.toString())])) ?? [];
    let discrete_values = values.map((v) => scale.discretize(v));
    let indexes = Utils.runs(discrete_values);
    for (let i = 0, sl = indexes[0]; i < indexes.length; i++, sl = indexes[i]) {
      let coordinates = this.track.coords.slice(sl.start, sl.stop + 1);
      let line_string = new KML.LineString(coordinates, altitude_mode);
      let style_url = styles[discrete_values[sl.start]].url;
      let placemark = new KML.Placemark(null, line_string, [], style_url);
      folder.add(placemark);
    }
    let href = "images/" + scale.title.replaceAll(" ", "_") + "_scale.png";
    if (scale_chart && scale && globals.canvas) {
      if (globals.files.indexOf(href) < 0) {
        globals.files.push(href);
        this.pcount++;
        this.make_scale_chart(globals, scale).then((imgdata) => {
          this.root.add_file(href, imgdata);
          this.endwork();
        }).catch((e) => {
          console.log(e);
          this.endwork();
        });
      }
      let icon = new KML.Icon([new KML.CDATA("href", href)]);
      let overlay_xy = new KML.overlayXY(0, "fraction", 1, "fraction");
      let screen_xy = new KML.screenXY(0, "fraction", 1, "fraction");
      let size = new KML.size(0, "fraction", 0, "fraction");
      let screen_overlay = new KML.ScreenOverlay([icon, overlay_xy, screen_xy, size]);
      folder.add(screen_overlay);
    }
    return new KMZ([folder]).add_roots(styles);
  }
  make_scale_chart(globals, scale) {
    return new Promise((res, rej) => {
      if (!globals.canvas)
        return rej("no canvas");
      globals.canvas.create_canvas(50, 200).then((cv) => {
        const ctx = cv.getContext("2d");
        if (!ctx || !scale)
          return rej("no context");
        ctx.clearRect(0, 0, cv.width, cv.height);
        ctx.fillStyle = "#ffffff00";
        ctx.fillRect(0, 0, cv.width, cv.height);
        let scalewidth = Math.max(Math.round(scale.range.max).toString().length, Math.round(scale.range.min).toString().length) * 9 + 2;
        ctx.fillStyle = "#ffffffcc";
        ctx.fillRect(0, 0, cv.width - scalewidth, cv.height);
        for (let i = 0; i < 32; i++) {
          let color = scale.color((i * (scale.range.max - scale.range.min) + 0.5) / 32 + scale.range.min);
          ctx.fillStyle = color.toRGBString();
          ctx.fillRect(0, (31 - i) * (cv.height / 32), cv.width - scalewidth, cv.height / 32);
        }
        ctx.strokeStyle = "#ff9f9f9f";
        ctx.fillStyle = "#fff";
        ctx.font = `12pt ${globals.canvas?.fontname}`;
        let nbrgraduations = cv.height / 25;
        for (let i = 0; i < nbrgraduations; i++) {
          let y = i * (cv.height / nbrgraduations);
          let value = Math.round((nbrgraduations - i) * (scale.range.max - scale.range.min) / nbrgraduations + scale.range.min).toString();
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(cv.width - scalewidth + 1, y);
          ctx.stroke();
          ctx.fillText(value, cv.width - scalewidth + 1, y);
        }
        globals.canvas.get_base64(cv).then((v) => res(v));
      });
    });
  }
  make_graph_chart(globals, values, scale) {
    return new Promise((res, rej) => {
      if (!globals.canvas)
        return rej("no canvas");
      globals.canvas.create_canvas(globals.graph_width, globals.graph_height).then((cv) => {
        const ctx = cv.getContext("2d");
        let oldconsole = console.log;
        console.log = function() {
        };
        let timescale = globals.scales["time"];
        if (!ctx || !(timescale instanceof TimeScale) || !scale)
          return rej("no context");
        ctx.clearRect(0, 0, cv.width, cv.height);
        ctx.fillStyle = "#ffffff00";
        ctx.fillRect(0, 0, cv.width, cv.height);
        ctx.fillStyle = "#ffffffcc";
        let marginleft = 35;
        let marginbtm = 14;
        let grphw = globals.graph_width - marginleft;
        let grphh = globals.graph_height - marginbtm;
        ctx.fillRect(marginleft, 0, grphw, grphh);
        ctx.fillStyle = "#ffffffff";
        ctx.font = `12pt ${globals.canvas?.fontname} bold`;
        let increment = grphw / timescale.labels.length;
        for (let i = 0; i < timescale.labels.length; i++) {
          ctx.fillText(timescale.labels[i], marginleft + i * increment, cv.height - 1);
        }
        ctx.textAlign = "right";
        increment = 50;
        while ((scale.range.max - scale.range.min) / increment > 10)
          increment += 50;
        let minalt = Utils.roundToFloor(scale.range.min, increment);
        let maxalt = Utils.roundToCeil(scale.range.max, increment);
        let multy = grphh / (maxalt - minalt);
        for (let i = minalt; i <= maxalt; i += increment) {
          ctx.fillText(i.toString(), marginleft - 1, grphh - (i - minalt) * multy);
        }
        ctx.textAlign = "left";
        let yvals = values.map((v) => grphh * (v - scale.range.min) / (scale.range.max - scale.range.min));
        let indexes = Utils.incr_douglas_peucker(this.time_positions, yvals, 1, 450);
        let cvalues = new Array(2);
        cvalues[0] = [];
        cvalues[1] = [];
        for (let i = 0; i < indexes.length; i++) {
          cvalues[0].push(this.track.t[indexes[i]]);
          cvalues[1].push(yvals[indexes[i]]);
        }
        let multx = grphw / (timescale.range.max - timescale.range.min);
        ctx.strokeStyle = "#FF9500";
        ctx.lineWidth = 2;
        let x = marginleft + multx * (cvalues[0][0] - timescale.range.min);
        let y = grphh - cvalues[1][0];
        ctx.beginPath();
        ctx.moveTo(x, y);
        for (let i = 1; i < indexes.length; i++) {
          x = marginleft + multx * (cvalues[0][i] - timescale.range.min);
          y = grphh - cvalues[1][i];
          ctx.lineTo(x, y);
        }
        ctx.stroke();
        console.log = oldconsole;
        globals.canvas.get_base64(cv).then((v) => res(v));
      });
    });
  }
  make_track_folder(globals) {
    let style_url = globals.stock.radio_folder_style.url;
    let folder = new KMZ([new KML.Folder("Track", style_url, [], true)]);
    folder.add([globals.stock.invisible_none_folder]);
    let visibility;
    if (this.track.elevation_data) {
      visibility = globals.default_track == "climb";
      folder.add([this.make_colored_track(globals, this.track.climb, globals.scales["climb"], "absolute", visibility)]);
      visibility = globals.default_track == "altitude";
      folder.add([this.make_colored_track(globals, this.track.ele, globals.scales["altitude"], "absolute", visibility)]);
      visibility = globals.default_track == "tec";
      folder.add([this.make_colored_track(globals, this.track.tec, globals.scales["tec"], "absolute", visibility)]);
    }
    visibility = globals.default_track == "speed";
    folder.add([this.make_colored_track(globals, this.track.speed, globals.scales["speed"], this.altitude_mode, visibility)]);
    visibility = globals.default_track == "time";
    folder.add([this.make_colored_track(globals, this.track.t, globals.scales["t"], this.altitude_mode, visibility, false)]);
    visibility = globals.default_track == "solid_color";
    let style = new KML.Style([new KML.LineStyle(this.color, this.width.toString())]);
    folder.add([this.make_solid_track(globals, style, this.altitude_mode, "Solid color", visibility)]);
    return folder;
  }
  make_shadow_folder(globals) {
    if (!this.track.elevation_data) {
      return new KMZ();
    }
    let style_url = globals.stock.radio_folder_style.url;
    let folder = new KMZ([new KML.Folder("Shadow", style_url, [], false, globals.flights.length <= 1)]);
    folder.add([globals.stock.invisible_none_folder]);
    let style = new KML.Style([new KML.LineStyle("ff000000", "1")]);
    folder.add([this.make_solid_track(globals, style, "clampToGround", "Normal")]);
    let line_style = new KML.LineStyle("00000000", "1");
    let polyline_color = RGBA.fromRGBAHexString(globals.options.extrude_color);
    if (!polyline_color) {
      polyline_color = new RGBA(0, 0, 0, 128 / 255);
    } else {
      polyline_color.a = 128 / 255;
    }
    let poly_style = new KML.PolyStyle([new KML.SimpleElement("color", polyline_color.toHexString()), new KML.SimpleElement("width", "1")]);
    style = new KML.Style([line_style, poly_style]);
    folder.add([this.make_solid_track(globals, style, "absolute", "Extrude", false, true)]);
    style = new KML.Style([new KML.LineStyle(this.color, this.width.toString())]);
    folder.add([this.make_solid_track(globals, style, "clampToGround", "Solid color", false)]);
    return folder;
  }
  make_animation_tour(globals) {
    let style_url = globals.stock.radio_folder_style.url;
    let result = new KML.Folder("Animation", style_url, [], false);
    let line_style = new KML.Style([new KML.LineStyle("bf00aaff", "2")]);
    result.add(line_style);
    let tour = new KML.Tour("Double-click here to start tour", 1);
    result.add(tour);
    style_url = globals.stock.check_hide_children_style.url;
    let folder = new KML.Folder("Path segments", style_url, [], false);
    let placemarks = [];
    let line_string = new KML.LineString(this.track.coords.slice(0, 2), this.altitude_mode, true);
    let placemark = new KML.Placemark("1", line_string, [], line_style.url, false, false);
    placemarks.push(placemark);
    tour.add_update(placemark.Id);
    for (let i = 1; i < this.track.coords.length; i++) {
      line_string = new KML.LineString(this.track.coords.slice(i, i + 2), this.altitude_mode, true);
      placemark = new KML.Placemark(null, line_string, [], line_style.url, false, false);
      placemarks.push(placemark);
      tour.add_update(placemark.Id);
    }
    placemarks.forEach((placemark2) => folder.add(placemark2));
    result.add(folder);
    return result;
  }
  make_animation(globals) {
    let icon_style = new KML.IconStyle([globals.stock.animation_icon, new KML.color(this.color), new KML.scale(globals.stock.icon_scales[0].toString())]);
    let list_style = new KML.ListStyle("checkHideChildren");
    let label_color = new RGBA(Math.random(), Math.random(), Math.random(), 1);
    let line_color = label_color;
    if (!globals.options.anim_tail_use_pilot_color) {
      line_color = RGBA.fromRGBAHexString(globals.options.anim_tail_color);
      if (!line_color) {
        line_color = new RGBA(255 / 255, 155 / 255, 0 / 255, 159 / 255);
      } else {
        line_color.a = 159 / 255;
      }
    }
    let line_style = new KML.LineStyle(line_color, this.width.toString());
    let label_style = new KML.LabelStyle(label_color, 1);
    let style = new KML.Style([icon_style, list_style, line_style, label_style]);
    let folder = new KML.Folder("Animation", null, [style], null, false);
    let point = new KML.Point(this.track.coords[0], this.altitude_mode);
    let timespan = new KML.TimeSpan(null, this.track.coords[0].dt);
    let placemark = new KML.Placemark(null, point, [timespan], style.url);
    folder.add(placemark);
    for (let i = 1; i < this.track.coords.length - 1; i++) {
      let coord = this.track.coords[i - 1].halfway_to(this.track.coords[i]);
      point = new KML.Point(coord, this.altitude_mode);
      timespan = new KML.TimeSpan(this.track.coords[i - 1].dt, this.track.coords[i].dt);
      placemark = new KML.Placemark(null, point, [timespan], style.url);
      if (globals.flights.length > 1) {
        placemark.add(new KML.SimpleElement("name", this.track.pilot_name));
      }
      folder.add(placemark);
      if (globals.options.anim_tail) {
        let line_string2 = new KML.LineString([this.track.coords[i - 1], this.track.coords[i]], "absolute");
        let endtime = null;
        if (globals.options.anim_tail_duration > 0) {
          endtime = new Date(this.track.coords[i].dt.getTime() + globals.options.anim_tail_duration * 1e3);
        }
        timespan = new KML.TimeSpan(this.track.coords[i].dt, endtime);
        placemark = new KML.Placemark(null, line_string2, [timespan], style.url);
        folder.add(placemark);
      }
    }
    point = new KML.Point(this.track.coords[this.track.coords.length - 1], this.altitude_mode);
    let line_string = new KML.LineString(this.track.coords.slice(this.track.indexOf(new Date(this.track.coords[this.track.coords.length - 1].dt.getTime() - 6e4)), this.track.coords.length - 1), "absolute");
    timespan = new KML.TimeSpan(this.track.coords[this.track.coords.length - 1].dt);
    placemark = new KML.Placemark(null, point, [timespan], style.url);
    folder.add(placemark);
    placemark = new KML.Placemark(null, line_string, [timespan], style.url);
    folder.add(placemark);
    return new KMZ([folder]);
  }
  make_photos_folder(globals) {
    if (this.photos.length <= 0) {
      return new KMZ();
    }
    let folder = new KML.Folder("Photos", null, [], false);
    let photos = this.photos.sort((a, b) => b.date.getTime() - a.date.getTime());
    photos.forEach((photo) => {
      let coord;
      let altitude_mode;
      if (photo.coord) {
        coord = photo.coord;
        altitude_mode = photo.elevation_data ? "absolute" : "clampToGround";
      } else {
        coord = this.track.coord_at(add_seconds(photo.date, -1 * globals.tz_offset));
        altitude_mode = this.altitude_mode;
      }
      let point = new KML.Point(coord, altitude_mode);
      let title = photo.name;
      if (photo.description?.trim().length ?? 0 > 0) {
        title += ": " + photo.description;
      }
      let description = `<h3>${title}</h3>${photo.to_html_img()}`;
      let style_url = globals.stock.photo_style.url;
      let placemark = new KML.Placemark(photo.name, point, [new KML.CDATA("description", description), new KML.CDATA("Snippet", description)], style_url);
      folder.add(placemark);
    });
    return new KMZ([folder]);
  }
  make_xc_folder(globals) {
    if (!this.track.xc_score || !this.track.xc_score.solution || typeof this.track.xc_score.solution.scoreInfo !== "object") {
      return new KMZ();
    }
    let score = this.track.xc_score.solution.scoreInfo;
    let rows = [];
    rows.push(["Rules", globals.options.xc_score_rules]);
    rows.push(["Type", this.track.xc_score.solution.opt.scoring.name]);
    rows.push(["Score", `${score.score}pts`]);
    if (score.legs) {
      score.legs.forEach((leg) => {
        rows.push([leg.name, `${leg.d}km`]);
      });
    }
    rows.push(["Distance", `${score.distance}km`]);
    if (this.track.xc_score.closingCircleRadius > 0) {
      rows.push(["Closing distance", `${this.track.xc_score.closingCircleRadius / 1e3}km`]);
    }
    let table = Utils.make_table(rows);
    let snippet = `${this.track.xc_score.solution.opt.scoring.name} ${score.score}pts`;
    let style_url = globals.stock.check_hide_children_style.url;
    let folder = new KML.Folder("Score", style_url, [new KML.CDATA("description", table), new KML.Snippet(snippet)], null, globals.flights.length <= 1);
    let line_style = new KML.Style([new KML.LineStyle("cc00FF00", "1")]);
    folder.add(line_style);
    let line_style1 = new KML.Style([new KML.LineStyle("ccFFFFFF", "1")]);
    folder.add(line_style1);
    let line_style2 = new KML.Style([new KML.LineStyle("cc00F5FF", "1")]);
    folder.add(line_style2);
    style_url = globals.stock.xc_style.url;
    if (score.tp) {
      score.tp.forEach((tp, i) => {
        let coord = Coord.deg(tp.y, tp.x);
        let point = new KML.Point(coord);
        folder.add(new KML.Placemark("TP" + (i + 1), point, [], style_url));
      });
    }
    if (score.legs) {
      score.legs.forEach((leg) => {
        let coord0 = Coord.deg(leg.start.y, leg.start.x);
        let coord1 = Coord.deg(leg.finish.y, leg.finish.x);
        let line_string = new KML.LineString([coord0, coord1], null, true);
        folder.add(new KML.Placemark(null, line_string, [], line_style.url));
      });
    }
    if (score.cp) {
      let coordin = Coord.deg(score.cp.in.y, score.cp.in.x);
      let coordout = Coord.deg(score.cp.out.y, score.cp.out.x);
      folder.add(new KML.Placemark("IN", new KML.Point(coordin), [], style_url));
      folder.add(new KML.Placemark("OUT", new KML.Point(coordout), [], style_url));
      if (score.tp) {
        let coordtp = Coord.deg(score.tp[0].y, score.tp[0].x);
        let line_string = new KML.LineString([coordin, coordtp], null, true);
        folder.add(new KML.Placemark(null, line_string, [], line_style1.url));
        coordtp = Coord.deg(score.tp[score.tp.length - 1].y, score.tp[score.tp.length - 1].x);
        line_string = new KML.LineString([coordout, coordtp], null, true);
        folder.add(new KML.Placemark(null, line_string, [], line_style1.url));
      }
      if (this.track.xc_score.closingCircleRadius > 0) {
        let coordinates = KML.coordinates.circle(coordin, this.track.xc_score.closingCircleRadius);
        let line_string = new KML.LineString(coordinates, null, true);
        folder.add(new KML.Placemark(null, line_string, [], line_style2.url));
      }
    }
    return new KMZ([folder]);
  }
  make_tour_folder(globals) {
    let style_url = globals.stock.check_hide_children_style.url;
    let folder = new KML.Folder("Tour", style_url, [], null, false);
    let dt = this.track.coords[0].dt;
    let delta = 15 * 60;
    let coords = [];
    while (dt < this.track.coords[this.track.coords.length - 1].dt) {
      coords.push(this.track.coord_at(dt));
      dt = add_seconds(dt, delta);
    }
    for (let i = 0; i < coords.length; i++) {
      let j = (i + 1) % coords.length;
      let point = new KML.Point(coords[i], this.altitude_mode);
      let heading = coords[i].initial_bearing_to_deg(coords[j]);
      let camera = new KML.Camera(coords[i], heading, 75);
      let placemark = new KML.Placemark(null, point, [camera]);
      folder.add(placemark);
    }
    return folder;
  }
  make_placemark(globals, coord, altitudeMode, name, style_url) {
    let point = new KML.Point(coord, altitudeMode);
    return new KML.Placemark(name, point, [new KML.Snippet()], style_url);
  }
  make_altitude_marks_folder(globals) {
    if (!this.track.elevation_data) {
      return new KMZ();
    }
    let style_url = globals.stock.check_hide_children_style.url;
    let folder = new KML.Folder("Altitude marks", style_url, [], null, false);
    Utils.salient2(this.track.coords.map((c) => c.ele), [100, 50, 10]).forEach((j, index) => {
      let coord = this.track.coords[index];
      let i = globals.scales.altitude?.discretize(coord.ele) ?? 0;
      style_url = globals.altitude_styles[j][i].url;
      folder.add(this.make_placemark(globals, coord, "absolute", `${coord.ele}m`, style_url));
    });
    return new KMZ([folder]);
  }
  make_graph(globals, values, scale) {
    if (!globals.canvas) {
      return new KML.Comment("Error while generating graph");
    }
    let href = "images/" + scale.title.replaceAll(" ", "_") + "_" + this.Id + "_graph.png";
    this.pcount++;
    this.make_graph_chart(globals, values, scale).then((imgdata) => {
      this.root.add_file(href, imgdata);
      this.endwork();
    }).catch((e) => {
      console.log(e);
      this.endwork();
    });
    let icon = new KML.Icon([new KML.CDATA("href", href)]);
    let overlay_xy = new KML.overlayXY(0, "fraction", 0, "fraction");
    let screen_xy = new KML.screenXY(0, "fraction", 16, "pixels");
    let size = new KML.size(0, "fraction", 0, "fraction");
    let screen_overlay = new KML.ScreenOverlay([icon, overlay_xy, screen_xy, size]);
    let style_url = globals.stock.check_hide_children_style.url;
    let name = Utils.capitalizeFirstLetter(scale.title) + " graph";
    let folder = new KML.Folder(name, style_url, [screen_overlay], null, false);
    return folder;
  }
  make_analysis_folder(globals, title, slices, style_url) {
    if (!this.track.elevation_data || slices.length <= 0) {
      return new KMZ();
    }
    let folder_style_url = globals.stock.check_hide_children_style.url;
    let folder = new KML.Folder(Utils.capitalizeFirstLetter(title) + "s", folder_style_url, null, null, false);
    for (let k = 0, sl = slices[0]; k < slices.length; k++, sl = slices[k]) {
      let coord0 = this.track.coords[sl.start];
      let coord1 = this.track.coords[sl.stop];
      let coord = coord0.halfway_to(coord1);
      let point = new KML.Point(coord, "absolute");
      let total_dz_positive = 0, total_dz_negative = 0;
      let peak_climb = new Bounds(0);
      for (let i = sl.start; i < sl.stop; i++) {
        let dz2 = this.track.coords[i + 1].ele - this.track.coords[i].ele;
        let dt2 = this.track.t[i + 1] - this.track.t[i];
        if (dz2 > 0) {
          total_dz_positive += dz2;
        } else if (dz2 < 0) {
          total_dz_negative += dz2;
        }
        peak_climb.update(dz2 / dt2);
      }
      let climb = new Bounds(this.track.climb.slice(sl.start, sl.stop));
      let dz = this.track.coords[sl.stop].ele - this.track.coords[sl.start].ele;
      let dt = this.track.t[sl.stop] - this.track.t[sl.start];
      let dp = coord0.distance_to(coord1);
      let theta = coord0.initial_bearing_to(coord1);
      let dict = {};
      dict["altitude_change"] = round(dz);
      dict["average_climb"] = round(dz / dt, 1);
      dict["maximum_climb"] = round(climb.max, 1);
      dict["peak_climb"] = round(peak_climb.max, 1);
      let divisor = dt * climb.max;
      if (divisor == 0) {
        dict["efficiency"] = UP_TACK;
      } else {
        dict["efficiency"] = round(100 * dz / divisor);
      }
      dict["distance"] = round(dp / 1e3, 1);
      let average_ld = dz < 0 ? round(-dp / dz, 1).toString() : INFINITY;
      dict["average_ld"] = average_ld;
      dict["average_speed"] = round(3.6 * dp / dt, 1);
      dict["maximum_descent"] = round(climb.min, 1);
      dict["peak_descent"] = round(peak_climb.min, 1);
      dict["start_altitude"] = coord0.ele;
      dict["finish_altitude"] = coord1.ele;
      let start_time = new Date(coord0.dt.getTime() + globals.tz_offset * 1e3);
      dict["start_time"] = start_time.toISOString().substring(11, 19);
      let stop_time = new Date(coord1.dt.getTime() + globals.tz_offset * 1e3);
      dict["finish_time"] = stop_time.toISOString().substring(11, 19);
      let duration = this.track.t[sl.stop] - this.track.t[sl.start];
      let seconds = ("0" + Math.trunc(duration % 60).toString()).substr(-2);
      dict["duration"] = `${Math.trunc(duration / 60)}m ${seconds}ds`;
      dict["accumulated_altitude_gain"] = total_dz_positive;
      dict["accumulated_altitude_loss"] = total_dz_negative;
      dict["drift_direction"] = Coord.rad_to_cardinal(theta + Math.PI);
      let extended_data = new KML.ExtendedData(dict);
      let name = "";
      if (title == "thermal") {
        name = `${round(dz)}m at ${round(dz / dt, 1)}m/s`;
      } else if (title == "glide") {
        name = `${round(dp / 1e3, 1)}km at ${average_ld}:1, ${round(3.6 * dp / dt)}km/h`;
      } else if (title == "dive") {
        name = `${-1 * round(-dz)}m at ${round(dz / dt, 1)}m/s`;
      }
      let placemark = new KML.Placemark(name, point, [extended_data], style_url);
      folder.add(placemark);
      let line_string = new KML.LineString([coord0, coord1], "absolute");
      placemark = new KML.Placemark(null, line_string, null, style_url);
      folder.add(placemark);
    }
    return new KMZ([folder]);
  }
  make_time_mark(globals, coord, dt, style_url) {
    let point = new KML.Point(coord, this.altitude_mode);
    let name = new Date(dt.getTime() + globals.tz_offset * 1e3).toISOString().substring(11, 16);
    return new KML.Placemark(name, point, [], style_url);
  }
  make_time_marks_folder(globals, step = 300) {
    let style_url = globals.stock.check_hide_children_style.url;
    let folder = new KML.Folder("Time marks", style_url, [], null, false);
    let coord = this.track.coords[0];
    style_url = globals.stock.time_mark_styles[0].url;
    folder.add(this.make_time_mark(globals, coord, coord.dt, style_url));
    let dt = Utils.datetime_floor(this.track.coords[0].dt, step);
    while (dt <= this.track.coords[0].dt) {
      dt = new Date(dt.getTime() + step * 1e3);
    }
    while (dt < this.track.coords[this.track.coords.length - 1].dt) {
      coord = this.track.coord_at(dt);
      let style_index = 3;
      if (dt.getMinutes() == 0) {
        style_index = 0;
      } else if (dt.getMinutes() == 30) {
        style_index = 1;
      } else if (dt.getMinutes() == 15 || dt.getMinutes() == 45) {
        style_index = 2;
      }
      style_url = globals.stock.time_mark_styles[style_index].url;
      folder.add(this.make_time_mark(globals, coord, dt, style_url));
      dt = new Date(dt.getTime() + step * 1e3);
    }
    coord = this.track.coords[this.track.coords.length - 1];
    style_url = globals.stock.time_mark_styles[0].url;
    folder.add(this.make_time_mark(globals, coord, coord.dt, style_url));
    return folder;
  }
  to_kmz(globals) {
    return new Promise((res, rej) => {
      this.endconv = res;
      this.pcount++;
      if (globals.scales["time"] != null) {
        let maxtimescale = globals.scales["time"]?.range.max;
        let mintimescale = globals.scales["time"]?.range.min;
        this.time_positions = this.track.t.map((t) => Math.trunc(globals.graph_width * (t - mintimescale) / (maxtimescale - mintimescale)));
      }
      this.root.add([this.make_description(globals)]);
      this.root.add([this.make_snippet(globals)]);
      if (this.track.declaration) {
        this.root.add([Flight.make_task_folder(globals, this.track.declaration)]);
      }
      this.root.add([this.make_track_folder(globals)]);
      this.root.add([this.make_shadow_folder(globals)]);
      this.root.add([this.make_animation(globals)]);
      this.root.add([this.make_photos_folder(globals)]);
      this.root.add([this.make_xc_folder(globals)]);
      this.root.add([this.make_altitude_marks_folder(globals)]);
      if (this.track.elevation_data && globals.scales["altitude"]) {
        let eles = this.track.coords.map((c) => c.ele);
        this.root.add([this.make_graph(globals, eles, globals.scales["altitude"])]);
      }
      this.root.add([this.make_analysis_folder(globals, "thermal", this.track.thermals, globals.stock.thermal_style.url)]);
      this.root.add([this.make_analysis_folder(globals, "glide", this.track.glides, globals.stock.glide_style.url)]);
      this.root.add([this.make_analysis_folder(globals, "dive", this.track.dives, globals.stock.dive_style.url)]);
      this.root.add([this.make_time_marks_folder(globals)]);
      this.photos.forEach((photo) => this.root.add_file(photo.filename, photo.image));
      this.endwork();
    });
  }
};
__name(Flight, "Flight");

// assets/paraglider.png
var paraglider_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfXBQMSDhn88FT5AAAA1klEQVQoz32QsUoDURBFz4RlIVYWNgEr21TaprCxzedYuB8QsPMbUlmkk7SmCdiJWAhuYaWFhCAWKgThWLxs0N2NM8V7j7n3zr0v5P/K0vHimF2eWfLIOz0KBpEmITDxgAX35JzwzYxrnsi5TRCZWnpq32NFVn744LlD+84VpPRy/aj60zdnDj1UMii54mizE6AbuAOsgA5ccMd+zXs3XvmCBMjZYxRFLe8NvSrmNNp/YFylqPrMtnunjVs42qj+AiQfUfNSUwj/8huEEIytCs1xc2WjfgBWl2gno0VlygAAAABJRU5ErkJggg==";

// assets/pixel.png
var pixel_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH2AQMFBQfNWb8lgAAAA1JREFUCJljYGBgYAAAAAUAAYehTtQAAAAASUVORK5CYII=";

// igc2kmz/stock.ts
var Stock = class {
  constructor() {
    this.icons = [];
    this.kmz = new KMZ();
    this.icons = [25, 25, 24, 24].map((v) => KML.Icon.palette(4, v));
    this.icon_scales = [0.6, 0.5, 0.4, 0.3].map((v) => Math.sqrt(v));
    this.label_scales = [0.6, 0.5, 0.4, 0.3].map((v) => Math.sqrt(v));
    let list_style = new KML.ListStyle("radioFolder");
    this.radio_folder_style = new KML.Style([list_style]);
    this.kmz.add_root(this.radio_folder_style);
    list_style = new KML.ListStyle("checkHideChildren");
    this.check_hide_children_style = new KML.Style([list_style]);
    this.kmz.add_root(this.check_hide_children_style);
    let bgcolors = ["#ffcccc", "#ffdddd"];
    let rows = [
      ["Altitude gain", "$[altitude_change]m"],
      ["Average climb", "$[average_climb]m/s"],
      ["Maximum climb", "$[maximum_climb]m/s"],
      ["Peak climb", "$[peak_climb]m/s"],
      ["Efficiency", "$[efficiency]%"],
      ["Start altitude", "$[start_altitude]m"],
      ["Finish altitude", "$[finish_altitude]m"],
      ["Start time", "$[start_time]"],
      ["Finish time", "$[finish_time]"],
      ["Duration", "$[duration]"],
      ["Accumulated altitude gain", "$[accumulated_altitude_gain]m"],
      ["Accumulated altitude loss", "$[accumulated_altitude_loss]m"],
      ["Drift", "$[average_speed]km/h $[drift_direction]"]
    ];
    this.thermal_style = this.make_analysis_style("cc3333ff", bgcolors, rows);
    this.kmz.add_root(this.thermal_style);
    bgcolors = ["#ccccff", "#ddddff"];
    rows = [
      ["Altitude change", "$[altitude_change]m"],
      ["Average descent", "$[average_climb]m/s"],
      ["Maximum descent", "$[maximum_descent]m/s"],
      ["Peak descent", "$[peak_descent]m/s"],
      ["Start altitude", "$[start_altitude]m"],
      ["Finish altitude", "$[finish_altitude]m"],
      ["Start time", "$[start_time]"],
      ["Finish time", "$[finish_time]"],
      ["Duration", "$[duration]"],
      ["Accumulated altitude gain", "$[accumulated_altitude_gain]m"],
      ["Accumulated altitude loss", "$[accumulated_altitude_loss]m"]
    ];
    this.dive_style = this.make_analysis_style("ccff3333", bgcolors, rows);
    this.kmz.add_root(this.dive_style);
    bgcolors = ["#ccffcc", "#ddffdd"];
    rows = [
      ["Altitude change", "$[altitude_change]m"],
      ["Average descent", "$[average_climb]m/s"],
      ["Distance", "$[distance]km"],
      ["Average glide ratio", "$[average_ld]:1"],
      ["Average speed", "$[average_speed]km/h"],
      ["Start altitude", "$[start_altitude]m"],
      ["Finish altitude", "$[finish_altitude]m"],
      ["Start time", "$[start_time]"],
      ["Finish time", "$[finish_time]"],
      ["Duration", "$[duration]"],
      ["Accumulated altitude gain", "$[accumulated_altitude_gain]m"],
      ["Accumulated altitude loss", "$[accumulated_altitude_loss]m"]
    ];
    this.glide_style = this.make_analysis_style("cc33ff33", bgcolors, rows);
    this.kmz.add_root(this.glide_style);
    this.time_mark_styles = [];
    for (let i = 0; i < this.icons.length; i++) {
      let icon_style2 = new KML.IconStyle([this.icons[0], new KML.scale(this.icon_scales[i].toString())]);
      let label_style2 = new KML.LabelStyle("cc33ffff", this.label_scales[i]);
      this.time_mark_styles.push(new KML.Style([icon_style2, label_style2]));
    }
    this.kmz.add_roots(this.time_mark_styles);
    let balloon_style = new KML.BalloonStyle([new KML.CDATA("text", "$[description]")]);
    let icon_style = new KML.IconStyle([KML.Icon.palette(4, 46), new KML.scale(this.icon_scales[0].toString())]);
    let label_style = new KML.LabelStyle(void 0, this.label_scales[0]);
    this.photo_style = new KML.Style([balloon_style, icon_style, label_style]);
    this.kmz.add_root(this.photo_style);
    balloon_style = new KML.BalloonStyle([new KML.CDATA("text", "<h3>$[name]</h3>$[description]")]);
    icon_style = new KML.IconStyle([this.icons[0], new KML.SimpleElement("color", "ccff33ff"), new KML.scale(this.icon_scales[0].toString())]);
    label_style = new KML.LabelStyle("ccff33ff", this.label_scales[0]);
    let line_style = new KML.LineStyle("ccff33ff", "2");
    this.xc_style = new KML.Style([balloon_style, icon_style, label_style, line_style]);
    this.kmz.add_root(this.xc_style);
    balloon_style = new KML.BalloonStyle([new KML.CDATA("text", "<h3>$[name]</h3>$[description]")]);
    icon_style = new KML.IconStyle([this.icons[0], new KML.SimpleElement("color", "ccff33ff"), new KML.scale(this.icon_scales[0].toString())]);
    label_style = new KML.LabelStyle("ccff33ff");
    line_style = new KML.LineStyle("ccff33ff", "2");
    this.xc_style2 = new KML.Style([balloon_style, icon_style, label_style, line_style]);
    this.kmz.add_root(this.xc_style2);
    this.pixel_url = "images/pixel.png";
    let pixel = pixel_default.substring(pixel_default.indexOf("base64,") + "base64,".length);
    this.kmz.add_file(this.pixel_url, pixel);
    this.visible_none_folder = this.make_none_folder(1);
    this.invisible_none_folder = this.make_none_folder(0);
    let animation_icon_url = "images/paraglider.png";
    this.animation_icon = new KML.Icon([new KML.SimpleElement("href", animation_icon_url)]);
    let animation_icon = paraglider_default.substring(paraglider_default.indexOf("base64,") + "base64,".length);
    this.kmz.add_file(animation_icon_url, animation_icon);
  }
  make_none_folder(visibility) {
    let icon = new KML.Icon([new KML.SimpleElement("href", this.pixel_url)]);
    let overlay_xy = new KML.overlayXY(0, "fraction", 0, "fraction");
    let screen_xy = new KML.screenXY(0, "fraction", 0, "fraction");
    let size = new KML.size(0, "fraction", 0, "fraction");
    let screen_overlay = new KML.ScreenOverlay([icon, overlay_xy, screen_xy, size, new KML.SimpleElement("visibility", visibility.toString())]);
    let style_url = this.check_hide_children_style.url;
    return new KML.Folder("None", style_url, [screen_overlay]);
  }
  make_analysis_style(color, bgcolors, rows) {
    let text = "<h3>$[name]</h3>$[description]" + Utils.make_table(rows, bgcolors);
    let bg_color = "ff" + [...bgcolors[1].substring(1).matchAll(/../g)].reverse().join("");
    let balloon_style = new KML.BalloonStyle([new KML.CDATA("text", text), new KML.SimpleElement("bgColor", bg_color)]);
    let icon_style = new KML.IconStyle([this.icons[0], new KML.SimpleElement("color", color), new KML.scale(this.icon_scales[0].toString())]);
    let label_style = new KML.LabelStyle(color, this.label_scales[0]);
    let line_style = new KML.LineStyle(color, "4");
    return new KML.Style([balloon_style, icon_style, label_style, line_style]);
  }
};
__name(Stock, "Stock");

// igc2kmz/init.ts
var defaultconfig = {
  tz_offset: 0,
  pressure_altitude: false,
  qnh: SEALEVEL_QNH,
  same_start: false,
  solid_color: "#ff0000",
  anim_tail: true,
  anim_tail_duration: 60,
  anim_tail_color: "#ff9b00",
  anim_tail_use_pilot_color: true,
  extrude_color: "#000000",
  xc_score: true,
  xc_score_rules: "FFVL",
  xc_score_maxtime: 10,
  dbg_serialize: false
};
var FlightConvert = class {
  constructor(canvas) {
    this.bounds = {};
    this.scales = {};
    this.stock = new Stock();
    this.task = null;
    this.tz_offset = 0;
    this.altitude_styles = [];
    this.graph_width = 600;
    this.graph_height = 300;
    this.default_track = "solid_color";
    this.canvas = null;
    this.files = [];
    this.flights = [];
    this.options = defaultconfig;
    if (canvas) {
      this.canvas = canvas;
    }
  }
  convert(flights, options = defaultconfig, task, kml = false) {
    this.flights = flights;
    this.options = options;
    this.bounds = {};
    this.scales = {};
    this.altitude_styles = [];
    this.files = [];
    flights.forEach((flight) => {
      bsupdate(this.bounds, flight.track.bounds);
    });
    this.tz_offset = options.tz_offset * 3600;
    if (task) {
      this.task = task;
    }
    let gradient = bilinear_gradient;
    if (this.bounds["climb"] != null) {
      if (this.bounds["climb"].min < -5) {
        this.bounds["climb"].min = -5;
      } else if (this.bounds["climb"].max > 5) {
        this.bounds["climb"].max = 5;
      }
      this.scales["climb"] = new ZeroCenteredScale(this.bounds["climb"], "climb", 0.1, gradient);
    }
    if (this.bounds["speed"] != null) {
      this.scales["speed"] = new Scale(this.bounds["speed"], "ground speed");
    }
    if (this.bounds["time"] != null) {
      let timedelta = Math.trunc((this.bounds["time"].max - this.bounds["time"].min) / 3600);
      if (timedelta > 24) {
        throw new Error(`Invalid operation : more than 24 hours between flights (${timedelta} hours)`);
      }
      this.scales["time"] = new TimeScale(this.bounds["time"], "ground speed", 1, default_gradient, 16, this.tz_offset);
    }
    if (this.bounds["tec"] != null) {
      this.scales["tec"] = new ZeroCenteredScale(this.bounds["tec"], "climb with energy compensation", 1, gradient);
    }
    if (this.bounds["t"] != null) {
      this.scales["t"] = new Scale(this.bounds["t"], "time");
    }
    if (this.bounds["tas"] != null) {
      this.scales["tas"] = new Scale(this.bounds["tas"], "air speed");
    }
    if (this.bounds["ele"]) {
      this.scales["altitude"] = new Scale(this.bounds["ele"], "altitude");
      for (let i = 0; i < 3; i++) {
        let altitude_styles = [];
        let cs = this.scales["altitude"].colors();
        for (let j = 0, c = cs[j]; j < cs.length; j++, c = cs[j]) {
          let ballon_style = new KML.BalloonStyle([new KML.SimpleElement("text", "$[description]")]);
          let icon_style = new KML.IconStyle([this.stock.icons[i], new KML.color(c), new KML.scale(this.stock.icon_scales[i].toString())]);
          let label_style = new KML.LabelStyle(c, this.stock.label_scales[i]);
          altitude_styles.push(new KML.Style([ballon_style, icon_style, label_style]));
        }
        this.stock.kmz.add_roots(altitude_styles);
        this.altitude_styles.push(altitude_styles);
      }
    }
    if (flights.length == 1) {
      if (flights[0].track.elevation_data) {
        this.default_track = "climb";
      } else {
        this.default_track = "speed";
      }
    }
    return new Promise((res) => {
      let kmz = new KMZ();
      kmz.add_siblings([this.stock.kmz]);
      if (task) {
        kmz.add_siblings([Flight.make_task_folder(this, task)]);
      }
      Promise.all(flights.map((f) => f.to_kmz(this))).then((kmzs) => {
        kmz.add_siblings(kmzs);
      }).then(() => {
        if (kml) {
          kmz.get_data(2.1, true).then(res);
        } else {
          kmz.get_data(2.1, false, this.options.dbg_serialize).then(res);
        }
      });
    });
  }
  flights2kml(flights, options = defaultconfig, task) {
    return this.convert(flights, options, task);
  }
  flights2kmz(flights, options = defaultconfig, task) {
    return this.convert(flights, options, task);
  }
};
__name(FlightConvert, "FlightConvert");

// igc2kmz/task.ts
var import_google_polyline = __toESM(require_polyline());
var Turnpoint = class {
  constructor(name, lat, lon, alt) {
    this.name = "";
    this.description = "";
    this.type = 0 /* NONE */;
    this.radius = 0;
    this.name = name ?? "";
    this.coord = Coord.deg(lat, lon, alt);
  }
};
__name(Turnpoint, "Turnpoint");
var Task = class {
  constructor() {
    this.name = null;
    this.tps = [];
  }
  static loadTask(taskcontent) {
    try {
      let to = JSON.parse(taskcontent);
      if (to.taskType == "CLASSIC") {
        if (to.version == 1) {
          return new XCTrackTask(taskcontent);
        } else if (to.version == 2) {
          return new XCTrackTaskV2(taskcontent);
        }
      } else if (to.V == 2 && to.T == "W") {
        return new XCTrackWaypointsTask(taskcontent);
      }
    } catch {
    }
    return null;
  }
  add_turnpoint(name, lat, lon, alt) {
    let tp = new Turnpoint(name, lat, lon, alt);
    this.tps.push(tp);
    return tp;
  }
};
__name(Task, "Task");
var XCTrackTask = class extends Task {
  constructor(taskcontent) {
    super();
    let task = JSON.parse(taskcontent);
    if (Array.isArray(task.turnpoints)) {
      task.turnpoints.forEach((t) => {
        if (typeof t.radius !== "number" || typeof t.waypoint !== "object")
          return;
        let tp = this.parse_waypoint(t.waypoint);
        if (tp) {
          tp.radius = t.radius;
          if (typeof t.type === "string") {
            switch (t.type) {
              case "SSS":
                tp.type = 2 /* SSS */;
                break;
              case "ESS":
                tp.type = 3 /* ESS */;
                break;
              case "TAKEOFF":
                tp.type = 1 /* TAKEOFF */;
                break;
              default:
                tp.type = 0 /* NONE */;
                break;
            }
          }
        }
      });
    }
  }
  parse_waypoint(wp) {
    if (typeof wp.name !== "string" || typeof wp.lat !== "number" || typeof wp.lon !== "number" || typeof wp.altSmoothed !== "number")
      return null;
    let tp = this.add_turnpoint(wp.name, wp.lat, wp.lon, wp.altSmoothed);
    if (tp && typeof wp.description === "string") {
      tp.description = wp.description;
    }
    return tp;
  }
};
__name(XCTrackTask, "XCTrackTask");
var XCTrackTaskV2 = class extends Task {
  constructor(taskcontent) {
    super();
    let task = JSON.parse(taskcontent);
    if (Array.isArray(task.t)) {
      task.t.forEach((t) => {
        if (typeof t.z !== "string" || typeof t.n !== "string")
          return;
        let pts = (0, import_google_polyline.decode)(t.z);
        if (pts.length <= 0)
          return;
        let tp = this.add_turnpoint(t.n, pts[0][1], pts[0][0]);
        if (pts.length > 1) {
          tp.radius = Coord.haversineDistance(pts[0], pts[1]);
        }
        if (tp && typeof t.d === "string") {
          tp.description = t.d;
        }
      });
    }
  }
};
__name(XCTrackTaskV2, "XCTrackTaskV2");
var XCTrackWaypointsTask = class extends Task {
  constructor(taskcontent) {
    super();
    let task = JSON.parse(taskcontent);
    if (Array.isArray(task.t)) {
      task.t.forEach((t) => {
        if (typeof t.z !== "string" || typeof t.n !== "string")
          return;
        (0, import_google_polyline.decode)(t.z).forEach((c) => this.add_turnpoint(t.n, c[1], c[0]));
      });
    }
  }
};
__name(XCTrackWaypointsTask, "XCTrackWaypointsTask");

// igc2kmz/track.ts
var import_igc_xc_score2 = __toESM(require_dist());

// igc2kmz/xc.ts
var import_igc_xc_score = __toESM(require_dist());
var XC = class {
  constructor(solution, options) {
    this.closingCircleRadius = 0;
    this.options = options;
    this.solution = solution;
    try {
      let rules = import_igc_xc_score.scoringRules[this.options.xc_score_rules].find((sr) => sr.name == solution.opt.scoring.name);
      if (rules && solution.scoreInfo && typeof rules.closingDistance === "function") {
        this.closingCircleRadius = rules.closingDistance(solution.scoreInfo.distance, { "scoring": rules }) * 1e3;
      }
    } catch {
    }
  }
};
__name(XC, "XC");

// igc2kmz/track.ts
var Track = class {
  //extensions: Record<string, string[]> = {};
  constructor(flight, filename, options = defaultconfig) {
    this.bounds = {};
    this.elevation_data = false;
    this.s = [0];
    this.ele = [];
    this.total_dz_positive = 0;
    this.max_dz_positive = 0;
    this.min_ele = 0;
    this.speed = [];
    this.climb = [];
    this.tec = [];
    this.progress = [];
    this.thermals = [];
    this.glides = [];
    this.dives = [];
    this.declaration = null;
    this.xc_score = null;
    this.options = options;
    this.flight = flight;
    this.filename = filename ?? "flight.igc";
    let pressure_altitude = this.options.pressure_altitude && flight.fixes.length > 0 && flight.fixes[0].pressureAltitude !== null;
    let getRealAltitude = /* @__PURE__ */ __name((alt) => Utils.getAltitude(Utils.getPressure(alt, SEALEVEL_QNH), options.qnh), "getRealAltitude");
    this.coords = Track.filter(flight.fixes.map((f) => Coord.deg(f.latitude, f.longitude, (pressure_altitude ? getRealAltitude(f.pressureAltitude ?? 0) : f.gpsAltitude) || 0, new Date(f.timestamp))));
    this.t = this.coords.map((c) => c.dt.getTime() / 1e3);
    if (this.t.length <= 0) {
      throw new Error("No valid records in " + this.filename);
    } else if (this.t.length < 5) {
      throw new Error(`The IGC '${this.filename}' seems corrupted : ${this.t.length} records, starting at ${this.coords[0].dt}`);
    } else if (this.t.length < 60 || this.coords[0].dt > /* @__PURE__ */ new Date()) {
      console.warn(`The IGC '${this.filename}' seems corrupted : ${this.t.length} records, starting at ${this.coords[0].dt}`);
    }
    this.pilot_name = flight.pilot || "";
    this.glider_type = flight.gliderType || "";
    this.glider_id = flight.registration || "";
    if (flight.task && flight.task.points && flight.task.points.length > 0) {
      this.declaration = new Task();
      flight.task.points.forEach((tp) => this.declaration?.add_turnpoint(tp.name, tp.latitude, tp.longitude));
    }
    this.analyse(20);
  }
  static filter(coords) {
    let result = [coords[0]];
    let last_c = coords[0];
    let c;
    for (let i = 0; i < coords.length; i++) {
      c = coords[i];
      if (c.dt <= last_c.dt)
        continue;
      let ds = last_c.distance_to(c);
      let dt = (c.dt.getTime() - last_c.dt.getTime()) / 1e3;
      if (dt == 0 || ds / dt > 100)
        continue;
      let dz = c.ele - last_c.ele;
      if (dz / dt < -30 || 30 < dz / dt)
        continue;
      result.push(c);
      last_c = c;
    }
    return result;
  }
  indexOf(dt) {
    let t = dt.getTime() / 1e3;
    if (t < this.t[0]) {
      return 0;
    } else if (this.t[this.t.length - 1] <= t) {
      return this.coords.length - 1;
    }
    return Utils.find_first_ge(this.t, t) ?? 0;
  }
  coord_at(dt) {
    let t = dt.getTime() / 1e3;
    let index = this.indexOf(dt);
    if (index == 0 || index == this.coords.length - 1) {
      return this.coords[index];
    } else if (this.t[index] == t) {
      return this.coords[index];
    } else {
      let delta = (t - this.t[index - 1]) / (this.t[index] - this.t[index - 1]);
      return this.coords[index - 1].interpolate(this.coords[index], delta);
    }
  }
  analyse(dt) {
    let n = this.coords.length;
    let period = (this.coords[n - 1].dt.getTime() - this.coords[0].dt.getTime()) / 1e3 / n;
    if (dt < 2 * period)
      dt = 2 * period;
    this.bounds["ele"] = Bounds.createbounds(this.coords.map((c) => c.ele));
    this.bounds["time"] = Bounds.createbounds([this.coords[0].dt.getTime() / 1e3, this.coords[n - 1].dt.getTime() / 1e3]);
    this.bounds["t"] = Bounds.createbounds([this.t[0], this.t[n - 1]]);
    this.bounds["tas"] = Bounds.createbounds(this.flight.fixes.filter((f) => f.extensions.hasOwnProperty("TAS")).map((f) => parseInt(f.extensions["TAS"])));
    if (this.bounds["ele"] && (this.bounds["ele"].min != 0 || this.bounds["ele"].max != 0))
      this.elevation_data = true;
    this.min_ele = this.coords[0].ele;
    let dz = 0;
    for (let i = 1; i < n; i++) {
      this.s.push(this.s[i - 1] + this.coords[i - 1].distance_to(this.coords[i]));
      this.ele.push((this.coords[i - 1].ele + this.coords[i - 1].ele) / 2);
      dz = this.coords[i].ele - this.coords[i - 1].ele;
      if (dz > 0)
        this.total_dz_positive += dz;
      if (this.coords[i].ele < this.min_ele)
        this.min_ele = this.coords[i].ele;
      else if (this.coords[i].ele - this.min_ele > this.max_dz_positive)
        this.max_dz_positive = this.coords[i].ele - this.min_ele;
    }
    let i0 = 0, i1 = 0, t0 = 0, t1 = 0, s0 = 0, s1 = 0, delta0 = 0, delta1 = 0, ds = 0, ds2 = 0, dp = 0, progress = 0;
    let coord0, coord1;
    for (let i = 1; i < n; i++) {
      t0 = (this.t[i - 1] + this.t[i]) / 2 - dt / 2;
      while (this.t[i0] <= t0) {
        i0++;
      }
      if (i0 == 0) {
        coord0 = this.coords[0];
        s0 = this.s[0];
      } else {
        delta0 = (t0 - this.t[i0 - 1]) / (this.t[i0] - this.t[i0 - 1]);
        coord0 = this.coords[i0 - 1].interpolate(this.coords[i0], delta0);
        s0 = (1 - delta0) * this.s[i0 - 1] + delta0 * this.s[i0];
      }
      t1 = t0 + dt;
      while (i1 < n && this.t[i1] < t1) {
        i1++;
      }
      if (i1 == n) {
        coord1 = this.coords[n - 1];
        s1 = this.s[n - 1];
      } else {
        delta1 = (t1 - this.t[i1 - 1]) / (this.t[i1] - this.t[i1 - 1]);
        coord1 = this.coords[i1 - 1].interpolate(this.coords[i1], delta1);
        s1 = (1 - delta1) * this.s[i1 - 1] + delta1 * this.s[i1];
      }
      ds = s1 - s0;
      ds2 = s1 * s1 - s0 * s0;
      dz = coord1.ele - coord0.ele;
      dp = coord0.distance_to(coord1);
      if (ds == 0) {
        progress = 0;
      } else if (dp > ds) {
        progress = 1;
      } else {
        progress = dp / ds;
      }
      this.speed.push(3.6 * ds / dt);
      this.climb.push(dz / dt);
      this.tec.push(dz / dt + ds2 / (2 * 9.80665));
      this.progress.push(progress);
    }
    this.bounds["speed"] = Bounds.createbounds(this.speed);
    this.bounds["climb"] = Bounds.createbounds(this.climb);
    this.bounds["tec"] = Bounds.createbounds(this.tec);
    let state = Array(n - 1).fill(0 /* UNKNOWN */);
    let glide = this.progress.map((p) => p >= 0.9);
    let sl;
    let indexes = Utils.condense(Utils.runs_where(glide), this.t, 60);
    for (let i = 0; i < indexes.length; i++) {
      sl = indexes[i];
      for (let j = sl.start; j < sl.stop; j++) {
        state[j] = 2 /* GLIDE */;
      }
    }
    let dive = Array.from(Array(n - 1)).map((v, i) => this.progress[i] < 0.9 && this.climb[i] < 1);
    indexes = Utils.condense(Utils.runs_where(dive), this.t, 30);
    for (let i = 0; i < indexes.length; i++) {
      sl = indexes[i];
      if (this.coords[sl.stop].ele - this.coords[sl.start].ele >= -100)
        continue;
      for (let j = sl.start; j < sl.stop; j++) {
        state[j] = 3 /* DIVE */;
      }
    }
    let thermal = Array.from(Array(n - 1)).map((v, i) => this.progress[i] < 0.9 && this.climb[i] > 0 || this.speed[i] < 10 && this.climb[i] > 0 || this.climb[i] > 1);
    indexes = Utils.condense(Utils.runs_where(thermal), this.t, 60);
    for (let i = 0; i < indexes.length; i++) {
      sl = indexes[i];
      for (let j = sl.start; j < sl.stop; j++) {
        state[j] = 1 /* THERMAL */;
      }
    }
    indexes = Utils.runs(state);
    for (let i = 0; i < indexes.length; i++) {
      sl = indexes[i];
      dt = this.t[sl.stop] - this.t[sl.start];
      dz = this.coords[sl.stop].ele - this.coords[sl.start].ele;
      switch (state[sl.start]) {
        case 1 /* THERMAL */:
          if (dt >= 60 && dz > 50) {
            this.thermals.push(sl);
          }
          break;
        case 3 /* DIVE */:
          if (dt >= 30 && dz / dt < -2) {
            this.dives.push(sl);
          }
          break;
        case 2 /* GLIDE */:
          if (dt >= 120) {
            this.glides.push(sl);
          }
          break;
      }
    }
    if (this.options.xc_score) {
      const tend = Date.now() + this.options.xc_score_maxtime * 1e3;
      if (!import_igc_xc_score2.scoringRules.hasOwnProperty(this.options.xc_score_rules))
        this.options.xc_score_rules = defaultconfig.xc_score_rules;
      const it = (0, import_igc_xc_score2.solver)(this.flight, import_igc_xc_score2.scoringRules[this.options.xc_score_rules]);
      let newbest, best;
      do {
        newbest = it.next();
        if (best === void 0 || newbest.value.id !== best.id) {
          best = newbest.value;
        }
        if (Date.now() > tend) {
          break;
        }
      } while (!newbest.done);
      if (best) {
        this.xc_score = new XC(best, this.options);
      }
    }
  }
};
__name(Track, "Track");

// igc2kmz/photo.ts
var import_exifr = __toESM(require_full_umd());
var Photo = class {
  constructor(name, image, date, coord = null, description = null) {
    this.coord = null;
    this.elevation_data = false;
    this.description = null;
    this.id = "img_" + RandomIdGenerator.makeid();
    this.name = name;
    this.image = image;
    this.date = date;
    this.coord = coord;
    this.elevation_data = !!coord;
    this.description = description;
  }
  get filename() {
    let ext = "jpg";
    let idx = this.name.lastIndexOf(".");
    if (idx > -1) {
      ext = this.name.substring(idx + 1);
    }
    return "images/" + this.id + "." + ext;
  }
  to_html_img() {
    return `<img alt="${this.name}" src="${this.filename}" style="max-width:1024px"/>`;
  }
  static parse(name, image) {
    name = name ?? "image";
    name.replaceAll("\\", "/");
    let idx = name.lastIndexOf("/");
    if (idx > -1) {
      name = name.substring(idx + 1);
    }
    return new Promise((res) => {
      import_exifr.default.parse(image ?? name).then((exif) => {
        let date = new Date(2e3, 0, 1);
        let coord = void 0;
        let description = null;
        if (exif) {
          if (exif.DateTimeOriginal && typeof exif.DateTimeOriginal.getTime === "function") {
            date = exif.DateTimeOriginal;
          } else if (exif.DateTime && typeof exif.DateTime.getTime === "function") {
            date = exif.DateTime;
          }
          let latitude = null;
          if (typeof exif.latitude === "number") {
            latitude = exif.latitude;
          } else if (Array.isArray(exif.GPSLatitude) && exif.GPSLatitude.length == 3) {
            latitude = exif.GPSLatitude[0] + exif.GPSLatitude[1] / 60 + exif.GPSLatitude[2] / (60 * 60);
          }
          let longitude = null;
          if (typeof exif.longitude === "number") {
            longitude = exif.longitude;
          } else if (Array.isArray(exif.GPSLongitude) && exif.GPSLongitude.length == 3) {
            longitude = exif.GPSLongitude[0] + exif.GPSLongitude[1] / 60 + exif.GPSLongitude[2] / (60 * 60);
          }
          let altitude = typeof exif.GPSAltitude === "number" ? exif.GPSAltitude : void 0;
          if (latitude && longitude) {
            coord = Coord.deg(latitude, longitude, altitude);
          }
          if (typeof exif.UserComment === "string") {
            description = exif.UserComment;
          }
        }
        let photo = new Photo(name, image, date, coord, description);
        res(photo);
      });
    });
  }
};
__name(Photo, "Photo");

// igc2kmz/igc2kmz.ts
var IGCParser = require_igc_parser();
var _convert, convert_fn;
var IGC2KMZ = class {
  constructor(cv, options = defaultconfig) {
    __privateAdd(this, _convert);
    this.igccontents = [];
    this.filenames = [];
    this.taskcontent = null;
    this.photos = [];
    this.cv = cv;
    this.options = { ...defaultconfig, ...options };
  }
  setOptions(options) {
    this.options = { ...defaultconfig, ...options };
  }
  addIGC(content, filename) {
    this.igccontents.push([filename ?? `track${this.igccontents.length}.igc`, content]);
  }
  addTask(taskcontent) {
    this.taskcontent = taskcontent;
  }
  addPhoto(content, filename) {
    this.photos.push([filename ?? `track${this.photos.length + 1}.igc`, content]);
  }
  clear() {
    this.photos = this.filenames = this.igccontents = [];
    this.taskcontent = null;
  }
  getFlightsList() {
    let flights = [];
    let firstlaunch = -1;
    for (let i = 0; i < this.igccontents.length; i++) {
      let igc = IGCParser.parse(this.igccontents[i][1], { lenient: true });
      if (this.options.same_start && igc.fixes.length > 0) {
        if (firstlaunch < 0) {
          firstlaunch = igc.fixes[0].timestamp;
        } else {
          let offset = firstlaunch - igc.fixes[0].timestamp;
          igc.fixes.forEach((f) => f.timestamp += offset);
        }
      }
      flights.push(new Flight(new Track(igc, this.igccontents[i][0], this.options)));
    }
    return flights;
  }
  toKMZ() {
    return __privateMethod(this, _convert, convert_fn).call(this);
  }
  toKML() {
    return __privateMethod(this, _convert, convert_fn).call(this, true);
  }
};
__name(IGC2KMZ, "IGC2KMZ");
_convert = new WeakSet();
convert_fn = /* @__PURE__ */ __name(function(kml = false) {
  let flights = [];
  let firstlaunch = -1;
  for (let i = 0; i < this.igccontents.length; i++) {
    let igc = IGCParser.parse(this.igccontents[i][1], { lenient: true });
    if (this.options.same_start && igc.fixes.length > 0) {
      if (firstlaunch < 0) {
        firstlaunch = igc.fixes[0].timestamp;
      } else {
        let offset = firstlaunch - igc.fixes[0].timestamp;
        igc.fixes.forEach((f) => f.timestamp += offset);
      }
    }
    flights.push(new Flight(new Track(igc, this.igccontents[i][0], this.options)));
  }
  let task = null;
  if (this.taskcontent) {
    task = Task.loadTask(this.taskcontent);
  }
  let promises = [];
  if (flights.length > 0 && this.photos) {
    this.photos.forEach((photo) => {
      promises.push(Photo.parse(photo[0], photo[1]));
    });
  }
  return new Promise((res) => {
    Promise.all(promises).then((photos) => {
      if (flights.length > 0 && photos.length > 0) {
        flights[flights.length - 1].photos.push(...photos);
      }
      let fcv = new FlightConvert(this.cv);
      fcv.convert(flights, this.options, task, kml).then(res);
    });
  });
}, "#convert");

// igc2kmz/nodewrapper.ts
var HeadlessCanvas = class {
  constructor() {
    this.cvs = [];
    this.font_loading = false;
    this.font_loaded = false;
    this.fontfilename = "OpenSans-Regular.ttf";
    this.fontname = "sans-serif";
    this.loadfontcbs = [];
  }
  // opentype doesn't load font from data url from node context, just web
  loadfont() {
    return new Promise((res) => {
      this.loadfontcbs.push(res);
      if (this.font_loading)
        return;
      this.font_loading = true;
      let sourcesansprofont = OpenSans_Regular_default.substring(OpenSans_Regular_default.indexOf("base64,") + "base64,".length);
      (0, import_promises.writeFile)(this.fontfilename, sourcesansprofont, "base64").then(() => {
        let fnt = PImage.registerFont(this.fontfilename, this.fontname, 400, "bold", "");
        fnt.load(() => {
          this.font_loading = false;
          this.font_loaded = true;
          (0, import_fs.unlink)(this.fontfilename, () => {
          });
          this.loadfontcbs.forEach((r2) => r2());
        });
      });
    });
  }
  create_canvas(width, height, options) {
    return new Promise((res) => {
      let ncv = this.cvs.length;
      this.cvs.push(PImage.make(width, height, { ...options }));
      if (this.font_loaded) {
        res(this.cvs[ncv]);
      } else {
        this.loadfont().then(() => res(this.cvs[ncv]));
      }
    });
  }
  get_base64(cv) {
    return new Promise((res, rej) => {
      let base64toout = new import_base64_stream.Base64Encode();
      base64toout.pipe((0, import_concat_stream.default)({ encoding: "string" }, res)).on("error", rej);
      PImage.encodePNGToStream(cv, base64toout).catch(rej);
    });
  }
};
__name(HeadlessCanvas, "HeadlessCanvas");
function createconverter(igccontents, infilenames, taskcontent, photos, options = defaultconfig) {
  igccontents = Array.isArray(igccontents) ? igccontents : [igccontents ?? ""];
  infilenames = Array.isArray(infilenames) ? infilenames : [infilenames ?? ""];
  if (infilenames.length < igccontents.length) {
    for (let i = infilenames.length; i < igccontents.length; i++) {
      infilenames.push(`track${i + 1}.igc`);
    }
  }
  let cv = new HeadlessCanvas();
  let converter = new IGC2KMZ(cv, options);
  igccontents.forEach((igc, i) => converter.addIGC(igc, infilenames && infilenames[i] || ""));
  if (taskcontent) {
    converter.addTask(taskcontent);
  }
  if (photos) {
    photos.forEach((photo) => {
      converter.addPhoto(photo[1], photo[0]);
    });
  }
  return converter;
}
__name(createconverter, "createconverter");
function igc2kmz(igccontents, infilenames, taskcontent, photos, options = defaultconfig) {
  return createconverter(igccontents, infilenames, taskcontent, photos, options).toKMZ();
}
__name(igc2kmz, "igc2kmz");
function igc2kml(igccontents, infilenames, taskcontent, photos, options = defaultconfig) {
  return createconverter(igccontents, infilenames, taskcontent, photos, options).toKML();
}
__name(igc2kml, "igc2kml");
function igc2Data(igccontents, infilenames, taskcontent, photos, options = defaultconfig) {
  return createconverter(igccontents, infilenames, taskcontent, photos, options).getFlightsList();
}
__name(igc2Data, "igc2Data");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  igc2Data,
  igc2kml,
  igc2kmz
});
